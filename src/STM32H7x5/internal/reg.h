/**
 * This file is part of the Titan Flight Computer Project
 * Copyright (c) 2024 UW SARP
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 * 
 * @file src/STM32H745x5/internal/reg.h
 * @authors Aaron McBride
 * @brief Register/field utilities and definitions. 
 */

#pragma once
#include "stdint.h"
#include "stddef.h"
#include "stdbool.h"

#ifdef __ICCARM__
  #pragma language = extended
#endif

#if defined(__cplusplus)
  extern "C" {
#endif

  /**********************************************************************************************
   * @section Implementation Resources
   **********************************************************************************************/

  // Qualifier for pointers to "read-only" registers.
  #define RO_ const volatile

  // Qualifier for pointers to "write-only" registers.
  #define WO_ volatile

  // Qualifier for pointers to "read-write" registers.
  #define RW_ volatile

  // Used for implementing compile time logic related to "NX"
  #define opt_(a, b, c, ...) c

  /**********************************************************************************************
   * @section Utilities
   **********************************************************************************************/

  /** @brief Denotes the lack of an index. */
  #define NX , 

  /**
   * @brief Writes a value to a field.
   * @param v (expression) The value to write to the field.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's 
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's 
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or 
   *           "NX" if it is not indexed.
   * @returns Nothing.
   * @see NX
   */
  #define write(v, p, pn, r, rn, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    *ptr = (*ptr & ~msk) | ((typeof(msk)(v) << pos) & msk); \
  })

  /**
   * @brief Writes two values to two fields at the same time.
   * @param v1 (expression) The value to write to the first field.
   * @param v2 (expression) The value to write to the second field.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's 
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's 
   *           register or "NX" if it is not indexed.
   * @param f1 (token) The name of the first target field.
   * @param fn1 (integer expression) The index of the first target field or 
   *            "NX" if it is not indexed.
   * @param f2 (token) The name of the second target field.
   * @param fn2 (integer expression) The index of the second target field or 
   *            "NX" if it is not indexed.
   * @returns Nothing.
   * @see NX
   */
  #define write2(v1, v2, p, pn, r, rn, f1, fn1, f2, fn2) ({ \
    __auto_type const fn1_ = opt_(fn1, 0, (fn1)); \
    __auto_type const fn2_ = opt_(fn2, 0, (fn2)); \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk1 = (p##_##r##_##f1##_MSK opt_(, fn1, [fn1_])); \
    __auto_type const msk2 = (p##_##r##_##f2##_MSK opt_(, fn2, [fn2_])); \
    __auto_type const pos1 = (p##_##r##_##f1##_POS opt_(, fn1, [fn1_])); \
    __auto_type const pos2 = (p##_##r##_##f2##_POS opt_(, fn2, [fn2_])); \
    *ptr = (*ptr & ~(msk1 | msk2)) | \
        ((typeof(msk1)(v1) << pos1) & msk1) | \
        ((typeof(msk2)(v2) << pos2) & msk2);  \
  })

  /**
   * @brief Sets or clears the bits of a field.
   * @param v (boolean expression) The value to set the field's bits to.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's 
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's 
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or 
   *           "NX" if it is not indexed.
   * @returns Nothing.
   * @see NX
   */
  #define set(v, p, pn, r, rn, f, fn) ({ \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn])); \
    *ptr = (*ptr & ~msk) | (typeof(msk)(!!(v)) * msk); \
  })

  /**
   * @brief Reads the value of a field.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's 
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's 
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or 
   *           "NX" if it is not indexed.
   * @returns The value of the target field.
   * @see NX
   */
  #define read(p, pn, r, rn, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    (*ptr & msk) >> pos; \
  })

  /**
   * @brief Determines if the bits in a field are set or cleared.
   * @param v (boolean expression) The value to compare the field's bits to.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or
   *           "NX" if it is not indexed.
   * @returns True if all bits in the target field equal the given value,
   *          or false otherwise.
   * @see NX
   */
  #define is_set(v, p, pn, r, rn, f, fn) ({ \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn])); \
    (*ptr & msk) == (typeof(msk)(!!(v)) * msk); \
  })

  /**
   * @brief Moves a value to the location of a field.
   * @param v (expression) The value to format.
   * @param p (token) The name of the target field's peripheral.
   * @param r (token) The name of the target field's register.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or 
   *           "NX" if it is not indexed.
   * @returns The given value moved to the location of the target field.
   * @note - This macro has no side effects.
   * @see NX
   */
  #define v2f(v, p, r, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    (typeof(msk)(v) << pos) & msk; \
  })

  /**
   * @brief Extracts the value of a field.
   * @param v (expression) The value to extract the field from.
   * @param p (token) The name of the target field's peripheral.
   * @param r (token) The name of the target field's register.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or
   *           "NX" if it is not indexed.
   * @returns The value of the target field.
   * @note - This macro has no side effects.
   * @see NX
   */
  #define f2v(v, p, r, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    (typeof(msk)(v) & msk) >> pos; \
  })

  /**
   * @brief Determines if a value can be fully represented in a field.
   * @param v (expression) The value to query.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or
   *           "NX" if it is not indexed.
   * @returns True if the given value can be fully represented in the
   *          target field (i.e. its bit width is less than or equal to
   *          that of the field), or false otherwise.
   * @see NX
   */
  #define can_write(v, p, pn, r, rn, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const ptr = (p##_##r##_PTR opt_(, pn, [pn]) opt_(, rn, [rn])); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    typeof(msk) const v_ = typeof(msk)(v); \
    (sizeof(v) <= sizeof(*ptr)) && (((v_ & msk) >> pos) == v_); \
  })

  /**
   * @brief Determines if a register exists.
   * @param p (token) The name of the target register.
   * @param pn (integer expression) The index of the target register or
   *           "NX" if it is not indexed.
   * @param r (token) The name of the target register.
   * @param rn (integer expression) The index of the target register or
   *           "NX" if it is not indexed.
   * @returns True if the target register exists, or false otherwise.
   * @see NX
   */
  #define rvalid(p, pn, r, rn) ({ \
    __auto_type const pn_ = opt_(pn, 0, (pn)); \
    __auto_type const rn_ = opt_(rn, 0, (rn)); \
    const int32_t d1s = sizeof(p##_##r##_PTR); \
    const int32_t d2s = sizeof(p##_##r##_PTR opt_(, pn, [0])); \
    const int32_t d3s = sizeof(p##_##r##_PTR opt_(, pn, [0]) opt_(, rn, [0])); \
    (opt_(pn, 1, 0) || (pn_ >= 0 && pn_ <= (d1s / d2s))) && \
    (opt_(rn, 1, 0) || (rn_ >= 0 && rn_ <= (d2s / d3s))) && \
    (d3s != NULL); \
  })

  /**
   * @brief Determines if a field exists.
   * @param p (token) The name of the target field's peripheral.
   * @param r (token) The name of the target field's register.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or
   *           "NX" if it is not indexed.
   * @returns True if the target field exists, or false otherwise.
   * @see NX
   */
  #define fvalid(p, r, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    const int32_t d1s = sizeof(p##_##r##_##f##_MSK); \
    const int32_t d2s = sizeof(p##_##r##_##f##_MSK opt_(, fn, [0])); \
    (opt_(fn, 1, 0) || (fn_ >= 0 && fn_ <= (d1s / d2s))) && \
    (d2s != 0U); \
  })

  /**
   * @brief Determines the maximum value that can be represented in a field.
   * @param p (token) The name of the target field's peripheral.
   * @param pn (integer expression) The index of the target field's
   *           peripheral or "NX" if it is not indexed.
   * @param r (token) The name of the target field's register.
   * @param rn (integer expression) The index of the target field's
   *           register or "NX" if it is not indexed.
   * @param f (token) The name of the target field.
   * @param fn (integer expression) The index of the target field or
   *           "NX" if it is not indexed.
   * @returns The maximum value that can be represented in the target field.
   *          (i.e. the field's mask shifted right by its position).
   * @see NX
   */
  #define fmax(p, r, f, fn) ({ \
    __auto_type const fn_ = opt_(fn, 0, (fn)); \
    __auto_type const msk = (p##_##r##_##f##_MSK opt_(, fn, [fn_])); \
    __auto_type const pos = (p##_##r##_##f##_POS opt_(, fn, [fn_])); \
    msk >> pos; \
  })

  /**********************************************************************************************
   * @section COMP1 Register Information
   **********************************************************************************************/

  /**** @subsection COMP1 Register Pointers ****/

  static RO_ uint32_t* const COMP1_SR_PTR   = (RO_ uint32_t* const)0x58003800U;   /** @brief Comparator status register */
  static WO_ uint32_t* const COMP1_ICFR_PTR = (WO_ uint32_t* const)0x58003804U;   /** @brief Comparator interrupt clear flag register */
  static RW_ uint32_t* const COMP1_OR_PTR   = (RW_ uint32_t* const)0x58003808U;   /** @brief Comparator option register */

  /**** @subsection Enumerated COMP1 Register Pointers ****/

  static RW_ uint32_t* const COMP1_CFGRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5800380CU,   /** @brief Comparator configuration register 1 */
    [2] = (RW_ uint32_t* const)0x58003810U,   /** @brief Comparator configuration register 2 */
  };

  /**** @subsection COMP1 Register Field Masks ****/

  static const uint32_t COMP1_OR_AFOP_MSK        = 0x000007FFU;   /** @brief Selection of source for alternate function of output ports */
  static const uint32_t COMP1_OR_OR_MSK          = 0xFFFFF800U;   /** @brief Option register */
  static const uint32_t COMP1_CFGRx_EN_MSK       = 0x00000001U;   /** @brief COMP channel 1 enable bit */
  static const uint32_t COMP1_CFGRx_BRGEN_MSK    = 0x00000002U;   /** @brief Scaler bridge enable */
  static const uint32_t COMP1_CFGRx_SCALEN_MSK   = 0x00000004U;   /** @brief Voltage scaler enable bit */
  static const uint32_t COMP1_CFGRx_POLARITY_MSK = 0x00000008U;   /** @brief COMP channel 1 polarity selection bit */
  static const uint32_t COMP1_CFGRx_ITEN_MSK     = 0x00000040U;   /** @brief COMP channel 1 interrupt enable */
  static const uint32_t COMP1_CFGRx_HYST_MSK     = 0x00000300U;   /** @brief COMP channel 1 hysteresis selection bits */
  static const uint32_t COMP1_CFGRx_PWRMODE_MSK  = 0x00003000U;   /** @brief Power mode of the COMP channel 1 */
  static const uint32_t COMP1_CFGRx_INMSEL_MSK   = 0x00070000U;   /** @brief COMP channel 1 inverting input selection field */
  static const uint32_t COMP1_CFGRx_INPSEL_MSK   = 0x00100000U;   /** @brief COMP channel 1 non-inverting input selection bit */
  static const uint32_t COMP1_CFGRx_BLANKING_MSK = 0x0F000000U;   /** @brief COMP channel 1 blanking source selection bits */
  static const uint32_t COMP1_CFGRx_LOCK_MSK     = 0x80000000U;   /** @brief Lock bit */

  /**** @subsection Enumerated COMP1 Register Field Masks ****/

  static const uint32_t COMP1_SR_CxVAL_MSK[3] = {
    [1] = 0x00000001U,   /** @brief COMP channel 1 output status bit */
    [2] = 0x00000002U,   /** @brief COMP channel 2 output status bit */
  };

  static const uint32_t COMP1_SR_CxIF_MSK[3] = {
    [1] = 0x00010000U,   /** @brief COMP channel 1 interrupt flag */
    [2] = 0x00020000U,   /** @brief COMP channel 2 interrupt flag */
  };

  static const uint32_t COMP1_ICFR_CCxIF_MSK[3] = {
    [1] = 0x00010000U,   /** @brief Clear COMP channel 1 interrupt flag */
    [2] = 0x00020000U,   /** @brief Clear COMP channel 2 interrupt flag */
  };

  /**** @subsection COMP1 Register Field Positions ****/

  static const int32_t COMP1_OR_AFOP_POS        = 0;    /** @brief Selection of source for alternate function of output ports */
  static const int32_t COMP1_OR_OR_POS          = 11;   /** @brief Option register */
  static const int32_t COMP1_CFGRx_EN_POS       = 0;    /** @brief COMP channel 1 enable bit */
  static const int32_t COMP1_CFGRx_BRGEN_POS    = 1;    /** @brief Scaler bridge enable */
  static const int32_t COMP1_CFGRx_SCALEN_POS   = 2;    /** @brief Voltage scaler enable bit */
  static const int32_t COMP1_CFGRx_POLARITY_POS = 3;    /** @brief COMP channel 1 polarity selection bit */
  static const int32_t COMP1_CFGRx_ITEN_POS     = 6;    /** @brief COMP channel 1 interrupt enable */
  static const int32_t COMP1_CFGRx_HYST_POS     = 8;    /** @brief COMP channel 1 hysteresis selection bits */
  static const int32_t COMP1_CFGRx_PWRMODE_POS  = 12;   /** @brief Power mode of the COMP channel 1 */
  static const int32_t COMP1_CFGRx_INMSEL_POS   = 16;   /** @brief COMP channel 1 inverting input selection field */
  static const int32_t COMP1_CFGRx_INPSEL_POS   = 20;   /** @brief COMP channel 1 non-inverting input selection bit */
  static const int32_t COMP1_CFGRx_BLANKING_POS = 24;   /** @brief COMP channel 1 blanking source selection bits */
  static const int32_t COMP1_CFGRx_LOCK_POS     = 31;   /** @brief Lock bit */

  /**** @subsection Enumerated COMP1 Register Field Positions ****/

  static const int32_t COMP1_SR_CxVAL_POS[3] = {
    [1] = 0,   /** @brief COMP channel 1 output status bit */
    [2] = 1,   /** @brief COMP channel 2 output status bit */
  };

  static const int32_t COMP1_SR_CxIF_POS[3] = {
    [1] = 16,   /** @brief COMP channel 1 interrupt flag */
    [2] = 17,   /** @brief COMP channel 2 interrupt flag */
  };

  static const int32_t COMP1_ICFR_CCxIF_POS[3] = {
    [1] = 16,   /** @brief Clear COMP channel 1 interrupt flag */
    [2] = 17,   /** @brief Clear COMP channel 2 interrupt flag */
  };

  /**********************************************************************************************
   * @section CRx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated CRx Register Pointers ****/

  static RW_ uint32_t* const CRx_CR_PTR[19] = {
    [2]  = (RW_ uint32_t* const)0x58024C00U,   /** @brief Data register */
    [18] = (RW_ uint32_t* const)0x40008400U,   /** @brief CRS control register */
  };

  static RW_ uint32_t* const CRx_CFGR_PTR[19] = {
    [2]  = (RW_ uint32_t* const)0x58024C04U,   /** @brief Independent data register */
    [18] = (RW_ uint32_t* const)0x40008404U,   /** @brief This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected. */
  };

  static RO_ uint32_t* const CRx_ISR_PTR[19] = {
    [2]  = (RO_ uint32_t* const)0x58024C08U,   /** @brief Control register */
    [18] = (RO_ uint32_t* const)0x40008408U,   /** @brief CRS interrupt and status register */
  };

  static RW_ uint32_t* const CRx_ICR_PTR[19] = {
    [2]  = (RW_ uint32_t* const)0x58024C0CU,   /** @brief Initial CRC value */
    [18] = (RW_ uint32_t* const)0x4000840CU,   /** @brief CRS interrupt flag clear register */
  };

  /**** @subsection CRx Register Field Masks ****/

  static const uint32_t CRx_CR_SYNCOKIE_MSK   = 0x00000001U;   /** @brief SYNC event OK interrupt enable */
  static const uint32_t CRx_CR_SYNCWARNIE_MSK = 0x00000002U;   /** @brief SYNC warning interrupt enable */
  static const uint32_t CRx_CR_ERRIE_MSK      = 0x00000004U;   /** @brief Synchronization or trimming error interrupt enable */
  static const uint32_t CRx_CR_ESYNCIE_MSK    = 0x00000008U;   /** @brief Expected SYNC interrupt enable */
  static const uint32_t CRx_CR_CEN_MSK        = 0x00000020U;   /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
  static const uint32_t CRx_CR_AUTOTRIMEN_MSK = 0x00000040U;   /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
  static const uint32_t CRx_CR_SWSYNC_MSK     = 0x00000080U;   /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
  static const uint32_t CRx_CR_TRIM_MSK       = 0x00003F00U;   /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
  static const uint32_t CRx_CFGR_RELOAD_MSK   = 0x0000FFFFU;   /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
  static const uint32_t CRx_CFGR_FELIM_MSK    = 0x00FF0000U;   /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
  static const uint32_t CRx_CFGR_SYNCDIV_MSK  = 0x07000000U;   /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
  static const uint32_t CRx_CFGR_SYNCSRC_MSK  = 0x30000000U;   /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
  static const uint32_t CRx_CFGR_SYNCPOL_MSK  = 0x80000000U;   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
  static const uint32_t CRx_ISR_SYNCOKF_MSK   = 0x00000001U;   /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_SYNCWARNF_MSK = 0x00000002U;   /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_ERRF_MSK      = 0x00000004U;   /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
  static const uint32_t CRx_ISR_ESYNCF_MSK    = 0x00000008U;   /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_SYNCERR_MSK   = 0x00000100U;   /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_SYNCMISS_MSK  = 0x00000200U;   /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_TRIMOVF_MSK   = 0x00000400U;   /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const uint32_t CRx_ISR_FEDIR_MSK     = 0x00008000U;   /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
  static const uint32_t CRx_ISR_FECAP_MSK     = 0xFFFF0000U;   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
  static const uint32_t CRx_ICR_SYNCOKC_MSK   = 0x00000001U;   /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
  static const uint32_t CRx_ICR_SYNCWARNC_MSK = 0x00000002U;   /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
  static const uint32_t CRx_ICR_ERRC_MSK      = 0x00000004U;   /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
  static const uint32_t CRx_ICR_ESYNCC_MSK    = 0x00000008U;   /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

  /**** @subsection CRx Register Field Positions ****/

  static const int32_t CRx_CR_SYNCOKIE_POS   = 0;    /** @brief SYNC event OK interrupt enable */
  static const int32_t CRx_CR_SYNCWARNIE_POS = 1;    /** @brief SYNC warning interrupt enable */
  static const int32_t CRx_CR_ERRIE_POS      = 2;    /** @brief Synchronization or trimming error interrupt enable */
  static const int32_t CRx_CR_ESYNCIE_POS    = 3;    /** @brief Expected SYNC interrupt enable */
  static const int32_t CRx_CR_CEN_POS        = 5;    /** @brief Frequency error counter enable this bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified. */
  static const int32_t CRx_CR_AUTOTRIMEN_POS = 6;    /** @brief Automatic trimming enable this bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details. */
  static const int32_t CRx_CR_SWSYNC_POS     = 7;    /** @brief Generate software SYNC event this bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware. */
  static const int32_t CRx_CR_TRIM_POS       = 8;    /** @brief HSI48 oscillator smooth trimming these bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 khz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only. */
  static const int32_t CRx_CFGR_RELOAD_POS   = 0;    /** @brief Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to section7.3.3: frequency error measurement for more details about counter behavior. */
  static const int32_t CRx_CFGR_FELIM_POS    = 16;   /** @brief Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP evaluation. */
  static const int32_t CRx_CFGR_SYNCDIV_POS  = 24;   /** @brief SYNC divider these bits are set and cleared by software to control the division factor of the SYNC signal. */
  static const int32_t CRx_CFGR_SYNCSRC_POS  = 28;   /** @brief SYNC signal source selection these bits are set and cleared by software to select the SYNC signal source. Note: when using USB LPM (link power management) and the device is in sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from sleep mode, the LSE or reference clock on the gpios should be used as SYNC signal. */
  static const int32_t CRx_CFGR_SYNCPOL_POS  = 31;   /** @brief SYNC polarity selection this bit is set and cleared by software to select the input polarity for the SYNC signal source. */
  static const int32_t CRx_ISR_SYNCOKF_POS   = 0;    /** @brief SYNC event OK flag this flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_SYNCWARNF_POS = 1;    /** @brief SYNC warning flag this flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_ERRF_POS      = 2;    /** @brief Error flag this flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits. */
  static const int32_t CRx_ISR_ESYNCF_POS    = 3;    /** @brief Expected SYNC flag this flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_SYNCERR_POS   = 8;    /** @brief SYNC error this flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_SYNCMISS_POS  = 9;    /** @brief SYNC missed this flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_TRIMOVF_POS   = 10;   /** @brief Trimming overflow or underflow this flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register. */
  static const int32_t CRx_ISR_FEDIR_POS     = 15;   /** @brief Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target. */
  static const int32_t CRx_ISR_FECAP_POS     = 16;   /** @brief Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to section7.3.4: frequency error evaluation and automatic trimming for more details about FECAP usage. */
  static const int32_t CRx_ICR_SYNCOKC_POS   = 0;    /** @brief SYNC event OK clear flag writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register. */
  static const int32_t CRx_ICR_SYNCWARNC_POS = 1;    /** @brief SYNC warning clear flag writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register. */
  static const int32_t CRx_ICR_ERRC_POS      = 2;    /** @brief Error clear flag writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register. */
  static const int32_t CRx_ICR_ESYNCC_POS    = 3;    /** @brief Expected SYNC clear flag writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register. */

  /**********************************************************************************************
   * @section DAC Register Information
   **********************************************************************************************/

  /**** @subsection DAC Register Pointers ****/

  static RW_ uint32_t* const DAC_CR_PTR      = (RW_ uint32_t* const)0x40007400U;   /** @brief DAC control register */
  static WO_ uint32_t* const DAC_SWTRGR_PTR  = (WO_ uint32_t* const)0x40007404U;   /** @brief DAC software trigger register */
  static RW_ uint32_t* const DAC_DHR8R2_PTR  = (RW_ uint32_t* const)0x4000741CU;   /** @brief DAC channel2 8-bit right-aligned data holding register */
  static RW_ uint32_t* const DAC_DHR12LD_PTR = (RW_ uint32_t* const)0x40007424U;   /** @brief DUAL DAC 12-bit left aligned data holding register */
  static RW_ uint32_t* const DAC_SR_PTR      = (RW_ uint32_t* const)0x40007434U;   /** @brief DAC status register */
  static RW_ uint32_t* const DAC_CCR_PTR     = (RW_ uint32_t* const)0x40007438U;   /** @brief DAC calibration control register */
  static RW_ uint32_t* const DAC_MCR_PTR     = (RW_ uint32_t* const)0x4000743CU;   /** @brief DAC mode control register */
  static RW_ uint32_t* const DAC_SHHR_PTR    = (RW_ uint32_t* const)0x40007448U;   /** @brief DAC sample and hold hold time register */
  static RW_ uint32_t* const DAC_SHRR_PTR    = (RW_ uint32_t* const)0x4000744CU;   /** @brief DAC sample and hold refresh time register */

  /**** @subsection Enumerated DAC Register Pointers ****/

  static RW_ uint32_t* const DAC_DHR12Rx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40007408U,   /** @brief DAC channel1 12-bit right-aligned data holding register */
    [2] = (RW_ uint32_t* const)0x40007414U,   /** @brief DAC channel2 12-bit right aligned data holding register */
  };

  static RW_ uint32_t* const DAC_DHR12Lx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000740CU,   /** @brief DAC channel1 12-bit left aligned data holding register */
    [2] = (RW_ uint32_t* const)0x40007418U,   /** @brief DAC channel2 12-bit left aligned data holding register */
  };

  static RW_ uint32_t* const DAC_DHRxR1_PTR[13] = {
    [8]  = (RW_ uint32_t* const)0x40007410U,   /** @brief DAC channel1 8-bit right aligned data holding register */
  };

  static RW_ uint32_t* const DAC_DHRxRD_PTR[13] = {
    [8]  = (RW_ uint32_t* const)0x40007428U,   /** @brief DUAL DAC 8-bit right aligned data holding register */
    [12] = (RW_ uint32_t* const)0x40007420U,   /** @brief Dual DAC 12-bit right-aligned data holding register */
  };

  static RO_ uint32_t* const DAC_DORx_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000742CU,   /** @brief DAC channel1 data output register */
    [2] = (RO_ uint32_t* const)0x40007430U,   /** @brief DAC channel2 data output register */
  };

  static RW_ uint32_t* const DAC_SHSRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40007440U,   /** @brief DAC sample and hold sample time register 1 */
    [2] = (RW_ uint32_t* const)0x40007444U,   /** @brief DAC sample and hold sample time register 2 */
  };

  /**** @subsection DAC Register Field Masks ****/

  static const uint32_t DAC_DHR12Rx_DACC1DHR_MSK = 0x00000FFFU;   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const uint32_t DAC_DHR12Lx_DACC1DHR_MSK = 0x0000FFF0U;   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const uint32_t DAC_DHRxR1_DACC1DHR_MSK  = 0x000000FFU;   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
  static const uint32_t DAC_DHR8R2_DACC2DHR_MSK  = 0x000000FFU;   /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
  static const uint32_t DAC_DORx_DACC1DOR_MSK    = 0x00000FFFU;   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
  static const uint32_t DAC_SHSRx_TSAMPLE1_MSK   = 0x000003FFU;   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */

  /**** @subsection Enumerated DAC Register Field Masks ****/

  static const uint32_t DAC_CR_ENx_MSK[3] = {
    [1] = 0x00000001U,   /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
    [2] = 0x00010000U,   /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
  };

  static const uint32_t DAC_CR_TENx_MSK[3] = {
    [1] = 0x00000002U,   /** @brief DAC channel1 trigger enable */
    [2] = 0x00020000U,   /** @brief DAC channel2 trigger enable */
  };

  static const uint32_t DAC_CR_TSELx_MSK[3] = {
    [1] = 0x0000001CU,   /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = 0x001C0000U,   /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
  };

  static const uint32_t DAC_CR_WAVEx_MSK[3] = {
    [1] = 0x000000C0U,   /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = 0x00C00000U,   /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
  };

  static const uint32_t DAC_CR_MAMPx_MSK[3] = {
    [1] = 0x00000F00U,   /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    [2] = 0x0F000000U,   /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
  };

  static const uint32_t DAC_CR_DMAENx_MSK[3] = {
    [1] = 0x00001000U,   /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
    [2] = 0x10000000U,   /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
  };

  static const uint32_t DAC_CR_DMAUDRIEx_MSK[3] = {
    [1] = 0x00002000U,   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
    [2] = 0x20000000U,   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
  };

  static const uint32_t DAC_CR_CENx_MSK[3] = {
    [1] = 0x00004000U,   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    [2] = 0x40000000U,   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
  };

  static const uint32_t DAC_SWTRGR_SWTRIGx_MSK[3] = {
    [1] = 0x00000001U,   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    [2] = 0x00000002U,   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
  };

  static const uint32_t DAC_DHRxRD_DACCxDHR_MSK[3] = {
    [1] = 0x00000FFFU,   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    [2] = 0x0FFF0000U,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
  };

  static const uint32_t DAC_SR_DMAUDRx_MSK[3] = {
    [1] = 0x00002000U,   /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    [2] = 0x20000000U,   /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
  };

  static const uint32_t DAC_SR_CAL_FLAGx_MSK[3] = {
    [1] = 0x00004000U,   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
    [2] = 0x40000000U,   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
  };

  static const uint32_t DAC_SR_BWSTx_MSK[3] = {
    [1] = 0x00008000U,   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    [2] = 0x80000000U,   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
  };

  static const uint32_t DAC_CCR_OTRIMx_MSK[3] = {
    [1] = 0x0000001FU,   /** @brief DAC channel 1 offset trimming value */
    [2] = 0x001F0000U,   /** @brief DAC channel 2 offset trimming value */
  };

  static const uint32_t DAC_MCR_MODEx_MSK[3] = {
    [1] = 0x00000007U,   /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
    [2] = 0x00070000U,   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
  };

  static const uint32_t DAC_SHHR_THOLDx_MSK[3] = {
    [1] = 0x000003FFU,   /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
    [2] = 0x03FF0000U,   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
  };

  static const uint32_t DAC_SHRR_TREFRESHx_MSK[3] = {
    [1] = 0x000000FFU,   /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    [2] = 0x00FF0000U,   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
  };

  /**** @subsection DAC Register Field Positions ****/

  static const int32_t DAC_DHR12Rx_DACC1DHR_POS = 0;   /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const int32_t DAC_DHR12Lx_DACC1DHR_POS = 4;   /** @brief DAC channel1 12-bit left-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
  static const int32_t DAC_DHRxR1_DACC1DHR_POS  = 0;   /** @brief DAC channel1 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel1. */
  static const int32_t DAC_DHR8R2_DACC2DHR_POS  = 0;   /** @brief DAC channel2 8-bit right-aligned data these bits are written by software which specifies 8-bit data for DAC channel2. */
  static const int32_t DAC_DORx_DACC1DOR_POS    = 0;   /** @brief DAC channel1 data output these bits are read-only, they contain data output for DAC channel1. */
  static const int32_t DAC_SHSRx_TSAMPLE1_POS   = 0;   /** @brief DAC channel 1 sample time (only valid in sample &amp; hold mode) these bits can be written when the DAC channel1 is disabled or also during normal operation. In the latter case, the write can be done only when bwstx of DAC_SR register is low, if bwstx=1, the write operation is ignored. */

  /**** @subsection Enumerated DAC Register Field Positions ****/

  static const int32_t DAC_CR_ENx_POS[3] = {
    [1] = 0,    /** @brief DAC channel1 enable this bit is set and cleared by software to enable/disable DAC channel1. */
    [2] = 16,   /** @brief DAC channel2 enable this bit is set and cleared by software to enable/disable DAC channel2. */
  };

  static const int32_t DAC_CR_TENx_POS[3] = {
    [1] = 1,    /** @brief DAC channel1 trigger enable */
    [2] = 17,   /** @brief DAC channel2 trigger enable */
  };

  static const int32_t DAC_CR_TSELx_POS[3] = {
    [1] = 2,    /** @brief DAC channel1 trigger selection these bits select the external event used to trigger DAC channel1. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = 18,   /** @brief DAC channel2 trigger selection these bits select the external event used to trigger DAC channel2 note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled). */
  };

  static const int32_t DAC_CR_WAVEx_POS[3] = {
    [1] = 6,    /** @brief DAC channel1 noise/triangle wave generation enable these bits are set and cleared by software. Note: only used if bit TEN1 = 1 (DAC channel1 trigger enabled). */
    [2] = 22,   /** @brief DAC channel2 noise/triangle wave generation enable these bits are set/reset by software. 1x: triangle wave generation enabled note: only used if bit TEN2 = 1 (DAC channel2 trigger enabled) */
  };

  static const int32_t DAC_CR_MAMPx_POS[3] = {
    [1] = 8,    /** @brief DAC channel1 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
    [2] = 24,   /** @brief DAC channel2 mask/amplitude selector these bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095 */
  };

  static const int32_t DAC_CR_DMAENx_POS[3] = {
    [1] = 12,   /** @brief DAC channel1 DMA enable this bit is set and cleared by software. */
    [2] = 28,   /** @brief DAC channel2 DMA enable this bit is set and cleared by software. */
  };

  static const int32_t DAC_CR_DMAUDRIEx_POS[3] = {
    [1] = 13,   /** @brief DAC channel1 DMA underrun interrupt enable this bit is set and cleared by software. */
    [2] = 29,   /** @brief DAC channel2 DMA underrun interrupt enable this bit is set and cleared by software. */
  };

  static const int32_t DAC_CR_CENx_POS[3] = {
    [1] = 14,   /** @brief DAC channel 1 calibration enable this bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
    [2] = 30,   /** @brief DAC channel 2 calibration enable this bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) otherwise, the write operation is ignored. */
  };

  static const int32_t DAC_SWTRGR_SWTRIGx_POS[3] = {
    [1] = 0,   /** @brief DAC channel1 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register. */
    [2] = 1,   /** @brief DAC channel2 software trigger this bit is set by software to trigger the DAC in software trigger mode. Note: this bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register. */
  };

  static const int32_t DAC_DHRxRD_DACCxDHR_POS[3] = {
    [1] = 0,    /** @brief DAC channel1 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel1. */
    [2] = 16,   /** @brief DAC channel2 12-bit right-aligned data these bits are written by software which specifies 12-bit data for DAC channel2. */
  };

  static const int32_t DAC_SR_DMAUDRx_POS[3] = {
    [1] = 13,   /** @brief DAC channel1 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
    [2] = 29,   /** @brief DAC channel2 DMA underrun flag this bit is set by hardware and cleared by software (by writing it to 1). */
  };

  static const int32_t DAC_SR_CAL_FLAGx_POS[3] = {
    [1] = 14,   /** @brief DAC channel 1 calibration offset status this bit is set and cleared by hardware */
    [2] = 30,   /** @brief DAC channel 2 calibration offset status this bit is set and cleared by hardware */
  };

  static const int32_t DAC_SR_BWSTx_POS[3] = {
    [1] = 15,   /** @brief DAC channel 1 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR1, it is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization). */
    [2] = 31,   /** @brief DAC channel 2 busy writing sample time flag this bit is systematically set just after sample & hold mode enable and is set each time the software writes the register DAC_SHSR2, it is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization). */
  };

  static const int32_t DAC_CCR_OTRIMx_POS[3] = {
    [1] = 0,    /** @brief DAC channel 1 offset trimming value */
    [2] = 16,   /** @brief DAC channel 2 offset trimming value */
  };

  static const int32_t DAC_MCR_MODEx_POS[3] = {
    [1] = 0,    /** @brief DAC channel 1 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 1 mode: DAC channel 1 in normal mode DAC channel 1 in sample &amp; hold mode */
    [2] = 16,   /** @brief DAC channel 2 mode these bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC channel 2 mode: DAC channel 2 in normal mode DAC channel 2 in sample &amp; hold mode */
  };

  static const int32_t DAC_SHHR_THOLDx_POS[3] = {
    [1] = 0,    /** @brief DAC channel 1 hold time (only valid in sample &amp; hold mode) hold time= (THOLD[9:0]) x T LSI */
    [2] = 16,   /** @brief DAC channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI */
  };

  static const int32_t DAC_SHRR_TREFRESHx_POS[3] = {
    [1] = 0,    /** @brief DAC channel 1 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
    [2] = 16,   /** @brief DAC channel 2 refresh time (only valid in sample &amp; hold mode) refresh time= (TREFRESH[7:0]) x T LSI */
  };

  /**********************************************************************************************
   * @section xDMA Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated xDMA Register Pointers ****/

  static RO_ uint32_t* const xDMA_ISR_PTR[13] = {
    [1]  = (RO_ uint32_t* const)0x58025400U,   /** @brief DMA interrupt status register */
    [12] = (RO_ uint32_t* const)0x52000000U,   /** @brief MDMA global interrupt/status register */
  };

  static WO_ uint32_t* const xDMA_IFCR_PTR[13] = {
    [1]  = (WO_ uint32_t* const)0x58025404U,   /** @brief DMA interrupt flag clear register */
  };

  /**** @subsection xDMA Register Field Masks ****/

  static const uint32_t xDMA_CCRx_EN_MSK      = 0x00000001U;   /** @brief Channel enable this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_TCIE_MSK    = 0x00000002U;   /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_HTIE_MSK    = 0x00000004U;   /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_TEIE_MSK    = 0x00000008U;   /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_DIR_MSK     = 0x00000010U;   /** @brief Data transfer direction this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_CIRC_MSK    = 0x00000020U;   /** @brief Circular mode this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_PINC_MSK    = 0x00000040U;   /** @brief Peripheral increment mode this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_MINC_MSK    = 0x00000080U;   /** @brief Memory increment mode this bit is set and cleared by software. */
  static const uint32_t xDMA_CCRx_PSIZE_MSK   = 0x00000300U;   /** @brief Peripheral size these bits are set and cleared by software. */
  static const uint32_t xDMA_CCRx_MSIZE_MSK   = 0x00000C00U;   /** @brief Memory size these bits are set and cleared by software. */
  static const uint32_t xDMA_CCRx_PL_MSK      = 0x00003000U;   /** @brief Channel priority level these bits are set and cleared by software. */
  static const uint32_t xDMA_CCRx_MEM2MEM_MSK = 0x00004000U;   /** @brief Memory to memory mode this bit is set and cleared by software. */
  static const uint32_t xDMA_CNDTRx_NDT_MSK   = 0x0000FFFFU;   /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

  /**** @subsection Enumerated xDMA Register Field Masks ****/

  static const uint32_t xDMA_ISR_GIFx_MSK[9] = {
    [1] = 0x00000001U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 0x00000010U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 0x00000100U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 0x00001000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 0x00010000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 0x00100000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 0x01000000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 0x10000000U,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const uint32_t xDMA_ISR_TCIFx_MSK[9] = {
    [1] = 0x00000002U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 0x00000020U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 0x00000200U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 0x00002000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 0x00020000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 0x00200000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 0x02000000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 0x20000000U,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const uint32_t xDMA_ISR_HTIFx_MSK[9] = {
    [1] = 0x00000004U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 0x00000040U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 0x00000400U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 0x00004000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 0x00040000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 0x00400000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 0x04000000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 0x40000000U,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const uint32_t xDMA_ISR_TEIFx_MSK[9] = {
    [1] = 0x00000008U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 0x00000080U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 0x00000800U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 0x00008000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 0x00080000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 0x00800000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 0x08000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 0x80000000U,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const uint32_t xDMA_IFCR_CGIFx_MSK[9] = {
    [1] = 0x00000001U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [2] = 0x00000010U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [3] = 0x00000100U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [4] = 0x00001000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [5] = 0x00010000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [6] = 0x00100000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [7] = 0x01000000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [8] = 0x10000000U,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
  };

  static const uint32_t xDMA_IFCR_CTCIFx_MSK[9] = {
    [1] = 0x00000002U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [2] = 0x00000020U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [3] = 0x00000200U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [4] = 0x00002000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [5] = 0x00020000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [6] = 0x00200000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [7] = 0x02000000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [8] = 0x20000000U,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
  };

  static const uint32_t xDMA_IFCR_CHTIFx_MSK[9] = {
    [1] = 0x00000004U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [2] = 0x00000040U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [3] = 0x00000400U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [4] = 0x00004000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [5] = 0x00040000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [6] = 0x00400000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [7] = 0x04000000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [8] = 0x40000000U,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
  };

  static const uint32_t xDMA_IFCR_CTEIFx_MSK[9] = {
    [1] = 0x00000008U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [2] = 0x00000080U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [3] = 0x00000800U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [4] = 0x00008000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [5] = 0x00080000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [6] = 0x00800000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [7] = 0x08000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [8] = 0x80000000U,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
  };

  /**** @subsection xDMA Register Field Positions ****/

  static const int32_t xDMA_CCRx_EN_POS      = 0;    /** @brief Channel enable this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_TCIE_POS    = 1;    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_HTIE_POS    = 2;    /** @brief Half transfer interrupt enable this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_TEIE_POS    = 3;    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_DIR_POS     = 4;    /** @brief Data transfer direction this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_CIRC_POS    = 5;    /** @brief Circular mode this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_PINC_POS    = 6;    /** @brief Peripheral increment mode this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_MINC_POS    = 7;    /** @brief Memory increment mode this bit is set and cleared by software. */
  static const int32_t xDMA_CCRx_PSIZE_POS   = 8;    /** @brief Peripheral size these bits are set and cleared by software. */
  static const int32_t xDMA_CCRx_MSIZE_POS   = 10;   /** @brief Memory size these bits are set and cleared by software. */
  static const int32_t xDMA_CCRx_PL_POS      = 12;   /** @brief Channel priority level these bits are set and cleared by software. */
  static const int32_t xDMA_CCRx_MEM2MEM_POS = 14;   /** @brief Memory to memory mode this bit is set and cleared by software. */
  static const int32_t xDMA_CNDTRx_NDT_POS   = 0;    /** @brief Number of data to transfer number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not. */

  /**** @subsection Enumerated xDMA Register Field Positions ****/

  static const int32_t xDMA_ISR_GIFx_POS[9] = {
    [1] = 0,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 4,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 8,    /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 12,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 16,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 20,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 24,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 28,   /** @brief Channel x global interrupt flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const int32_t xDMA_ISR_TCIFx_POS[9] = {
    [1] = 1,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 5,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 9,    /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 13,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 17,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 21,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 25,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 29,   /** @brief Channel x transfer complete flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const int32_t xDMA_ISR_HTIFx_POS[9] = {
    [1] = 2,    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 6,    /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 10,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 14,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 18,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 22,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 26,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 30,   /** @brief Channel x half transfer flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const int32_t xDMA_ISR_TEIFx_POS[9] = {
    [1] = 3,    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [2] = 7,    /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [3] = 11,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [4] = 15,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [5] = 19,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [6] = 23,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [7] = 27,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
    [8] = 31,   /** @brief Channel x transfer error flag (x = 1..8) this bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register. */
  };

  static const int32_t xDMA_IFCR_CGIFx_POS[9] = {
    [1] = 0,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [2] = 4,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [3] = 8,    /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [4] = 12,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [5] = 16,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [6] = 20,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [7] = 24,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
    [8] = 28,   /** @brief Channel x global interrupt clear this bit is set and cleared by software. */
  };

  static const int32_t xDMA_IFCR_CTCIFx_POS[9] = {
    [1] = 1,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [2] = 5,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [3] = 9,    /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [4] = 13,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [5] = 17,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [6] = 21,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [7] = 25,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
    [8] = 29,   /** @brief Channel x transfer complete clear this bit is set and cleared by software. */
  };

  static const int32_t xDMA_IFCR_CHTIFx_POS[9] = {
    [1] = 2,    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [2] = 6,    /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [3] = 10,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [4] = 14,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [5] = 18,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [6] = 22,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [7] = 26,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
    [8] = 30,   /** @brief Channel x half transfer clear this bit is set and cleared by software. */
  };

  static const int32_t xDMA_IFCR_CTEIFx_POS[9] = {
    [1] = 3,    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [2] = 7,    /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [3] = 11,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [4] = 15,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [5] = 19,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [6] = 23,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [7] = 27,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
    [8] = 31,   /** @brief Channel x transfer error clear this bit is set and cleared by software. */
  };

  /**********************************************************************************************
   * @section DMA2D Register Information
   **********************************************************************************************/

  /**** @subsection DMA2D Register Pointers ****/

  static RW_ uint32_t* const DMA2D_CR_PTR      = (RW_ uint32_t* const)0x52001000U;   /** @brief DMA2D control register */
  static RO_ uint32_t* const DMA2D_ISR_PTR     = (RO_ uint32_t* const)0x52001004U;   /** @brief DMA2D interrupt status register */
  static RW_ uint32_t* const DMA2D_IFCR_PTR    = (RW_ uint32_t* const)0x52001008U;   /** @brief DMA2D interrupt flag clear register */
  static RW_ uint32_t* const DMA2D_FGMAR_PTR   = (RW_ uint32_t* const)0x5200100CU;   /** @brief DMA2D foreground memory address register */
  static RW_ uint32_t* const DMA2D_FGOR_PTR    = (RW_ uint32_t* const)0x52001010U;   /** @brief DMA2D foreground offset register */
  static RW_ uint32_t* const DMA2D_BGMAR_PTR   = (RW_ uint32_t* const)0x52001014U;   /** @brief DMA2D background memory address register */
  static RW_ uint32_t* const DMA2D_BGOR_PTR    = (RW_ uint32_t* const)0x52001018U;   /** @brief DMA2D background offset register */
  static RW_ uint32_t* const DMA2D_FGPFCCR_PTR = (RW_ uint32_t* const)0x5200101CU;   /** @brief DMA2D foreground PFC control register */
  static RW_ uint32_t* const DMA2D_FGCOLR_PTR  = (RW_ uint32_t* const)0x52001020U;   /** @brief DMA2D foreground color register */
  static RW_ uint32_t* const DMA2D_BGPFCCR_PTR = (RW_ uint32_t* const)0x52001024U;   /** @brief DMA2D background PFC control register */
  static RW_ uint32_t* const DMA2D_BGCOLR_PTR  = (RW_ uint32_t* const)0x52001028U;   /** @brief DMA2D background color register */
  static RW_ uint32_t* const DMA2D_FGCMAR_PTR  = (RW_ uint32_t* const)0x5200102CU;   /** @brief DMA2D foreground CLUT memory address register */
  static RW_ uint32_t* const DMA2D_BGCMAR_PTR  = (RW_ uint32_t* const)0x52001030U;   /** @brief DMA2D background CLUT memory address register */
  static RW_ uint32_t* const DMA2D_OPFCCR_PTR  = (RW_ uint32_t* const)0x52001034U;   /** @brief DMA2D output PFC control register */
  static RW_ uint32_t* const DMA2D_OCOLR_PTR   = (RW_ uint32_t* const)0x52001038U;   /** @brief DMA2D output color register */
  static RW_ uint32_t* const DMA2D_OMAR_PTR    = (RW_ uint32_t* const)0x5200103CU;   /** @brief DMA2D output memory address register */
  static RW_ uint32_t* const DMA2D_OOR_PTR     = (RW_ uint32_t* const)0x52001040U;   /** @brief DMA2D output offset register */
  static RW_ uint32_t* const DMA2D_NLR_PTR     = (RW_ uint32_t* const)0x52001044U;   /** @brief DMA2D number of line register */
  static RW_ uint32_t* const DMA2D_LWR_PTR     = (RW_ uint32_t* const)0x52001048U;   /** @brief DMA2D line watermark register */
  static RW_ uint32_t* const DMA2D_AMTCR_PTR   = (RW_ uint32_t* const)0x5200104CU;   /** @brief DMA2D AXI master timer configuration register */

  /**** @subsection DMA2D Register Field Masks ****/

  static const uint32_t DMA2D_CR_START_MSK      = 0x00000001U;   /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
  static const uint32_t DMA2D_CR_SUSP_MSK       = 0x00000002U;   /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
  static const uint32_t DMA2D_CR_ABORT_MSK      = 0x00000004U;   /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
  static const uint32_t DMA2D_CR_TEIE_MSK       = 0x00000100U;   /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_TCIE_MSK       = 0x00000200U;   /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_TWIE_MSK       = 0x00000400U;   /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_CAEIE_MSK      = 0x00000800U;   /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_CTCIE_MSK      = 0x00001000U;   /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_CEIE_MSK       = 0x00002000U;   /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
  static const uint32_t DMA2D_CR_MODE_MSK       = 0x00030000U;   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
  static const uint32_t DMA2D_ISR_TEIF_MSK      = 0x00000001U;   /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
  static const uint32_t DMA2D_ISR_TCIF_MSK      = 0x00000002U;   /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
  static const uint32_t DMA2D_ISR_TWIF_MSK      = 0x00000004U;   /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
  static const uint32_t DMA2D_ISR_CAEIF_MSK     = 0x00000008U;   /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
  static const uint32_t DMA2D_ISR_CTCIF_MSK     = 0x00000010U;   /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
  static const uint32_t DMA2D_ISR_CEIF_MSK      = 0x00000020U;   /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
  static const uint32_t DMA2D_IFCR_CTEIF_MSK    = 0x00000001U;   /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_IFCR_CTCIF_MSK    = 0x00000002U;   /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_IFCR_CTWIF_MSK    = 0x00000004U;   /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_IFCR_CAECIF_MSK   = 0x00000008U;   /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_IFCR_CCTCIF_MSK   = 0x00000010U;   /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_IFCR_CCEIF_MSK    = 0x00000020U;   /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
  static const uint32_t DMA2D_FGOR_LO_MSK       = 0x00003FFFU;   /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const uint32_t DMA2D_BGOR_LO_MSK       = 0x00003FFFU;   /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const uint32_t DMA2D_FGPFCCR_CM_MSK    = 0x0000000FU;   /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const uint32_t DMA2D_FGPFCCR_CCM_MSK   = 0x00000010U;   /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_FGPFCCR_START_MSK = 0x00000020U;   /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
  static const uint32_t DMA2D_FGPFCCR_CS_MSK    = 0x0000FF00U;   /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const uint32_t DMA2D_FGPFCCR_AM_MSK    = 0x00030000U;   /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
  static const uint32_t DMA2D_FGPFCCR_CSS_MSK   = 0x000C0000U;   /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
  static const uint32_t DMA2D_FGPFCCR_AI_MSK    = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_FGPFCCR_RBS_MSK   = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_FGPFCCR_ALPHA_MSK = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
  static const uint32_t DMA2D_FGCOLR_BLUE_MSK   = 0x000000FFU;   /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_FGCOLR_GREEN_MSK  = 0x0000FF00U;   /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_FGCOLR_RED_MSK    = 0x00FF0000U;   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_BGPFCCR_CM_MSK    = 0x0000000FU;   /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const uint32_t DMA2D_BGPFCCR_CCM_MSK   = 0x00000010U;   /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_BGPFCCR_START_MSK = 0x00000020U;   /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
  static const uint32_t DMA2D_BGPFCCR_CS_MSK    = 0x0000FF00U;   /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const uint32_t DMA2D_BGPFCCR_AM_MSK    = 0x00030000U;   /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const uint32_t DMA2D_BGPFCCR_AI_MSK    = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_BGPFCCR_RBS_MSK   = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_BGPFCCR_ALPHA_MSK = 0xFF000000U;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_BGCOLR_BLUE_MSK   = 0x000000FFU;   /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_BGCOLR_GREEN_MSK  = 0x0000FF00U;   /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_BGCOLR_RED_MSK    = 0x00FF0000U;   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_OPFCCR_CM_MSK     = 0x00000007U;   /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const uint32_t DMA2D_OPFCCR_AI_MSK     = 0x00100000U;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_OPFCCR_RBS_MSK    = 0x00200000U;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const uint32_t DMA2D_OCOLR_BLUE_MSK    = 0x000000FFU;   /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_OCOLR_GREEN_MSK   = 0x0000FF00U;   /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_OCOLR_RED_MSK     = 0x00FF0000U;   /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_OCOLR_ALPHA_MSK   = 0xFF000000U;   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_OOR_LO_MSK        = 0x00003FFFU;   /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_NLR_NL_MSK        = 0x0000FFFFU;   /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_NLR_PL_MSK        = 0x3FFF0000U;   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
  static const uint32_t DMA2D_LWR_LW_MSK        = 0x0000FFFFU;   /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const uint32_t DMA2D_AMTCR_EN_MSK      = 0x00000001U;   /** @brief Enable enables the dead time functionality. */
  static const uint32_t DMA2D_AMTCR_DT_MSK      = 0x0000FF00U;   /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

  /**** @subsection DMA2D Register Field Positions ****/

  static const int32_t DMA2D_CR_START_POS      = 0;    /** @brief Start this bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers */
  static const int32_t DMA2D_CR_SUSP_POS       = 1;    /** @brief Suspend this bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset. */
  static const int32_t DMA2D_CR_ABORT_POS      = 2;    /** @brief Abort this bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset. */
  static const int32_t DMA2D_CR_TEIE_POS       = 8;    /** @brief Transfer error interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_TCIE_POS       = 9;    /** @brief Transfer complete interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_TWIE_POS       = 10;   /** @brief Transfer watermark interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_CAEIE_POS      = 11;   /** @brief CLUT access error interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_CTCIE_POS      = 12;   /** @brief CLUT transfer complete interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_CEIE_POS       = 13;   /** @brief Configuration error interrupt enable this bit is set and cleared by software. */
  static const int32_t DMA2D_CR_MODE_POS       = 16;   /** @brief DMA2D mode this bit is set and cleared by software. It cannot be modified while a transfer is ongoing. */
  static const int32_t DMA2D_ISR_TEIF_POS      = 0;    /** @brief Transfer error interrupt flag this bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading). */
  static const int32_t DMA2D_ISR_TCIF_POS      = 1;    /** @brief Transfer complete interrupt flag this bit is set when a DMA2D transfer operation is complete (data transfer only). */
  static const int32_t DMA2D_ISR_TWIF_POS      = 2;    /** @brief Transfer watermark interrupt flag this bit is set when the last pixel of the watermarked line has been transferred. */
  static const int32_t DMA2D_ISR_CAEIF_POS     = 3;    /** @brief CLUT access error interrupt flag this bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D. */
  static const int32_t DMA2D_ISR_CTCIF_POS     = 4;    /** @brief CLUT transfer complete interrupt flag this bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete. */
  static const int32_t DMA2D_ISR_CEIF_POS      = 5;    /** @brief Configuration error interrupt flag this bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed. */
  static const int32_t DMA2D_IFCR_CTEIF_POS    = 0;    /** @brief Clear transfer error interrupt flag programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_IFCR_CTCIF_POS    = 1;    /** @brief Clear transfer complete interrupt flag programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_IFCR_CTWIF_POS    = 2;    /** @brief Clear transfer watermark interrupt flag programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_IFCR_CAECIF_POS   = 3;    /** @brief Clear CLUT access error interrupt flag programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_IFCR_CCTCIF_POS   = 4;    /** @brief Clear CLUT transfer complete interrupt flag programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_IFCR_CCEIF_POS    = 5;    /** @brief Clear configuration error interrupt flag programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register */
  static const int32_t DMA2D_FGOR_LO_POS       = 0;    /** @brief Line offset line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const int32_t DMA2D_BGOR_LO_POS       = 0;    /** @brief Line offset line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even. */
  static const int32_t DMA2D_FGPFCCR_CM_POS    = 0;    /** @brief Color mode these bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const int32_t DMA2D_FGPFCCR_CCM_POS   = 4;    /** @brief CLUT color mode this bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const int32_t DMA2D_FGPFCCR_START_POS = 5;    /** @brief Start this bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer). */
  static const int32_t DMA2D_FGPFCCR_CS_POS    = 8;    /** @brief CLUT size these bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const int32_t DMA2D_FGPFCCR_AM_POS    = 16;   /** @brief Alpha mode these bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. Other configurations are meaningless */
  static const int32_t DMA2D_FGPFCCR_CSS_POS   = 18;   /** @brief Chroma sub-sampling these bits define the chroma sub-sampling mode for ycbcr color mode. Once the transfer has started, these bits are read-only. Others: meaningless */
  static const int32_t DMA2D_FGPFCCR_AI_POS    = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_FGPFCCR_RBS_POS   = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_FGPFCCR_ALPHA_POS = 24;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only. */
  static const int32_t DMA2D_FGCOLR_BLUE_POS   = 0;    /** @brief Blue value these bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_FGCOLR_GREEN_POS  = 8;    /** @brief Green value these bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_FGCOLR_RED_POS    = 16;   /** @brief Red value these bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_BGPFCCR_CM_POS    = 0;    /** @brief Color mode these bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const int32_t DMA2D_BGPFCCR_CCM_POS   = 4;    /** @brief CLUT color mode these bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only. */
  static const int32_t DMA2D_BGPFCCR_START_POS = 5;    /** @brief Start this bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic background CLUT transfer). */
  static const int32_t DMA2D_BGPFCCR_CS_POS    = 8;    /** @brief CLUT size these bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1. */
  static const int32_t DMA2D_BGPFCCR_AM_POS    = 16;   /** @brief Alpha mode these bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const int32_t DMA2D_BGPFCCR_AI_POS    = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_BGPFCCR_RBS_POS   = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_BGPFCCR_ALPHA_POS = 24;   /** @brief Alpha value these bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_BGCOLR_BLUE_POS   = 0;    /** @brief Blue value these bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_BGCOLR_GREEN_POS  = 8;    /** @brief Green value these bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_BGCOLR_RED_POS    = 16;   /** @brief Red value these bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_OPFCCR_CM_POS     = 0;    /** @brief Color mode these bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. Others: meaningless */
  static const int32_t DMA2D_OPFCCR_AI_POS     = 20;   /** @brief Alpha inverted this bit inverts the alpha value. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_OPFCCR_RBS_POS    = 21;   /** @brief Red blue swap this bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only. */
  static const int32_t DMA2D_OCOLR_BLUE_POS    = 0;    /** @brief Blue value these bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_OCOLR_GREEN_POS   = 8;    /** @brief Green value these bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_OCOLR_RED_POS     = 16;   /** @brief Red value these bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_OCOLR_ALPHA_POS   = 24;   /** @brief Alpha channel value these bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_OOR_LO_POS        = 0;    /** @brief Line offset line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_NLR_NL_POS        = 0;    /** @brief Number of lines number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_NLR_PL_POS        = 16;   /** @brief Pixel per lines number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even. */
  static const int32_t DMA2D_LWR_LW_POS        = 0;    /** @brief Line watermark these bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. */
  static const int32_t DMA2D_AMTCR_EN_POS      = 0;    /** @brief Enable enables the dead time functionality. */
  static const int32_t DMA2D_AMTCR_DT_POS      = 8;    /** @brief Dead time dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses. */

  /**********************************************************************************************
   * @section DMAMUXx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated DMAMUXx Register Pointers ****/

  static RW_ uint32_t* const DMAMUXx_CxCR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [1] = (RW_ uint32_t* const)0x40020804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [2] = (RW_ uint32_t* const)0x40020808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [3] = (RW_ uint32_t* const)0x4002080CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [4] = (RW_ uint32_t* const)0x40020810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [5] = (RW_ uint32_t* const)0x40020814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [6] = (RW_ uint32_t* const)0x40020818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [7] = (RW_ uint32_t* const)0x4002081CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x58025800U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [1] = (RW_ uint32_t* const)0x58025804U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [2] = (RW_ uint32_t* const)0x58025808U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [3] = (RW_ uint32_t* const)0x5802580CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [4] = (RW_ uint32_t* const)0x58025810U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [5] = (RW_ uint32_t* const)0x58025814U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [6] = (RW_ uint32_t* const)0x58025818U,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
      [7] = (RW_ uint32_t* const)0x5802581CU,   /** @brief DMAMux - DMA request line multiplexer channel x control register */
    },
  };

  static RW_ uint32_t* const DMAMUXx_RGxCR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020900U,   /** @brief DMAMux - DMA request generator channel x control register */
      [1] = (RW_ uint32_t* const)0x40020904U,   /** @brief DMAMux - DMA request generator channel x control register */
      [2] = (RW_ uint32_t* const)0x40020908U,   /** @brief DMAMux - DMA request generator channel x control register */
      [3] = (RW_ uint32_t* const)0x4002090CU,   /** @brief DMAMux - DMA request generator channel x control register */
      [4] = (RW_ uint32_t* const)0x40020910U,   /** @brief DMAMux - DMA request generator channel x control register */
      [5] = (RW_ uint32_t* const)0x40020914U,   /** @brief DMAMux - DMA request generator channel x control register */
      [6] = (RW_ uint32_t* const)0x40020918U,   /** @brief DMAMux - DMA request generator channel x control register */
      [7] = (RW_ uint32_t* const)0x4002091CU,   /** @brief DMAMux - DMA request generator channel x control register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x58025900U,   /** @brief DMAMux - DMA request generator channel x control register */
      [1] = (RW_ uint32_t* const)0x58025904U,   /** @brief DMAMux - DMA request generator channel x control register */
      [2] = (RW_ uint32_t* const)0x58025908U,   /** @brief DMAMux - DMA request generator channel x control register */
      [3] = (RW_ uint32_t* const)0x5802590CU,   /** @brief DMAMux - DMA request generator channel x control register */
      [4] = (RW_ uint32_t* const)0x58025910U,   /** @brief DMAMux - DMA request generator channel x control register */
      [5] = (RW_ uint32_t* const)0x58025914U,   /** @brief DMAMux - DMA request generator channel x control register */
      [6] = (RW_ uint32_t* const)0x58025918U,   /** @brief DMAMux - DMA request generator channel x control register */
      [7] = (RW_ uint32_t* const)0x5802591CU,   /** @brief DMAMux - DMA request generator channel x control register */
    },
  };

  static RO_ uint32_t* const DMAMUXx_RGSR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40020940U,   /** @brief DMAMux - DMA request generator status register */
    [2] = (RO_ uint32_t* const)0x58025940U,   /** @brief DMAMux - DMA request generator status register */
  };

  static WO_ uint32_t* const DMAMUXx_RGCFR_PTR[3] = {
    [1] = (WO_ uint32_t* const)0x40020944U,   /** @brief DMAMux - DMA request generator clear flag register */
    [2] = (WO_ uint32_t* const)0x58025944U,   /** @brief DMAMux - DMA request generator clear flag register */
  };

  static RO_ uint32_t* const DMAMUXx_CSR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40020880U,   /** @brief DMAMUX request line multiplexer interrupt channel status register */
    [2] = (RO_ uint32_t* const)0x58025880U,   /** @brief DMAMUX request line multiplexer interrupt channel status register */
  };

  static WO_ uint32_t* const DMAMUXx_CFR_PTR[3] = {
    [1] = (WO_ uint32_t* const)0x40020884U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
    [2] = (WO_ uint32_t* const)0x58025884U,   /** @brief DMAMUX request line multiplexer interrupt clear flag register */
  };

  /**** @subsection DMAMUXx Register Field Masks ****/

  static const uint32_t DMAMUXx_CxCR_DMAREQ_ID_MSK = 0x000000FFU;   /** @brief Input DMA request line selected */
  static const uint32_t DMAMUXx_CxCR_SOIE_MSK      = 0x00000100U;   /** @brief Interrupt enable at synchronization event overrun */
  static const uint32_t DMAMUXx_CxCR_EGE_MSK       = 0x00000200U;   /** @brief Event generation enable/disable */
  static const uint32_t DMAMUXx_CxCR_SE_MSK        = 0x00010000U;   /** @brief Synchronous operating mode enable/disable */
  static const uint32_t DMAMUXx_CxCR_SPOL_MSK      = 0x00060000U;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
  static const uint32_t DMAMUXx_CxCR_NBREQ_MSK     = 0x00F80000U;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
  static const uint32_t DMAMUXx_CxCR_SYNC_ID_MSK   = 0x1F000000U;   /** @brief Synchronization input selected */
  static const uint32_t DMAMUXx_RGxCR_SIG_ID_MSK   = 0x0000001FU;   /** @brief DMA request trigger input selected */
  static const uint32_t DMAMUXx_RGxCR_OIE_MSK      = 0x00000100U;   /** @brief Interrupt enable at trigger event overrun */
  static const uint32_t DMAMUXx_RGxCR_GE_MSK       = 0x00010000U;   /** @brief DMA request generator channel enable/disable */
  static const uint32_t DMAMUXx_RGxCR_GPOL_MSK     = 0x00060000U;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
  static const uint32_t DMAMUXx_RGxCR_GNBREQ_MSK   = 0x00F80000U;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
  static const uint32_t DMAMUXx_RGSR_OF_MSK        = 0x000000FFU;   /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
  static const uint32_t DMAMUXx_RGCFR_COF_MSK      = 0x000000FFU;   /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
  static const uint32_t DMAMUXx_CSR_SOF_MSK        = 0x0000FFFFU;   /** @brief Synchronization overrun event flag */
  static const uint32_t DMAMUXx_CFR_CSOF_MSK       = 0x0000FFFFU;   /** @brief Clear synchronization overrun event flag */

  /**** @subsection DMAMUXx Register Field Positions ****/

  static const int32_t DMAMUXx_CxCR_DMAREQ_ID_POS = 0;    /** @brief Input DMA request line selected */
  static const int32_t DMAMUXx_CxCR_SOIE_POS      = 8;    /** @brief Interrupt enable at synchronization event overrun */
  static const int32_t DMAMUXx_CxCR_EGE_POS       = 9;    /** @brief Event generation enable/disable */
  static const int32_t DMAMUXx_CxCR_SE_POS        = 16;   /** @brief Synchronous operating mode enable/disable */
  static const int32_t DMAMUXx_CxCR_SPOL_POS      = 17;   /** @brief Synchronization event type selector defines the synchronization event on the selected synchronization input: */
  static const int32_t DMAMUXx_CxCR_NBREQ_POS     = 19;   /** @brief Number of DMA requests to forward defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: this field can only be written when both SE and EGE bits are reset. */
  static const int32_t DMAMUXx_CxCR_SYNC_ID_POS   = 24;   /** @brief Synchronization input selected */
  static const int32_t DMAMUXx_RGxCR_SIG_ID_POS   = 0;    /** @brief DMA request trigger input selected */
  static const int32_t DMAMUXx_RGxCR_OIE_POS      = 8;    /** @brief Interrupt enable at trigger event overrun */
  static const int32_t DMAMUXx_RGxCR_GE_POS       = 16;   /** @brief DMA request generator channel enable/disable */
  static const int32_t DMAMUXx_RGxCR_GPOL_POS     = 17;   /** @brief DMA request generator trigger event type selection defines the trigger event on the selected DMA request trigger input */
  static const int32_t DMAMUXx_RGxCR_GNBREQ_POS   = 19;   /** @brief Number of DMA requests to generate defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: this field can only be written when GE bit is reset. */
  static const int32_t DMAMUXx_RGSR_OF_POS        = 0;    /** @brief Trigger event overrun flag the flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding cofx bit in DMAMUX_RGCFR register. */
  static const int32_t DMAMUXx_RGCFR_COF_POS      = 0;    /** @brief Clear trigger event overrun flag upon setting, this bit clears the corresponding overrun flag ofx in the DMAMUX_RGCSR register. */
  static const int32_t DMAMUXx_CSR_SOF_POS        = 0;    /** @brief Synchronization overrun event flag */
  static const int32_t DMAMUXx_CFR_CSOF_POS       = 0;    /** @brief Clear synchronization overrun event flag */

  /**********************************************************************************************
   * @section FMC Register Information
   **********************************************************************************************/

  /**** @subsection FMC Register Pointers ****/

  static RW_ uint32_t* const FMC_PCR_PTR   = (RW_ uint32_t* const)0x52004080U;   /** @brief NAND flash control registers */
  static RW_ uint32_t* const FMC_SR_PTR    = (RW_ uint32_t* const)0x52004084U;   /** @brief This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.this is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.the ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty. */
  static RW_ uint32_t* const FMC_PMEM_PTR  = (RW_ uint32_t* const)0x52004088U;   /** @brief The FMC_PMEM read/write register contains the timing information for NAND flash memory bank. This information is used to access either the common memory space of the NAND flash for command, address write access and data read/write access. */
  static RW_ uint32_t* const FMC_PATT_PTR  = (RW_ uint32_t* const)0x5200408CU;   /** @brief The FMC_PATT read/write register contains the timing information for NAND flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND flash for the last address write access if the timing must differ from that of previous accesses (for ready/busy management, refer to section20.8.5: NAND flash prewait feature). */
  static RO_ uint32_t* const FMC_ECCR_PTR  = (RO_ uint32_t* const)0x52004094U;   /** @brief This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND flash memory page at the correct address (refer to section20.8.6: computation of the error correction code (ECC) in NAND flash memory), the data read/written from/to the NAND flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1. */
  static RW_ uint32_t* const FMC_SDCMR_PTR = (RW_ uint32_t* const)0x52004150U;   /** @brief This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the self-refresh and the power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks. */
  static RW_ uint32_t* const FMC_SDRTR_PTR = (RW_ uint32_t* const)0x52004154U;   /** @brief This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the refresh timer count value.examplewhere 64 ms is the SDRAM refresh period.the refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.as soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.if a memory access is in progress, the auto-refresh request is delayed. However, if the memory access and auto-refresh requests are generated simultaneously, the auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.this register is common to SDRAM bank 1 and bank 2. */
  static RO_ uint32_t* const FMC_SDSR_PTR  = (RO_ uint32_t* const)0x52004158U;   /** @brief SDRAM status register */

  /**** @subsection Enumerated FMC Register Pointers ****/

  static RW_ uint32_t* const FMC_BCRx_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x52004000U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [2] = (RW_ uint32_t* const)0x52004008U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [3] = (RW_ uint32_t* const)0x52004010U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
    [4] = (RW_ uint32_t* const)0x52004018U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories. */
  };

  static RW_ uint32_t* const FMC_BTRx_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x52004004U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [2] = (RW_ uint32_t* const)0x5200400CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [3] = (RW_ uint32_t* const)0x52004014U,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
    [4] = (RW_ uint32_t* const)0x5200401CU,   /** @brief This register contains the control information of each memory bank, used for srams, PSRAM and NOR flash memories.if the EXTMOD bit is set in the fmc_bcrx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (fmc_bwtrx registers). */
  };

  static RW_ uint32_t* const FMC_BWTRx_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x52004104U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [2] = (RW_ uint32_t* const)0x5200410CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [3] = (RW_ uint32_t* const)0x52004114U,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
    [4] = (RW_ uint32_t* const)0x5200411CU,   /** @brief This register contains the control information of each memory bank. It is used for srams, psrams and NOR flash memories. When the EXTMOD bit is set in the fmc_bcrx register, then this register is active for write access. */
  };

  static RW_ uint32_t* const FMC_SDCRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52004140U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
    [2] = (RW_ uint32_t* const)0x52004144U,   /** @brief This register contains the control parameters for each SDRAM memory bank */
  };

  static RW_ uint32_t* const FMC_SDTRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52004148U,   /** @brief This register contains the timing parameters of each SDRAM bank */
    [2] = (RW_ uint32_t* const)0x5200414CU,   /** @brief This register contains the timing parameters of each SDRAM bank */
  };

  /**** @subsection FMC Register Field Masks ****/

  static const uint32_t FMC_BCRx_MBKEN_MSK     = 0x00000001U;   /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
  static const uint32_t FMC_BCRx_MUXEN_MSK     = 0x00000002U;   /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
  static const uint32_t FMC_BCRx_MTYP_MSK      = 0x0000000CU;   /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
  static const uint32_t FMC_BCRx_MWID_MSK      = 0x00000030U;   /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
  static const uint32_t FMC_BCRx_FACCEN_MSK    = 0x00000040U;   /** @brief Flash access enable this bit enables NOR flash memory access operations. */
  static const uint32_t FMC_BCRx_BURSTEN_MSK   = 0x00000100U;   /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
  static const uint32_t FMC_BCRx_WAITPOL_MSK   = 0x00000200U;   /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
  static const uint32_t FMC_BCRx_WAITCFG_MSK   = 0x00000800U;   /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
  static const uint32_t FMC_BCRx_WREN_MSK      = 0x00001000U;   /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
  static const uint32_t FMC_BCRx_WAITEN_MSK    = 0x00002000U;   /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
  static const uint32_t FMC_BCRx_EXTMOD_MSK    = 0x00004000U;   /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
  static const uint32_t FMC_BCRx_ASYNCWAIT_MSK = 0x00008000U;   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
  static const uint32_t FMC_BCRx_CPSIZE_MSK    = 0x00070000U;   /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
  static const uint32_t FMC_BCRx_CBURSTRW_MSK  = 0x00080000U;   /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
  static const uint32_t FMC_BCRx_CCLKEN_MSK    = 0x00100000U;   /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
  static const uint32_t FMC_BCRx_WFDIS_MSK     = 0x00200000U;   /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const uint32_t FMC_BCRx_BMAP_MSK      = 0x03000000U;   /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
  static const uint32_t FMC_BCRx_FMCEN_MSK     = 0x80000000U;   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const uint32_t FMC_BTRx_ADDSET_MSK    = 0x0000000FU;   /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
  static const uint32_t FMC_BTRx_ADDHLD_MSK    = 0x000000F0U;   /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
  static const uint32_t FMC_BTRx_DATAST_MSK    = 0x0000FF00U;   /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
  static const uint32_t FMC_BTRx_BUSTURN_MSK   = 0x000F0000U;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
  static const uint32_t FMC_BTRx_CLKDIV_MSK    = 0x00F00000U;   /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
  static const uint32_t FMC_BTRx_DATLAT_MSK    = 0x0F000000U;   /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
  static const uint32_t FMC_BTRx_ACCMOD_MSK    = 0x30000000U;   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const uint32_t FMC_PCR_PWAITEN_MSK    = 0x00000002U;   /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
  static const uint32_t FMC_PCR_PBKEN_MSK      = 0x00000004U;   /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
  static const uint32_t FMC_PCR_PWID_MSK       = 0x00000030U;   /** @brief Data bus width. These bits define the external memory device width. */
  static const uint32_t FMC_PCR_ECCEN_MSK      = 0x00000040U;   /** @brief ECC computation logic enable bit */
  static const uint32_t FMC_PCR_TCLR_MSK       = 0x00001E00U;   /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const uint32_t FMC_PCR_TAR_MSK        = 0x0001E000U;   /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const uint32_t FMC_PCR_ECCPS_MSK      = 0x000E0000U;   /** @brief ECC page size. These bits define the page size for the extended ECC: */
  static const uint32_t FMC_SR_IRS_MSK         = 0x00000001U;   /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const uint32_t FMC_SR_ILS_MSK         = 0x00000002U;   /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
  static const uint32_t FMC_SR_IFS_MSK         = 0x00000004U;   /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const uint32_t FMC_SR_IREN_MSK        = 0x00000008U;   /** @brief Interrupt rising edge detection enable bit */
  static const uint32_t FMC_SR_ILEN_MSK        = 0x00000010U;   /** @brief Interrupt high-level detection enable bit */
  static const uint32_t FMC_SR_IFEN_MSK        = 0x00000020U;   /** @brief Interrupt falling edge detection enable bit */
  static const uint32_t FMC_SR_FEMPT_MSK       = 0x00000040U;   /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
  static const uint32_t FMC_PMEM_MEMSET_MSK    = 0x000000FFU;   /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
  static const uint32_t FMC_PMEM_MEMWAIT_MSK   = 0x0000FF00U;   /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
  static const uint32_t FMC_PMEM_MEMHOLD_MSK   = 0x00FF0000U;   /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
  static const uint32_t FMC_PMEM_MEMHIZ_MSK    = 0xFF000000U;   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
  static const uint32_t FMC_PATT_ATTSET_MSK    = 0x000000FFU;   /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
  static const uint32_t FMC_PATT_ATTWAIT_MSK   = 0x0000FF00U;   /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
  static const uint32_t FMC_PATT_ATTHOLD_MSK   = 0x00FF0000U;   /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
  static const uint32_t FMC_PATT_ATTHIZ_MSK    = 0xFF000000U;   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
  static const uint32_t FMC_BWTRx_ADDSET_MSK   = 0x0000000FU;   /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
  static const uint32_t FMC_BWTRx_ADDHLD_MSK   = 0x000000F0U;   /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
  static const uint32_t FMC_BWTRx_DATAST_MSK   = 0x0000FF00U;   /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
  static const uint32_t FMC_BWTRx_BUSTURN_MSK  = 0x000F0000U;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
  static const uint32_t FMC_BWTRx_ACCMOD_MSK   = 0x30000000U;   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const uint32_t FMC_SDCRx_NC_MSK       = 0x00000003U;   /** @brief Number of column address bits these bits define the number of bits of a column address. */
  static const uint32_t FMC_SDCRx_NR_MSK       = 0x0000000CU;   /** @brief Number of row address bits these bits define the number of bits of a row address. */
  static const uint32_t FMC_SDCRx_MWID_MSK     = 0x00000030U;   /** @brief Memory data bus width. These bits define the memory device width. */
  static const uint32_t FMC_SDCRx_NB_MSK       = 0x00000040U;   /** @brief Number of internal banks this bit sets the number of internal banks. */
  static const uint32_t FMC_SDCRx_CAS_MSK      = 0x00000180U;   /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
  static const uint32_t FMC_SDCRx_WP_MSK       = 0x00000200U;   /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
  static const uint32_t FMC_SDCRx_SDCLK_MSK    = 0x00000C00U;   /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const uint32_t FMC_SDCRx_RBURST_MSK   = 0x00001000U;   /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
  static const uint32_t FMC_SDCRx_RPIPE_MSK    = 0x00006000U;   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const uint32_t FMC_SDTRx_TMRD_MSK     = 0x0000000FU;   /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
  static const uint32_t FMC_SDTRx_TXSR_MSK     = 0x000000F0U;   /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
  static const uint32_t FMC_SDTRx_TRAS_MSK     = 0x00000F00U;   /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
  static const uint32_t FMC_SDTRx_TRC_MSK      = 0x0000F000U;   /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const uint32_t FMC_SDTRx_TWR_MSK      = 0x000F0000U;   /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
  static const uint32_t FMC_SDTRx_TRP_MSK      = 0x00F00000U;   /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const uint32_t FMC_SDTRx_TRCD_MSK     = 0x0F000000U;   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
  static const uint32_t FMC_SDCMR_MODE_MSK     = 0x00000007U;   /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
  static const uint32_t FMC_SDCMR_NRFS_MSK     = 0x000001E0U;   /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
  static const uint32_t FMC_SDCMR_MRD_MSK      = 0x007FFE00U;   /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
  static const uint32_t FMC_SDRTR_CRE_MSK      = 0x00000001U;   /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
  static const uint32_t FMC_SDRTR_COUNT_MSK    = 0x00003FFEU;   /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
  static const uint32_t FMC_SDRTR_REIE_MSK     = 0x00004000U;   /** @brief RES interrupt enable */
  static const uint32_t FMC_SDSR_RE_MSK        = 0x00000001U;   /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */

  /**** @subsection Enumerated FMC Register Field Masks ****/

  static const uint32_t FMC_SDCMR_CTBx_MSK[3] = {
    [1] = 0x00000010U,   /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
    [2] = 0x00000008U,   /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
  };

  static const uint32_t FMC_SDSR_MODESx_MSK[3] = {
    [1] = 0x00000006U,   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    [2] = 0x00000018U,   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
  };

  /**** @subsection FMC Register Field Positions ****/

  static const int32_t FMC_BCRx_MBKEN_POS     = 0;    /** @brief Memory bank enable bit this bit enables the memory bank. After reset bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus. */
  static const int32_t FMC_BCRx_MUXEN_POS     = 1;    /** @brief Address/data multiplexing enable bit when this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories: */
  static const int32_t FMC_BCRx_MTYP_POS      = 2;    /** @brief Memory type these bits define the type of external memory attached to the corresponding memory bank: */
  static const int32_t FMC_BCRx_MWID_POS      = 4;    /** @brief Memory data bus width defines the external memory device width, valid for all type of memories. */
  static const int32_t FMC_BCRx_FACCEN_POS    = 6;    /** @brief Flash access enable this bit enables NOR flash memory access operations. */
  static const int32_t FMC_BCRx_BURSTEN_POS   = 8;    /** @brief Burst enable bit this bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in burst mode: */
  static const int32_t FMC_BCRx_WAITPOL_POS   = 9;    /** @brief Wait signal polarity bit this bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode: */
  static const int32_t FMC_BCRx_WAITCFG_POS   = 11;   /** @brief Wait timing configuration the NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state: */
  static const int32_t FMC_BCRx_WREN_POS      = 12;   /** @brief Write enable bit this bit indicates whether write operations are enabled/disabled in the bank by the FMC: */
  static const int32_t FMC_BCRx_WAITEN_POS    = 13;   /** @brief Wait enable bit this bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode. */
  static const int32_t FMC_BCRx_EXTMOD_POS    = 14;   /** @brief Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: when the extended mode is disabled, the FMC can operate in mode1 or mode2 as follows: ** mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10). */
  static const int32_t FMC_BCRx_ASYNCWAIT_POS = 15;   /** @brief Wait signal during asynchronous transfers this bit enables/disables the FMC to use the wait signal even during an asynchronous protocol. */
  static const int32_t FMC_BCRx_CPSIZE_POS    = 16;   /** @brief CRAM page size these are used for cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved. */
  static const int32_t FMC_BCRx_CBURSTRW_POS  = 19;   /** @brief Write burst enable for PSRAM (CRAM) operating in burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the fmc_bcrx register. */
  static const int32_t FMC_BCRx_CCLKEN_POS    = 20;   /** @brief Continuous clock enable this bit enables the FMC_CLK clock output to external memory devices. Note: the CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.) */
  static const int32_t FMC_BCRx_WFDIS_POS     = 21;   /** @brief Write FIFO disable this bit disables the write FIFO used by the FMC controller. Note: the WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const int32_t FMC_BCRx_BMAP_POS      = 24;   /** @brief FMC bank mapping these bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.refer to table 10 for note: the BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register. */
  static const int32_t FMC_BCRx_FMCEN_POS     = 31;   /** @brief FMC controller enable this bit enables/disables the FMC controller. Note: the FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. */
  static const int32_t FMC_BTRx_ADDSET_POS    = 0;    /** @brief Address setup phase duration these bits are written by software to define the duration of the address setup phase (refer to figure81 to figure93), used in srams, roms and asynchronous NOR flash: for each access mode address setup phase duration, please refer to the respective figure (refer to figure81 to figure93). Note: in synchronous accesses, this value is dont care. In muxed mode or mode D, the minimum value for ADDSET is 1. */
  static const int32_t FMC_BTRx_ADDHLD_POS    = 4;    /** @brief Address-hold phase duration these bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in mode D or multiplexed accesses: for each access mode address-hold phase duration, please refer to the respective figure (figure81 to figure93). Note: in synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration. */
  static const int32_t FMC_BTRx_DATAST_POS    = 8;    /** @brief Data-phase duration these bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous accesses: for each memory type and access mode data-phase duration, please refer to the respective figure (figure81 to figure93). Example: mode1, write access, DATAST=1: data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: in synchronous accesses, this value is dont care. */
  static const int32_t FMC_BTRx_BUSTURN_POS   = 16;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in burst or single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write access (in burst or single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tehel from nex high to nex low) and the maximum time required by the memory to free the data bus after a read access (tehqz): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin and (BUSTRUN + 2)KCK_FMC period &#8805; tehqzmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tehelmin, tehqzmax) if EXTMOD = 126. ... */
  static const int32_t FMC_BTRx_CLKDIV_POS    = 20;   /** @brief Clock divide ratio (for FMC_CLK signal) these bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: in asynchronous NOR flash, SRAM or PSRAM accesses, this value is dont care. Note: refer to section20.6.5: synchronous transactions for FMC_CLK divider ratio formula) */
  static const int32_t FMC_BTRx_DATLAT_POS    = 24;   /** @brief Data latency for synchronous memory for synchronous access with read write burst mode enabled these bits define the number of memory clock cycles */
  static const int32_t FMC_BTRx_ACCMOD_POS    = 28;   /** @brief Access mode these bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const int32_t FMC_PCR_PWAITEN_POS    = 1;    /** @brief Wait feature enable bit. This bit enables the wait feature for the NAND flash memory bank: */
  static const int32_t FMC_PCR_PBKEN_POS      = 2;    /** @brief NAND flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus */
  static const int32_t FMC_PCR_PWID_POS       = 4;    /** @brief Data bus width. These bits define the external memory device width. */
  static const int32_t FMC_PCR_ECCEN_POS      = 6;    /** @brief ECC computation logic enable bit */
  static const int32_t FMC_PCR_TCLR_POS       = 9;    /** @brief CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const int32_t FMC_PCR_TAR_POS        = 13;   /** @brief ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period note: set is MEMSET or ATTSET according to the addressed space. */
  static const int32_t FMC_PCR_ECCPS_POS      = 17;   /** @brief ECC page size. These bits define the page size for the extended ECC: */
  static const int32_t FMC_SR_IRS_POS         = 0;    /** @brief Interrupt rising edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const int32_t FMC_SR_ILS_POS         = 1;    /** @brief Interrupt high-level status the flag is set by hardware and reset by software. */
  static const int32_t FMC_SR_IFS_POS         = 2;    /** @brief Interrupt falling edge status the flag is set by hardware and reset by software. Note: if this bit is written by software to 1 it will be set. */
  static const int32_t FMC_SR_IREN_POS        = 3;    /** @brief Interrupt rising edge detection enable bit */
  static const int32_t FMC_SR_ILEN_POS        = 4;    /** @brief Interrupt high-level detection enable bit */
  static const int32_t FMC_SR_IFEN_POS        = 5;    /** @brief Interrupt falling edge detection enable bit */
  static const int32_t FMC_SR_FEMPT_POS       = 6;    /** @brief FIFO empty. Read-only bit that provides the status of the FIFO */
  static const int32_t FMC_PMEM_MEMSET_POS    = 0;    /** @brief Common memory x setup time these bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND flash read or write access to common memory space: */
  static const int32_t FMC_PMEM_MEMWAIT_POS   = 8;    /** @brief Common memory wait time these bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
  static const int32_t FMC_PMEM_MEMHOLD_POS   = 16;   /** @brief Common memory hold time these bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND flash read or write access to common memory space: */
  static const int32_t FMC_PMEM_MEMHIZ_POS    = 24;   /** @brief Common memory x data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept hi-z after the start of a NAND flash write access to common memory space. This is only valid for write transactions: */
  static const int32_t FMC_PATT_ATTSET_POS    = 0;    /** @brief Attribute memory setup time these bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
  static const int32_t FMC_PATT_ATTWAIT_POS   = 8;    /** @brief Attribute memory wait time these bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC: */
  static const int32_t FMC_PATT_ATTHOLD_POS   = 16;   /** @brief Attribute memory hold time these bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND flash read or write access to attribute memory space: */
  static const int32_t FMC_PATT_ATTHIZ_POS    = 24;   /** @brief Attribute memory data bus hi-z time these bits define the number of KCK_FMC clock cycles during which the data bus is kept in hi-z after the start of a NAND flash write access to attribute memory space on socket. Only valid for writ transaction: */
  static const int32_t FMC_BWTRx_ADDSET_POS   = 0;    /** @brief Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to figure81 to figure93), used in asynchronous accesses: ... Note: in synchronous accesses, this value is not used, the address setup phase is always 1 flash clock period duration. In muxed mode, the minimum ADDSET value is 1. */
  static const int32_t FMC_BWTRx_ADDHLD_POS   = 4;    /** @brief Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to figure81 to figure93), used in asynchronous multiplexed accesses: ... Note: in synchronous NOR flash accesses, this value is not used, the address hold phase is always 1 flash clock period duration. */
  static const int32_t FMC_BWTRx_DATAST_POS   = 8;    /** @brief Data-phase duration. These bits are written by software to define the duration of the data phase (refer to figure81 to figure93), used in asynchronous SRAM, PSRAM and NOR flash memory accesses: */
  static const int32_t FMC_BWTRx_BUSTURN_POS  = 16;   /** @brief Bus turnaround phase duration these bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tehel from enx high to enx low): (BUSTRUN + 1) KCK_FMC period &#8805; tehelmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: the bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to the same bank A synchronous write transfer ((in burst or single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: two consecutive synchronous write operations (in burst or single mode) to different static banks. A synchronous write transfer (in burst or single mode) and a synchronous read from the same or a different bank. ... */
  static const int32_t FMC_BWTRx_ACCMOD_POS   = 28;   /** @brief Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.these bits are taken into account only when the EXTMOD bit in the fmc_bcrx register is 1. */
  static const int32_t FMC_SDCRx_NC_POS       = 0;    /** @brief Number of column address bits these bits define the number of bits of a column address. */
  static const int32_t FMC_SDCRx_NR_POS       = 2;    /** @brief Number of row address bits these bits define the number of bits of a row address. */
  static const int32_t FMC_SDCRx_MWID_POS     = 4;    /** @brief Memory data bus width. These bits define the memory device width. */
  static const int32_t FMC_SDCRx_NB_POS       = 6;    /** @brief Number of internal banks this bit sets the number of internal banks. */
  static const int32_t FMC_SDCRx_CAS_POS      = 7;    /** @brief CAS latency this bits sets the SDRAM CAS latency in number of memory clock cycles */
  static const int32_t FMC_SDCRx_WP_POS       = 9;    /** @brief Write protection this bit enables write mode access to the SDRAM bank. */
  static const int32_t FMC_SDCRx_SDCLK_POS    = 10;   /** @brief SDRAM clock configuration these bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const int32_t FMC_SDCRx_RBURST_POS   = 12;   /** @brief Burst read this bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the read FIFO. Note: the corresponding bit in the FMC_SDCR2 register is read only. */
  static const int32_t FMC_SDCRx_RPIPE_POS    = 13;   /** @brief Read pipe these bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: the corresponding bits in the FMC_SDCR2 register is read only. */
  static const int32_t FMC_SDTRx_TMRD_POS     = 0;    /** @brief Load mode register to active these bits define the delay between a load mode register command and an active or refresh command in number of memory clock cycles. .... */
  static const int32_t FMC_SDTRx_TXSR_POS     = 4;    /** @brief Exit self-refresh delay these bits define the delay from releasing the self-refresh command to issuing the activate command in number of memory clock cycles. .... Note: if two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device. */
  static const int32_t FMC_SDTRx_TRAS_POS     = 8;    /** @brief Self refresh time these bits define the minimum self-refresh period in number of memory clock cycles. .... */
  static const int32_t FMC_SDTRx_TRC_POS      = 12;   /** @brief Row cycle delay these bits define the delay between the refresh command and the activate command, as well as the delay between two consecutive refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (auto refresh period) timings defined in the SDRAM device datasheet. Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const int32_t FMC_SDTRx_TWR_POS      = 16;   /** @brief Recovery delay these bits define the delay between a write and a precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (twr) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device. */
  static const int32_t FMC_SDTRx_TRP_POS      = 20;   /** @brief Row precharge delay these bits define the delay between a precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: the corresponding bits in the FMC_SDTR2 register are dont care. */
  static const int32_t FMC_SDTRx_TRCD_POS     = 24;   /** @brief Row to column delay these bits define the delay between the activate command and a read/write command in number of memory clock cycles. .... */
  static const int32_t FMC_SDCMR_MODE_POS     = 0;    /** @brief Command mode these bits define the command issued to the SDRAM device. Note: when a command is issued, at least one command target bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: if two SDRAM banks are used, the auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: if only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0. */
  static const int32_t FMC_SDCMR_NRFS_POS     = 5;    /** @brief Number of auto-refresh these bits define the number of consecutive auto-refresh commands issued when MODE = 011. .... */
  static const int32_t FMC_SDCMR_MRD_POS      = 9;    /** @brief Mode register definition this 14-bit field defines the SDRAM mode register content. The mode register is programmed using the load mode register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM. */
  static const int32_t FMC_SDRTR_CRE_POS      = 0;    /** @brief Clear refresh error flag this bit is used to clear the refresh error flag (RE) in the status register. */
  static const int32_t FMC_SDRTR_COUNT_POS    = 1;    /** @brief Refresh timer count this 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / number of rows) - 20 */
  static const int32_t FMC_SDRTR_REIE_POS     = 14;   /** @brief RES interrupt enable */
  static const int32_t FMC_SDSR_RE_POS        = 0;    /** @brief Refresh error flag an interrupt is generated if REIE = 1 and RE = 1 */

  /**** @subsection Enumerated FMC Register Field Positions ****/

  static const int32_t FMC_SDCMR_CTBx_POS[3] = {
    [1] = 4,   /** @brief Command target bank 1 this bit indicates whether the command will be issued to SDRAM bank 1 or not. */
    [2] = 3,   /** @brief Command target bank 2 this bit indicates whether the command will be issued to SDRAM bank 2 or not. */
  };

  static const int32_t FMC_SDSR_MODESx_POS[3] = {
    [1] = 1,   /** @brief Status mode for bank 1 these bits define the status mode of SDRAM bank 1. */
    [2] = 3,   /** @brief Status mode for bank 2 these bits define the status mode of SDRAM bank 2. */
  };

  /**********************************************************************************************
   * @section CEC Register Information
   **********************************************************************************************/

  /**** @subsection CEC Register Pointers ****/

  static RW_ uint32_t* const CEC_CR_PTR   = (RW_ uint32_t* const)0x40006C00U;   /** @brief CEC control register */
  static RW_ uint32_t* const CEC_CFGR_PTR = (RW_ uint32_t* const)0x40006C04U;   /** @brief This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0. */
  static WO_ uint32_t* const CEC_TXDR_PTR = (WO_ uint32_t* const)0x40006C08U;   /** @brief CEC tx data register */
  static RO_ uint32_t* const CEC_RXDR_PTR = (RO_ uint32_t* const)0x40006C0CU;   /** @brief CEC rx data register */
  static RW_ uint32_t* const CEC_ISR_PTR  = (RW_ uint32_t* const)0x40006C10U;   /** @brief CEC interrupt and status register */
  static RW_ uint32_t* const CEC_IER_PTR  = (RW_ uint32_t* const)0x40006C14U;   /** @brief CEC interrupt enable register */

  /**** @subsection CEC Register Field Masks ****/

  static const uint32_t CEC_CR_CECEN_MSK      = 0x00000001U;   /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
  static const uint32_t CEC_CR_TXSOM_MSK      = 0x00000002U;   /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
  static const uint32_t CEC_CR_TXEOM_MSK      = 0x00000004U;   /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
  static const uint32_t CEC_CFGR_SFT_MSK      = 0x00000007U;   /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
  static const uint32_t CEC_CFGR_RXTOL_MSK    = 0x00000008U;   /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
  static const uint32_t CEC_CFGR_BRESTP_MSK   = 0x00000010U;   /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
  static const uint32_t CEC_CFGR_BREGEN_MSK   = 0x00000020U;   /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
  static const uint32_t CEC_CFGR_LBPEGEN_MSK  = 0x00000040U;   /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
  static const uint32_t CEC_CFGR_BRDNOGEN_MSK = 0x00000080U;   /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
  static const uint32_t CEC_CFGR_SFTOPT_MSK   = 0x00000100U;   /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
  static const uint32_t CEC_CFGR_OAR_MSK      = 0x7FFF0000U;   /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
  static const uint32_t CEC_CFGR_LSTN_MSK     = 0x80000000U;   /** @brief Listen mode LSTN bit is set and cleared by software. */
  static const uint32_t CEC_TXDR_TXD_MSK      = 0x000000FFU;   /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
  static const uint32_t CEC_RXDR_RXD_MSK      = 0x000000FFU;   /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
  static const uint32_t CEC_ISR_RXBR_MSK      = 0x00000001U;   /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
  static const uint32_t CEC_ISR_RXEND_MSK     = 0x00000002U;   /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
  static const uint32_t CEC_ISR_RXOVR_MSK     = 0x00000004U;   /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
  static const uint32_t CEC_ISR_BRE_MSK       = 0x00000008U;   /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
  static const uint32_t CEC_ISR_SBPE_MSK      = 0x00000010U;   /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
  static const uint32_t CEC_ISR_LBPE_MSK      = 0x00000020U;   /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
  static const uint32_t CEC_ISR_RXACKE_MSK    = 0x00000040U;   /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
  static const uint32_t CEC_ISR_ARBLST_MSK    = 0x00000080U;   /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
  static const uint32_t CEC_ISR_TXBR_MSK      = 0x00000100U;   /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
  static const uint32_t CEC_ISR_TXEND_MSK     = 0x00000200U;   /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
  static const uint32_t CEC_ISR_TXUDR_MSK     = 0x00000400U;   /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
  static const uint32_t CEC_ISR_TXERR_MSK     = 0x00000800U;   /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
  static const uint32_t CEC_ISR_TXACKE_MSK    = 0x00001000U;   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
  static const uint32_t CEC_IER_RXBRIE_MSK    = 0x00000001U;   /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_RXENDIE_MSK   = 0x00000002U;   /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_RXOVRIE_MSK   = 0x00000004U;   /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_BREIE_MSK     = 0x00000008U;   /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_SBPEIE_MSK    = 0x00000010U;   /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_LBPEIE_MSK    = 0x00000020U;   /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_RXACKIE_MSK   = 0x00000040U;   /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_ARBLSTIE_MSK  = 0x00000080U;   /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_TXBRIE_MSK    = 0x00000100U;   /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_TXENDIE_MSK   = 0x00000200U;   /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_TXUDRIE_MSK   = 0x00000400U;   /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_TXERRIE_MSK   = 0x00000800U;   /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
  static const uint32_t CEC_IER_TXACKIE_MSK   = 0x00001000U;   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

  /**** @subsection CEC Register Field Positions ****/

  static const int32_t CEC_CR_CECEN_POS      = 0;    /** @brief CEC enable the CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission. */
  static const int32_t CEC_CR_TXSOM_POS      = 1;    /** @brief Tx start of message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR headers first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception */
  static const int32_t CEC_CR_TXEOM_POS      = 2;    /** @brief Tx end of message the TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR if TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message) */
  static const int32_t CEC_CFGR_SFT_POS      = 0;    /** @brief Signal free time SFT bits are set by software. In the sft=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 data-bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 data-bit periods if CEC is the new bus initiator ** 6 data-bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods */
  static const int32_t CEC_CFGR_RXTOL_POS    = 3;    /** @brief Rx-Tolerance the RXTOL bit is set and cleared by software. ** start-bit, +/- 200 s rise, +/- 200 s fall. ** data-bit: +/- 200 s rise. +/- 350 s fall. ** start-bit: +/- 400 s rise, +/- 400 s fall ** data-bit: +/-300 s rise, +/- 500 s fall */
  static const int32_t CEC_CFGR_BRESTP_POS   = 4;    /** @brief Rx-Stop on bit rising error the BRESTP bit is set and cleared by software. */
  static const int32_t CEC_CFGR_BREGEN_POS   = 5;    /** @brief Generate error-bit on bit rising error the BREGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0 */
  static const int32_t CEC_CFGR_LBPEGEN_POS  = 6;    /** @brief Generate error-bit on long bit period error the LBPEGEN bit is set and cleared by software. Note: if BRDNOGEN=0, an error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0 */
  static const int32_t CEC_CFGR_BRDNOGEN_POS = 7;    /** @brief Avoid error-bit generation in broadcast the BRDNOGEN bit is set and cleared by software. */
  static const int32_t CEC_CFGR_SFTOPT_POS   = 8;    /** @brief SFT option bit the SFTOPT bit is set and cleared by software. */
  static const int32_t CEC_CFGR_OAR_POS      = 16;   /** @brief Own addresses configuration the OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received. */
  static const int32_t CEC_CFGR_LSTN_POS     = 31;   /** @brief Listen mode LSTN bit is set and cleared by software. */
  static const int32_t CEC_TXDR_TXD_POS      = 0;    /** @brief Tx data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1 */
  static const int32_t CEC_RXDR_RXD_POS      = 0;    /** @brief Rx data register. RXD is read-only and contains the last data byte which has been received from the CEC line. */
  static const int32_t CEC_ISR_RXBR_POS      = 0;    /** @brief Rx-Byte received the RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1. */
  static const int32_t CEC_ISR_RXEND_POS     = 1;    /** @brief End of reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1. */
  static const int32_t CEC_ISR_RXOVR_POS     = 2;    /** @brief Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1. */
  static const int32_t CEC_ISR_BRE_POS       = 3;    /** @brief Rx-Bit rising error BRE is set by hardware in case a data-bit waveform is detected with bit rising error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an error-bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1. */
  static const int32_t CEC_ISR_SBPE_POS      = 4;    /** @brief Rx-Short bit period error SBPE is set by hardware in case a data-bit waveform is detected with short bit period error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an error-bit on the CEC line. SBPE is cleared by software write at 1. */
  static const int32_t CEC_ISR_LBPE_POS      = 5;    /** @brief Rx-Long bit period error LBPE is set by hardware in case a data-bit waveform is detected with long bit period error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an error-bit on the CEC line if LBPEGEN=1. In case of broadcast, error-bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1. */
  static const int32_t CEC_ISR_RXACKE_POS    = 6;    /** @brief Rx-Missing acknowledge in receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1. */
  static const int32_t CEC_ISR_ARBLST_POS    = 7;    /** @brief Arbitration lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1. */
  static const int32_t CEC_ISR_TXBR_POS      = 8;    /** @brief Tx-Byte request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1. */
  static const int32_t CEC_ISR_TXEND_POS     = 9;    /** @brief End of transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1. */
  static const int32_t CEC_ISR_TXUDR_POS     = 10;   /** @brief Tx-Buffer underrun in transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1 */
  static const int32_t CEC_ISR_TXERR_POS     = 11;   /** @brief Tx-Error in transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1. */
  static const int32_t CEC_ISR_TXACKE_POS    = 12;   /** @brief Tx-Missing acknowledge error in transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1. */
  static const int32_t CEC_IER_RXBRIE_POS    = 0;    /** @brief Rx-Byte received interrupt enable the RXBRIE bit is set and cleared by software. */
  static const int32_t CEC_IER_RXENDIE_POS   = 1;    /** @brief End of reception interrupt enable the RXENDIE bit is set and cleared by software. */
  static const int32_t CEC_IER_RXOVRIE_POS   = 2;    /** @brief Rx-Buffer overrun interrupt enable the RXOVRIE bit is set and cleared by software. */
  static const int32_t CEC_IER_BREIE_POS     = 3;    /** @brief Bit rising error interrupt enable the BREIE bit is set and cleared by software. */
  static const int32_t CEC_IER_SBPEIE_POS    = 4;    /** @brief Short bit period error interrupt enable the SBPEIE bit is set and cleared by software. */
  static const int32_t CEC_IER_LBPEIE_POS    = 5;    /** @brief Long bit period error interrupt enable the LBPEIE bit is set and cleared by software. */
  static const int32_t CEC_IER_RXACKIE_POS   = 6;    /** @brief Rx-Missing acknowledge error interrupt enable the RXACKIE bit is set and cleared by software. */
  static const int32_t CEC_IER_ARBLSTIE_POS  = 7;    /** @brief Arbitration lost interrupt enable the ARBLSTIE bit is set and cleared by software. */
  static const int32_t CEC_IER_TXBRIE_POS    = 8;    /** @brief Tx-Byte request interrupt enable the TXBRIE bit is set and cleared by software. */
  static const int32_t CEC_IER_TXENDIE_POS   = 9;    /** @brief Tx-End of message interrupt enable the TXENDIE bit is set and cleared by software. */
  static const int32_t CEC_IER_TXUDRIE_POS   = 10;   /** @brief Tx-Underrun interrupt enable the TXUDRIE bit is set and cleared by software. */
  static const int32_t CEC_IER_TXERRIE_POS   = 11;   /** @brief Tx-Error interrupt enable the TXERRIE bit is set and cleared by software. */
  static const int32_t CEC_IER_TXACKIE_POS   = 12;   /** @brief Tx-Missing acknowledge error interrupt enable the TXACKEIE bit is set and cleared by software. */

  /**********************************************************************************************
   * @section HSEM Register Information
   **********************************************************************************************/

  /**** @subsection HSEM Register Pointers ****/

  static RW_ uint32_t* const HSEM_HSEM_IER_PTR= (RW_ uint32_t* const)0x58026500U;   /** @brief HSEM interrupt enable register */
  static RO_ uint32_t* const HSEM_HSEM_ICR_PTR= (RO_ uint32_t* const)0x58026504U;   /** @brief HSEM interrupt clear register */
  static RO_ uint32_t* const HSEM_HSEM_ISR_PTR= (RO_ uint32_t* const)0x58026508U;   /** @brief HSEM interrupt status register */
  static RO_ uint32_t* const HSEM_HSEM_MISR_PTR= (RO_ uint32_t* const)0x5802650CU;   /** @brief HSEM masked interrupt status register */
  static RW_ uint32_t* const HSEM_HSEM_CR_PTR= (RW_ uint32_t* const)0x58026540U;   /** @brief HSEM clear register */
  static RW_ uint32_t* const HSEM_HSEM_KEYR_PTR= (RW_ uint32_t* const)0x58026544U;   /** @brief HSEM interrupt clear register */

  /**** @subsection Enumerated HSEM Register Pointers ****/

  static RW_ uint32_t* const HSEM_HSEM_Rx_PTR[32] = {
    [0]  = (RW_ uint32_t* const)0x58026400U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [1]  = (RW_ uint32_t* const)0x58026404U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [2]  = (RW_ uint32_t* const)0x58026408U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [3]  = (RW_ uint32_t* const)0x5802640CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [4]  = (RW_ uint32_t* const)0x58026410U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [5]  = (RW_ uint32_t* const)0x58026414U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [6]  = (RW_ uint32_t* const)0x58026418U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [7]  = (RW_ uint32_t* const)0x5802641CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [8]  = (RW_ uint32_t* const)0x58026420U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [9]  = (RW_ uint32_t* const)0x58026424U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [10] = (RW_ uint32_t* const)0x58026428U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [11] = (RW_ uint32_t* const)0x5802642CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [12] = (RW_ uint32_t* const)0x58026430U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [13] = (RW_ uint32_t* const)0x58026434U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [14] = (RW_ uint32_t* const)0x58026438U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [15] = (RW_ uint32_t* const)0x5802643CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [16] = (RW_ uint32_t* const)0x58026440U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [17] = (RW_ uint32_t* const)0x58026444U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [18] = (RW_ uint32_t* const)0x58026448U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [19] = (RW_ uint32_t* const)0x5802644CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [20] = (RW_ uint32_t* const)0x58026450U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [21] = (RW_ uint32_t* const)0x58026454U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [22] = (RW_ uint32_t* const)0x58026458U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [23] = (RW_ uint32_t* const)0x5802645CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [24] = (RW_ uint32_t* const)0x58026460U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [25] = (RW_ uint32_t* const)0x58026464U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [26] = (RW_ uint32_t* const)0x58026468U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [27] = (RW_ uint32_t* const)0x5802646CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [28] = (RW_ uint32_t* const)0x58026470U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [29] = (RW_ uint32_t* const)0x58026474U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [30] = (RW_ uint32_t* const)0x58026478U,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
    [31] = (RW_ uint32_t* const)0x5802647CU,   /** @brief HSEM register HSEM_R0 HSEM_R31 */
  };

  static RO_ uint32_t* const HSEM_HSEM_RLRx_PTR[32] = {
    [0]  = (RO_ uint32_t* const)0x58026480U,   /** @brief HSEM read lock register */
    [1]  = (RO_ uint32_t* const)0x58026484U,   /** @brief HSEM read lock register */
    [2]  = (RO_ uint32_t* const)0x58026488U,   /** @brief HSEM read lock register */
    [3]  = (RO_ uint32_t* const)0x5802648CU,   /** @brief HSEM read lock register */
    [4]  = (RO_ uint32_t* const)0x58026490U,   /** @brief HSEM read lock register */
    [5]  = (RO_ uint32_t* const)0x58026494U,   /** @brief HSEM read lock register */
    [6]  = (RO_ uint32_t* const)0x58026498U,   /** @brief HSEM read lock register */
    [7]  = (RO_ uint32_t* const)0x5802649CU,   /** @brief HSEM read lock register */
    [8]  = (RO_ uint32_t* const)0x580264A0U,   /** @brief HSEM read lock register */
    [9]  = (RO_ uint32_t* const)0x580264A4U,   /** @brief HSEM read lock register */
    [10] = (RO_ uint32_t* const)0x580264A8U,   /** @brief HSEM read lock register */
    [11] = (RO_ uint32_t* const)0x580264ACU,   /** @brief HSEM read lock register */
    [12] = (RO_ uint32_t* const)0x580264B0U,   /** @brief HSEM read lock register */
    [13] = (RO_ uint32_t* const)0x580264B4U,   /** @brief HSEM read lock register */
    [14] = (RO_ uint32_t* const)0x580264B8U,   /** @brief HSEM read lock register */
    [15] = (RO_ uint32_t* const)0x580264BCU,   /** @brief HSEM read lock register */
    [16] = (RO_ uint32_t* const)0x580264C0U,   /** @brief HSEM read lock register */
    [17] = (RO_ uint32_t* const)0x580264C4U,   /** @brief HSEM read lock register */
    [18] = (RO_ uint32_t* const)0x580264C8U,   /** @brief HSEM read lock register */
    [19] = (RO_ uint32_t* const)0x580264CCU,   /** @brief HSEM read lock register */
    [20] = (RO_ uint32_t* const)0x580264D0U,   /** @brief HSEM read lock register */
    [21] = (RO_ uint32_t* const)0x580264D4U,   /** @brief HSEM read lock register */
    [22] = (RO_ uint32_t* const)0x580264D8U,   /** @brief HSEM read lock register */
    [23] = (RO_ uint32_t* const)0x580264DCU,   /** @brief HSEM read lock register */
    [24] = (RO_ uint32_t* const)0x580264E0U,   /** @brief HSEM read lock register */
    [25] = (RO_ uint32_t* const)0x580264E4U,   /** @brief HSEM read lock register */
    [26] = (RO_ uint32_t* const)0x580264E8U,   /** @brief HSEM read lock register */
    [27] = (RO_ uint32_t* const)0x580264ECU,   /** @brief HSEM read lock register */
    [28] = (RO_ uint32_t* const)0x580264F0U,   /** @brief HSEM read lock register */
    [29] = (RO_ uint32_t* const)0x580264F4U,   /** @brief HSEM read lock register */
    [30] = (RO_ uint32_t* const)0x580264F8U,   /** @brief HSEM read lock register */
    [31] = (RO_ uint32_t* const)0x580264FCU,   /** @brief HSEM read lock register */
  };

  /**** @subsection HSEM Register Field Masks ****/

  static const uint32_t HSEM_HSEM_Rx_PROCID_MSK     = 0x000000FFU;   /** @brief Semaphore processid */
  static const uint32_t HSEM_HSEM_Rx_MASTERID_MSK   = 0x0000FF00U;   /** @brief Semaphore masterid */
  static const uint32_t HSEM_HSEM_Rx_LOCK_MSK       = 0x80000000U;   /** @brief Lock indication */
  static const uint32_t HSEM_HSEM_RLRx_PROCID_MSK   = 0x000000FFU;   /** @brief Semaphore processid */
  static const uint32_t HSEM_HSEM_RLRx_MASTERID_MSK = 0x0000FF00U;   /** @brief Semaphore masterid */
  static const uint32_t HSEM_HSEM_RLRx_LOCK_MSK     = 0x80000000U;   /** @brief Lock indication */
  static const uint32_t HSEM_HSEM_CR_MASTERID_MSK   = 0x0000FF00U;   /** @brief MasterID of semaphores to be cleared */
  static const uint32_t HSEM_HSEM_CR_KEY_MSK        = 0xFFFF0000U;   /** @brief Semaphore clear key */
  static const uint32_t HSEM_HSEM_KEYR_KEY_MSK      = 0xFFFF0000U;   /** @brief Semaphore clear key */

  /**** @subsection Enumerated HSEM Register Field Masks ****/

  static const uint32_t HSEM_HSEM_IER_ISEMx_MSK[32] = {
    [0]  = 0x00000001U,   /** @brief Interrupt semaphore n enable bit */
    [1]  = 0x00000002U,   /** @brief Interrupt semaphore n enable bit */
    [2]  = 0x00000004U,   /** @brief Interrupt semaphore n enable bit */
    [3]  = 0x00000008U,   /** @brief Interrupt semaphore n enable bit */
    [4]  = 0x00000010U,   /** @brief Interrupt semaphore n enable bit */
    [5]  = 0x00000020U,   /** @brief Interrupt semaphore n enable bit */
    [6]  = 0x00000040U,   /** @brief Interrupt semaphore n enable bit */
    [7]  = 0x00000080U,   /** @brief Interrupt semaphore n enable bit */
    [8]  = 0x00000100U,   /** @brief Interrupt semaphore n enable bit */
    [9]  = 0x00000200U,   /** @brief Interrupt semaphore n enable bit */
    [10] = 0x00000400U,   /** @brief Interrupt semaphore n enable bit */
    [11] = 0x00000800U,   /** @brief Interrupt semaphore n enable bit */
    [12] = 0x00001000U,   /** @brief Interrupt semaphore n enable bit */
    [13] = 0x00002000U,   /** @brief Interrupt semaphore n enable bit */
    [14] = 0x00004000U,   /** @brief Interrupt semaphore n enable bit */
    [15] = 0x00008000U,   /** @brief Interrupt semaphore n enable bit */
    [16] = 0x00010000U,   /** @brief Interrupt semaphore n enable bit */
    [17] = 0x00020000U,   /** @brief Interrupt semaphore n enable bit */
    [18] = 0x00040000U,   /** @brief Interrupt semaphore n enable bit */
    [19] = 0x00080000U,   /** @brief Interrupt semaphore n enable bit */
    [20] = 0x00100000U,   /** @brief Interrupt semaphore n enable bit */
    [21] = 0x00200000U,   /** @brief Interrupt semaphore n enable bit */
    [22] = 0x00400000U,   /** @brief Interrupt semaphore n enable bit */
    [23] = 0x00800000U,   /** @brief Interrupt semaphore n enable bit */
    [24] = 0x01000000U,   /** @brief Interrupt semaphore n enable bit */
    [25] = 0x02000000U,   /** @brief Interrupt semaphore n enable bit */
    [26] = 0x04000000U,   /** @brief Interrupt semaphore n enable bit */
    [27] = 0x08000000U,   /** @brief Interrupt semaphore n enable bit */
    [28] = 0x10000000U,   /** @brief Interrupt semaphore n enable bit */
    [29] = 0x20000000U,   /** @brief Interrupt semaphore n enable bit */
    [30] = 0x40000000U,   /** @brief Interrupt semaphore n enable bit */
    [31] = 0x80000000U,   /** @brief Interrupt(N) semaphore n enable bit. */
  };

  /**** @subsection HSEM Register Field Positions ****/

  static const int32_t HSEM_HSEM_Rx_PROCID_POS     = 0;    /** @brief Semaphore processid */
  static const int32_t HSEM_HSEM_Rx_MASTERID_POS   = 8;    /** @brief Semaphore masterid */
  static const int32_t HSEM_HSEM_Rx_LOCK_POS       = 31;   /** @brief Lock indication */
  static const int32_t HSEM_HSEM_RLRx_PROCID_POS   = 0;    /** @brief Semaphore processid */
  static const int32_t HSEM_HSEM_RLRx_MASTERID_POS = 8;    /** @brief Semaphore masterid */
  static const int32_t HSEM_HSEM_RLRx_LOCK_POS     = 31;   /** @brief Lock indication */
  static const int32_t HSEM_HSEM_CR_MASTERID_POS   = 8;    /** @brief MasterID of semaphores to be cleared */
  static const int32_t HSEM_HSEM_CR_KEY_POS        = 16;   /** @brief Semaphore clear key */
  static const int32_t HSEM_HSEM_KEYR_KEY_POS      = 16;   /** @brief Semaphore clear key */

  /**** @subsection Enumerated HSEM Register Field Positions ****/

  static const int32_t HSEM_HSEM_IER_ISEMx_POS[32] = {
    [0]  = 0,    /** @brief Interrupt semaphore n enable bit */
    [1]  = 1,    /** @brief Interrupt semaphore n enable bit */
    [2]  = 2,    /** @brief Interrupt semaphore n enable bit */
    [3]  = 3,    /** @brief Interrupt semaphore n enable bit */
    [4]  = 4,    /** @brief Interrupt semaphore n enable bit */
    [5]  = 5,    /** @brief Interrupt semaphore n enable bit */
    [6]  = 6,    /** @brief Interrupt semaphore n enable bit */
    [7]  = 7,    /** @brief Interrupt semaphore n enable bit */
    [8]  = 8,    /** @brief Interrupt semaphore n enable bit */
    [9]  = 9,    /** @brief Interrupt semaphore n enable bit */
    [10] = 10,   /** @brief Interrupt semaphore n enable bit */
    [11] = 11,   /** @brief Interrupt semaphore n enable bit */
    [12] = 12,   /** @brief Interrupt semaphore n enable bit */
    [13] = 13,   /** @brief Interrupt semaphore n enable bit */
    [14] = 14,   /** @brief Interrupt semaphore n enable bit */
    [15] = 15,   /** @brief Interrupt semaphore n enable bit */
    [16] = 16,   /** @brief Interrupt semaphore n enable bit */
    [17] = 17,   /** @brief Interrupt semaphore n enable bit */
    [18] = 18,   /** @brief Interrupt semaphore n enable bit */
    [19] = 19,   /** @brief Interrupt semaphore n enable bit */
    [20] = 20,   /** @brief Interrupt semaphore n enable bit */
    [21] = 21,   /** @brief Interrupt semaphore n enable bit */
    [22] = 22,   /** @brief Interrupt semaphore n enable bit */
    [23] = 23,   /** @brief Interrupt semaphore n enable bit */
    [24] = 24,   /** @brief Interrupt semaphore n enable bit */
    [25] = 25,   /** @brief Interrupt semaphore n enable bit */
    [26] = 26,   /** @brief Interrupt semaphore n enable bit */
    [27] = 27,   /** @brief Interrupt semaphore n enable bit */
    [28] = 28,   /** @brief Interrupt semaphore n enable bit */
    [29] = 29,   /** @brief Interrupt semaphore n enable bit */
    [30] = 30,   /** @brief Interrupt semaphore n enable bit */
    [31] = 31,   /** @brief Interrupt(N) semaphore n enable bit. */
  };

  /**********************************************************************************************
   * @section I2Cx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated I2Cx Register Pointers ****/

  static RW_ uint32_t* const I2Cx_CRx_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40005400U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005404U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40005800U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005804U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40005C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x58001C00U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x58001C04U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
  };

  static RW_ uint32_t* const I2Cx_OARx_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40005408U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x4000540CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40005808U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x4000580CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40005C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x40005C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x58001C08U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
      [2] = (RW_ uint32_t* const)0x58001C0CU,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    },
  };

  static RW_ uint32_t* const I2Cx_TIMINGR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40005410U,   /** @brief Access: no wait states */
    [2] = (RW_ uint32_t* const)0x40005810U,   /** @brief Access: no wait states */
    [3] = (RW_ uint32_t* const)0x40005C10U,   /** @brief Access: no wait states */
    [4] = (RW_ uint32_t* const)0x58001C10U,   /** @brief Access: no wait states */
  };

  static RW_ uint32_t* const I2Cx_TIMEOUTR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40005414U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [2] = (RW_ uint32_t* const)0x40005814U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [3] = (RW_ uint32_t* const)0x40005C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
    [4] = (RW_ uint32_t* const)0x58001C14U,   /** @brief Access: no wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK. */
  };

  static RW_ uint32_t* const I2Cx_ISR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40005418U,   /** @brief Access: no wait states */
    [2] = (RW_ uint32_t* const)0x40005818U,   /** @brief Access: no wait states */
    [3] = (RW_ uint32_t* const)0x40005C18U,   /** @brief Access: no wait states */
    [4] = (RW_ uint32_t* const)0x58001C18U,   /** @brief Access: no wait states */
  };

  static WO_ uint32_t* const I2Cx_ICR_PTR[5] = {
    [1] = (WO_ uint32_t* const)0x4000541CU,   /** @brief Access: no wait states */
    [2] = (WO_ uint32_t* const)0x4000581CU,   /** @brief Access: no wait states */
    [3] = (WO_ uint32_t* const)0x40005C1CU,   /** @brief Access: no wait states */
    [4] = (WO_ uint32_t* const)0x58001C1CU,   /** @brief Access: no wait states */
  };

  static RO_ uint32_t* const I2Cx_PECR_PTR[5] = {
    [1] = (RO_ uint32_t* const)0x40005420U,   /** @brief Access: no wait states */
    [2] = (RO_ uint32_t* const)0x40005820U,   /** @brief Access: no wait states */
    [3] = (RO_ uint32_t* const)0x40005C20U,   /** @brief Access: no wait states */
    [4] = (RO_ uint32_t* const)0x58001C20U,   /** @brief Access: no wait states */
  };

  static RO_ uint32_t* const I2Cx_RXDR_PTR[5] = {
    [1] = (RO_ uint32_t* const)0x40005424U,   /** @brief Access: no wait states */
    [2] = (RO_ uint32_t* const)0x40005824U,   /** @brief Access: no wait states */
    [3] = (RO_ uint32_t* const)0x40005C24U,   /** @brief Access: no wait states */
    [4] = (RO_ uint32_t* const)0x58001C24U,   /** @brief Access: no wait states */
  };

  static RW_ uint32_t* const I2Cx_TXDR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40005428U,   /** @brief Access: no wait states */
    [2] = (RW_ uint32_t* const)0x40005828U,   /** @brief Access: no wait states */
    [3] = (RW_ uint32_t* const)0x40005C28U,   /** @brief Access: no wait states */
    [4] = (RW_ uint32_t* const)0x58001C28U,   /** @brief Access: no wait states */
  };

  /**** @subsection I2Cx Register Field Masks ****/

  static const uint32_t I2Cx_CRx_PE_MSK            = 0x00000001U;   /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
  static const uint32_t I2Cx_CRx_TXIE_MSK          = 0x00000002U;   /** @brief TX interrupt enable */
  static const uint32_t I2Cx_CRx_RXIE_MSK          = 0x00000004U;   /** @brief RX interrupt enable */
  static const uint32_t I2Cx_CRx_ADDRIE_MSK        = 0x00000008U;   /** @brief Address match interrupt enable (slave only) */
  static const uint32_t I2Cx_CRx_NACKIE_MSK        = 0x00000010U;   /** @brief Not acknowledge received interrupt enable */
  static const uint32_t I2Cx_CRx_STOPIE_MSK        = 0x00000020U;   /** @brief STOP detection interrupt enable */
  static const uint32_t I2Cx_CRx_TCIE_MSK          = 0x00000040U;   /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
  static const uint32_t I2Cx_CRx_ERRIE_MSK         = 0x00000080U;   /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
  static const uint32_t I2Cx_CRx_DNF_MSK           = 0x00000F00U;   /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
  static const uint32_t I2Cx_CRx_ANFOFF_MSK        = 0x00001000U;   /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const uint32_t I2Cx_CRx_TXDMAEN_MSK       = 0x00004000U;   /** @brief DMA transmission requests enable */
  static const uint32_t I2Cx_CRx_RXDMAEN_MSK       = 0x00008000U;   /** @brief DMA reception requests enable */
  static const uint32_t I2Cx_CRx_SBC_MSK           = 0x00010000U;   /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
  static const uint32_t I2Cx_CRx_NOSTRETCH_MSK     = 0x00020000U;   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const uint32_t I2Cx_CRx_WUPEN_MSK         = 0x00040000U;   /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
  static const uint32_t I2Cx_CRx_GCEN_MSK          = 0x00080000U;   /** @brief General call enable */
  static const uint32_t I2Cx_CRx_SMBHEN_MSK        = 0x00100000U;   /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_CRx_SMBDEN_MSK        = 0x00200000U;   /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_CRx_ALERTEN_MSK       = 0x00400000U;   /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_CRx_PECEN_MSK         = 0x00800000U;   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_OARx_OA1_MSK          = 0x000003FFU;   /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
  static const uint32_t I2Cx_OARx_OA1MODE_MSK      = 0x00000400U;   /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
  static const uint32_t I2Cx_OARx_OA1EN_MSK        = 0x00008000U;   /** @brief Own address 1 enable */
  static const uint32_t I2Cx_TIMINGR_SCLL_MSK      = 0x000000FFU;   /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
  static const uint32_t I2Cx_TIMINGR_SCLH_MSK      = 0x0000FF00U;   /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
  static const uint32_t I2Cx_TIMINGR_SDADEL_MSK    = 0x000F0000U;   /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
  static const uint32_t I2Cx_TIMINGR_SCLDEL_MSK    = 0x00F00000U;   /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
  static const uint32_t I2Cx_TIMINGR_PRESC_MSK     = 0xF0000000U;   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
  static const uint32_t I2Cx_TIMEOUTR_TIMEOUTA_MSK = 0x00000FFFU;   /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
  static const uint32_t I2Cx_TIMEOUTR_TIDLE_MSK    = 0x00001000U;   /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
  static const uint32_t I2Cx_TIMEOUTR_TIMOUTEN_MSK = 0x00008000U;   /** @brief Clock timeout enable */
  static const uint32_t I2Cx_TIMEOUTR_TIMEOUTB_MSK = 0x0FFF0000U;   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
  static const uint32_t I2Cx_TIMEOUTR_TEXTEN_MSK   = 0x80000000U;   /** @brief Extended clock timeout enable */
  static const uint32_t I2Cx_ISR_TXE_MSK           = 0x00000001U;   /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_TXIS_MSK          = 0x00000002U;   /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_RXNE_MSK          = 0x00000004U;   /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_ADDR_MSK          = 0x00000008U;   /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_NACKF_MSK         = 0x00000010U;   /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_STOPF_MSK         = 0x00000020U;   /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_TC_MSK            = 0x00000040U;   /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_TCR_MSK           = 0x00000080U;   /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
  static const uint32_t I2Cx_ISR_BERR_MSK          = 0x00000100U;   /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_ARLO_MSK          = 0x00000200U;   /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_OVR_MSK           = 0x00000400U;   /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_ISR_PECERR_MSK        = 0x00000800U;   /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_ISR_TIMEOUT_MSK       = 0x00001000U;   /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_ISR_ALERT_MSK         = 0x00002000U;   /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_ISR_BUSY_MSK          = 0x00008000U;   /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
  static const uint32_t I2Cx_ISR_DIR_MSK           = 0x00010000U;   /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
  static const uint32_t I2Cx_ISR_ADDCODE_MSK       = 0x00FE0000U;   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
  static const uint32_t I2Cx_ICR_ADDRCF_MSK        = 0x00000008U;   /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
  static const uint32_t I2Cx_ICR_NACKCF_MSK        = 0x00000010U;   /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
  static const uint32_t I2Cx_ICR_STOPCF_MSK        = 0x00000020U;   /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
  static const uint32_t I2Cx_ICR_BERRCF_MSK        = 0x00000100U;   /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
  static const uint32_t I2Cx_ICR_ARLOCF_MSK        = 0x00000200U;   /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
  static const uint32_t I2Cx_ICR_OVRCF_MSK         = 0x00000400U;   /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
  static const uint32_t I2Cx_ICR_PECCF_MSK         = 0x00000800U;   /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_ICR_TIMOUTCF_MSK      = 0x00001000U;   /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_ICR_ALERTCF_MSK       = 0x00002000U;   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const uint32_t I2Cx_PECR_PEC_MSK          = 0x000000FFU;   /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
  static const uint32_t I2Cx_RXDR_RXDATA_MSK       = 0x000000FFU;   /** @brief 8-bit receive data data byte received from the I2C bus. */
  static const uint32_t I2Cx_TXDR_TXDATA_MSK       = 0x000000FFU;   /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

  /**** @subsection I2Cx Register Field Positions ****/

  static const int32_t I2Cx_CRx_PE_POS            = 0;    /** @brief Peripheral enable note: when PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles. */
  static const int32_t I2Cx_CRx_TXIE_POS          = 1;    /** @brief TX interrupt enable */
  static const int32_t I2Cx_CRx_RXIE_POS          = 2;    /** @brief RX interrupt enable */
  static const int32_t I2Cx_CRx_ADDRIE_POS        = 3;    /** @brief Address match interrupt enable (slave only) */
  static const int32_t I2Cx_CRx_NACKIE_POS        = 4;    /** @brief Not acknowledge received interrupt enable */
  static const int32_t I2Cx_CRx_STOPIE_POS        = 5;    /** @brief STOP detection interrupt enable */
  static const int32_t I2Cx_CRx_TCIE_POS          = 6;    /** @brief Transfer complete interrupt enable note: any of these events will generate an interrupt: transfer complete (TC) transfer complete reload (TCR) */
  static const int32_t I2Cx_CRx_ERRIE_POS         = 7;    /** @brief Error interrupts enable note: any of these errors generate an interrupt: arbitration loss (ARLO) bus error detection (BERR) overrun/underrun (OVR) timeout detection (TIMEOUT) PEC error detection (PECERR) alert pin event detection (ALERT) */
  static const int32_t I2Cx_CRx_DNF_POS           = 8;    /** @brief Digital noise filter these bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * ti2cclk ... Note: if the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0). */
  static const int32_t I2Cx_CRx_ANFOFF_POS        = 12;   /** @brief Analog noise filter OFF note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const int32_t I2Cx_CRx_TXDMAEN_POS       = 14;   /** @brief DMA transmission requests enable */
  static const int32_t I2Cx_CRx_RXDMAEN_POS       = 15;   /** @brief DMA reception requests enable */
  static const int32_t I2Cx_CRx_SBC_POS           = 16;   /** @brief Slave byte control this bit is used to enable hardware byte control in slave mode. */
  static const int32_t I2Cx_CRx_NOSTRETCH_POS     = 17;   /** @brief Clock stretching disable this bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: this bit can only be programmed when the I2C is disabled (PE = 0). */
  static const int32_t I2Cx_CRx_WUPEN_POS         = 18;   /** @brief Wakeup from stop mode enable note: if the wakeup from stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000 */
  static const int32_t I2Cx_CRx_GCEN_POS          = 19;   /** @brief General call enable */
  static const int32_t I2Cx_CRx_SMBHEN_POS        = 20;   /** @brief SMBus host address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_CRx_SMBDEN_POS        = 21;   /** @brief SMBus device default address enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_CRx_ALERTEN_POS       = 22;   /** @brief SMBus alert enable device mode (SMBHEN=0): host mode (SMBHEN=1): note: when ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_CRx_PECEN_POS         = 23;   /** @brief PEC enable note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_OARx_OA1_POS          = 0;    /** @brief Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address note: these bits can be written only when OA1EN=0. OA1[7:1]: interface address bits 7:1 of address note: these bits can be written only when OA1EN=0. OA1[0]: interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address note: this bit can be written only when OA1EN=0. */
  static const int32_t I2Cx_OARx_OA1MODE_POS      = 10;   /** @brief Own address 1 10-bit mode note: this bit can be written only when OA1EN=0. */
  static const int32_t I2Cx_OARx_OA1EN_POS        = 15;   /** @brief Own address 1 enable */
  static const int32_t I2Cx_TIMINGR_SCLL_POS      = 0;    /** @brief SCL low period (master mode) this field is used to generate the SCL low period in master mode. TSCLL = (SCLL+1) x tpresc note: SCLL is also used to generate tbuf and tsu:sta timings. */
  static const int32_t I2Cx_TIMINGR_SCLH_POS      = 8;    /** @brief SCL high period (master mode) this field is used to generate the SCL high period in master mode. TSCLH = (SCLH+1) x tpresc note: SCLH is also used to generate tsu:sto and thd:sta timing. */
  static const int32_t I2Cx_TIMINGR_SDADEL_POS    = 16;   /** @brief Data hold time this field is used to generate the delay tsdadel between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tsdadel. TSDADEL= SDADEL x tpresc note: SDADEL is used to generate thd:dat timing. */
  static const int32_t I2Cx_TIMINGR_SCLDEL_POS    = 20;   /** @brief Data setup time this field is used to generate a delay tscldel between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tscldel. TSCLDEL = (SCLDEL+1) x tpresc note: tscldel is used to generate tsu:dat timing. */
  static const int32_t I2Cx_TIMINGR_PRESC_POS     = 28;   /** @brief Timing prescaler this field is used to prescale I2CCLK in order to generate the clock period tpresc used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). TPRESC = (PRESC+1) x ti2cclk */
  static const int32_t I2Cx_TIMEOUTR_TIMEOUTA_POS = 0;    /** @brief Bus timeout A this field is used to configure: the SCL low timeout condition ttimeout when TIDLE=0 ttimeout= (TIMEOUTA+1) x 2048 x ti2cclk the bus idle condition (both SCL and SDA high) when TIDLE=1 tidle= (TIMEOUTA+1) x 4 x ti2cclk note: these bits can be written only when TIMOUTEN=0. */
  static const int32_t I2Cx_TIMEOUTR_TIDLE_POS    = 12;   /** @brief Idle clock timeout detection note: this bit can be written only when TIMOUTEN=0. */
  static const int32_t I2Cx_TIMEOUTR_TIMOUTEN_POS = 15;   /** @brief Clock timeout enable */
  static const int32_t I2Cx_TIMEOUTR_TIMEOUTB_POS = 16;   /** @brief Bus timeout B this field is used to configure the cumulative clock extension timeout: in master mode, the master cumulative clock low extend time (tlow:mext) is detected in slave mode, the slave cumulative clock low extend time (tlow:sext) is detected tlow:ext= (TIMEOUTB+1) x 2048 x ti2cclk note: these bits can be written only when TEXTEN=0. */
  static const int32_t I2Cx_TIMEOUTR_TEXTEN_POS   = 31;   /** @brief Extended clock timeout enable */
  static const int32_t I2Cx_ISR_TXE_POS           = 0;    /** @brief Transmit data register empty (transmitters) this bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: this bit is set by hardware when PE=0. */
  static const int32_t I2Cx_ISR_TXIS_POS          = 1;    /** @brief Transmit interrupt status (transmitters) this bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_RXNE_POS          = 2;    /** @brief Receive data register not empty (receivers) this bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_ADDR_POS          = 3;    /** @brief Address matched (slave mode) this bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_NACKF_POS         = 4;    /** @brief Not acknowledge received flag this flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_STOPF_POS         = 5;    /** @brief Stop detection flag this flag is set by hardware when a stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. Or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_TC_POS            = 6;    /** @brief Transfer complete (master mode) this flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_TCR_POS           = 7;    /** @brief Transfer complete reload this flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: this bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set. */
  static const int32_t I2Cx_ISR_BERR_POS          = 8;    /** @brief Bus error this flag is set by hardware when a misplaced start or stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_ARLO_POS          = 9;    /** @brief Arbitration lost this flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_OVR_POS           = 10;   /** @brief Overrun/Underrun (slave mode) this flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: this bit is cleared by hardware when PE=0. */
  static const int32_t I2Cx_ISR_PECERR_POS        = 11;   /** @brief PEC error in reception this flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_ISR_TIMEOUT_POS       = 12;   /** @brief Timeout or tlow detection flag this flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_ISR_ALERT_POS         = 13;   /** @brief SMBus alert this flag is set by hardware when SMBHEN=1 (smbus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: this bit is cleared by hardware when PE=0. If the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_ISR_BUSY_POS          = 15;   /** @brief Bus busy this flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a stop condition is detected, or when PE=0. */
  static const int32_t I2Cx_ISR_DIR_POS           = 16;   /** @brief Transfer direction (slave mode) this flag is updated when an address match event occurs (ADDR=1). */
  static const int32_t I2Cx_ISR_ADDCODE_POS       = 17;   /** @brief Address match code (slave mode) these bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 msbs of the address. */
  static const int32_t I2Cx_ICR_ADDRCF_POS        = 3;    /** @brief Address matched flag clear writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register. */
  static const int32_t I2Cx_ICR_NACKCF_POS        = 4;    /** @brief Not acknowledge flag clear writing 1 to this bit clears the ACKF flag in I2C_ISR register. */
  static const int32_t I2Cx_ICR_STOPCF_POS        = 5;    /** @brief Stop detection flag clear writing 1 to this bit clears the STOPF flag in the I2C_ISR register. */
  static const int32_t I2Cx_ICR_BERRCF_POS        = 8;    /** @brief Bus error flag clear writing 1 to this bit clears the BERRF flag in the I2C_ISR register. */
  static const int32_t I2Cx_ICR_ARLOCF_POS        = 9;    /** @brief Arbitration lost flag clear writing 1 to this bit clears the ARLO flag in the I2C_ISR register. */
  static const int32_t I2Cx_ICR_OVRCF_POS         = 10;   /** @brief Overrun/Underrun flag clear writing 1 to this bit clears the OVR flag in the I2C_ISR register. */
  static const int32_t I2Cx_ICR_PECCF_POS         = 11;   /** @brief PEC error flag clear writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_ICR_TIMOUTCF_POS      = 12;   /** @brief Timeout detection flag clear writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_ICR_ALERTCF_POS       = 13;   /** @brief Alert flag clear writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: if the smbus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to section25.3: I2C implementation. */
  static const int32_t I2Cx_PECR_PEC_POS          = 0;    /** @brief Packet error checking register this field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0. */
  static const int32_t I2Cx_RXDR_RXDATA_POS       = 0;    /** @brief 8-bit receive data data byte received from the I2C bus. */
  static const int32_t I2Cx_TXDR_TXDATA_POS       = 0;    /** @brief 8-bit transmit data data byte to be transmitted to the I2C bus. Note: these bits can be written only when TXE=1. */

  /**********************************************************************************************
   * @section GPIOx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated GPIOx Register Pointers ****/

  static RW_ uint32_t* const GPIOx_MODER_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020000U,   /** @brief GPIO port mode register */
    [1]  = (RW_ uint32_t* const)0x58020400U,   /** @brief GPIO port mode register */
    [2]  = (RW_ uint32_t* const)0x58020800U,   /** @brief GPIO port mode register */
    [3]  = (RW_ uint32_t* const)0x58020C00U,   /** @brief GPIO port mode register */
    [4]  = (RW_ uint32_t* const)0x58021000U,   /** @brief GPIO port mode register */
    [5]  = (RW_ uint32_t* const)0x58021400U,   /** @brief GPIO port mode register */
    [6]  = (RW_ uint32_t* const)0x58021800U,   /** @brief GPIO port mode register */
    [7]  = (RW_ uint32_t* const)0x58021C00U,   /** @brief GPIO port mode register */
    [8]  = (RW_ uint32_t* const)0x58022000U,   /** @brief GPIO port mode register */
    [9]  = (RW_ uint32_t* const)0x58022400U,   /** @brief GPIO port mode register */
    [10] = (RW_ uint32_t* const)0x58022800U,   /** @brief GPIO port mode register */
  };

  static RW_ uint32_t* const GPIOx_OTYPER_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020004U,   /** @brief GPIO port output type register */
    [1]  = (RW_ uint32_t* const)0x58020404U,   /** @brief GPIO port output type register */
    [2]  = (RW_ uint32_t* const)0x58020804U,   /** @brief GPIO port output type register */
    [3]  = (RW_ uint32_t* const)0x58020C04U,   /** @brief GPIO port output type register */
    [4]  = (RW_ uint32_t* const)0x58021004U,   /** @brief GPIO port output type register */
    [5]  = (RW_ uint32_t* const)0x58021404U,   /** @brief GPIO port output type register */
    [6]  = (RW_ uint32_t* const)0x58021804U,   /** @brief GPIO port output type register */
    [7]  = (RW_ uint32_t* const)0x58021C04U,   /** @brief GPIO port output type register */
    [8]  = (RW_ uint32_t* const)0x58022004U,   /** @brief GPIO port output type register */
    [9]  = (RW_ uint32_t* const)0x58022404U,   /** @brief GPIO port output type register */
    [10] = (RW_ uint32_t* const)0x58022804U,   /** @brief GPIO port output type register */
  };

  static RW_ uint32_t* const GPIOx_OSPEEDR_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020008U,   /** @brief GPIO port output speed register */
    [1]  = (RW_ uint32_t* const)0x58020408U,   /** @brief GPIO port output speed register */
    [2]  = (RW_ uint32_t* const)0x58020808U,   /** @brief GPIO port output speed register */
    [3]  = (RW_ uint32_t* const)0x58020C08U,   /** @brief GPIO port output speed register */
    [4]  = (RW_ uint32_t* const)0x58021008U,   /** @brief GPIO port output speed register */
    [5]  = (RW_ uint32_t* const)0x58021408U,   /** @brief GPIO port output speed register */
    [6]  = (RW_ uint32_t* const)0x58021808U,   /** @brief GPIO port output speed register */
    [7]  = (RW_ uint32_t* const)0x58021C08U,   /** @brief GPIO port output speed register */
    [8]  = (RW_ uint32_t* const)0x58022008U,   /** @brief GPIO port output speed register */
    [9]  = (RW_ uint32_t* const)0x58022408U,   /** @brief GPIO port output speed register */
    [10] = (RW_ uint32_t* const)0x58022808U,   /** @brief GPIO port output speed register */
  };

  static RW_ uint32_t* const GPIOx_PUPDR_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x5802000CU,   /** @brief GPIO port pull-up/pull-down register */
    [1]  = (RW_ uint32_t* const)0x5802040CU,   /** @brief GPIO port pull-up/pull-down register */
    [2]  = (RW_ uint32_t* const)0x5802080CU,   /** @brief GPIO port pull-up/pull-down register */
    [3]  = (RW_ uint32_t* const)0x58020C0CU,   /** @brief GPIO port pull-up/pull-down register */
    [4]  = (RW_ uint32_t* const)0x5802100CU,   /** @brief GPIO port pull-up/pull-down register */
    [5]  = (RW_ uint32_t* const)0x5802140CU,   /** @brief GPIO port pull-up/pull-down register */
    [6]  = (RW_ uint32_t* const)0x5802180CU,   /** @brief GPIO port pull-up/pull-down register */
    [7]  = (RW_ uint32_t* const)0x58021C0CU,   /** @brief GPIO port pull-up/pull-down register */
    [8]  = (RW_ uint32_t* const)0x5802200CU,   /** @brief GPIO port pull-up/pull-down register */
    [9]  = (RW_ uint32_t* const)0x5802240CU,   /** @brief GPIO port pull-up/pull-down register */
    [10] = (RW_ uint32_t* const)0x5802280CU,   /** @brief GPIO port pull-up/pull-down register */
  };

  static RO_ uint32_t* const GPIOx_IDR_PTR[11] = {
    [0]  = (RO_ uint32_t* const)0x58020010U,   /** @brief GPIO port input data register */
    [1]  = (RO_ uint32_t* const)0x58020410U,   /** @brief GPIO port input data register */
    [2]  = (RO_ uint32_t* const)0x58020810U,   /** @brief GPIO port input data register */
    [3]  = (RO_ uint32_t* const)0x58020C10U,   /** @brief GPIO port input data register */
    [4]  = (RO_ uint32_t* const)0x58021010U,   /** @brief GPIO port input data register */
    [5]  = (RO_ uint32_t* const)0x58021410U,   /** @brief GPIO port input data register */
    [6]  = (RO_ uint32_t* const)0x58021810U,   /** @brief GPIO port input data register */
    [7]  = (RO_ uint32_t* const)0x58021C10U,   /** @brief GPIO port input data register */
    [8]  = (RO_ uint32_t* const)0x58022010U,   /** @brief GPIO port input data register */
    [9]  = (RO_ uint32_t* const)0x58022410U,   /** @brief GPIO port input data register */
    [10] = (RO_ uint32_t* const)0x58022810U,   /** @brief GPIO port input data register */
  };

  static RW_ uint32_t* const GPIOx_ODR_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020014U,   /** @brief GPIO port output data register */
    [1]  = (RW_ uint32_t* const)0x58020414U,   /** @brief GPIO port output data register */
    [2]  = (RW_ uint32_t* const)0x58020814U,   /** @brief GPIO port output data register */
    [3]  = (RW_ uint32_t* const)0x58020C14U,   /** @brief GPIO port output data register */
    [4]  = (RW_ uint32_t* const)0x58021014U,   /** @brief GPIO port output data register */
    [5]  = (RW_ uint32_t* const)0x58021414U,   /** @brief GPIO port output data register */
    [6]  = (RW_ uint32_t* const)0x58021814U,   /** @brief GPIO port output data register */
    [7]  = (RW_ uint32_t* const)0x58021C14U,   /** @brief GPIO port output data register */
    [8]  = (RW_ uint32_t* const)0x58022014U,   /** @brief GPIO port output data register */
    [9]  = (RW_ uint32_t* const)0x58022414U,   /** @brief GPIO port output data register */
    [10] = (RW_ uint32_t* const)0x58022814U,   /** @brief GPIO port output data register */
  };

  static WO_ uint32_t* const GPIOx_BSRR_PTR[11] = {
    [0]  = (WO_ uint32_t* const)0x58020018U,   /** @brief GPIO port bit set/reset register */
    [1]  = (WO_ uint32_t* const)0x58020418U,   /** @brief GPIO port bit set/reset register */
    [2]  = (WO_ uint32_t* const)0x58020818U,   /** @brief GPIO port bit set/reset register */
    [3]  = (WO_ uint32_t* const)0x58020C18U,   /** @brief GPIO port bit set/reset register */
    [4]  = (WO_ uint32_t* const)0x58021018U,   /** @brief GPIO port bit set/reset register */
    [5]  = (WO_ uint32_t* const)0x58021418U,   /** @brief GPIO port bit set/reset register */
    [6]  = (WO_ uint32_t* const)0x58021818U,   /** @brief GPIO port bit set/reset register */
    [7]  = (WO_ uint32_t* const)0x58021C18U,   /** @brief GPIO port bit set/reset register */
    [8]  = (WO_ uint32_t* const)0x58022018U,   /** @brief GPIO port bit set/reset register */
    [9]  = (WO_ uint32_t* const)0x58022418U,   /** @brief GPIO port bit set/reset register */
    [10] = (WO_ uint32_t* const)0x58022818U,   /** @brief GPIO port bit set/reset register */
  };

  static RW_ uint32_t* const GPIOx_LCKR_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x5802001CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [1]  = (RW_ uint32_t* const)0x5802041CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [2]  = (RW_ uint32_t* const)0x5802081CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [3]  = (RW_ uint32_t* const)0x58020C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [4]  = (RW_ uint32_t* const)0x5802101CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [5]  = (RW_ uint32_t* const)0x5802141CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [6]  = (RW_ uint32_t* const)0x5802181CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [7]  = (RW_ uint32_t* const)0x58021C1CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [8]  = (RW_ uint32_t* const)0x5802201CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [9]  = (RW_ uint32_t* const)0x5802241CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
    [10] = (RW_ uint32_t* const)0x5802281CU,   /** @brief This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.a specific write sequence is used to write to the gpiox_lckr register. Only word access (32-bit long) is allowed during this locking sequence.each lock bit freezes a specific configuration register (control and alternate function registers). */
  };

  static RW_ uint32_t* const GPIOx_AFRL_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020020U,   /** @brief GPIO alternate function low register */
    [1]  = (RW_ uint32_t* const)0x58020420U,   /** @brief GPIO alternate function low register */
    [2]  = (RW_ uint32_t* const)0x58020820U,   /** @brief GPIO alternate function low register */
    [3]  = (RW_ uint32_t* const)0x58020C20U,   /** @brief GPIO alternate function low register */
    [4]  = (RW_ uint32_t* const)0x58021020U,   /** @brief GPIO alternate function low register */
    [5]  = (RW_ uint32_t* const)0x58021420U,   /** @brief GPIO alternate function low register */
    [6]  = (RW_ uint32_t* const)0x58021820U,   /** @brief GPIO alternate function low register */
    [7]  = (RW_ uint32_t* const)0x58021C20U,   /** @brief GPIO alternate function low register */
    [8]  = (RW_ uint32_t* const)0x58022020U,   /** @brief GPIO alternate function low register */
    [9]  = (RW_ uint32_t* const)0x58022420U,   /** @brief GPIO alternate function low register */
    [10] = (RW_ uint32_t* const)0x58022820U,   /** @brief GPIO alternate function low register */
  };

  static RW_ uint32_t* const GPIOx_AFRH_PTR[11] = {
    [0]  = (RW_ uint32_t* const)0x58020024U,   /** @brief GPIO alternate function high register */
    [1]  = (RW_ uint32_t* const)0x58020424U,   /** @brief GPIO alternate function high register */
    [2]  = (RW_ uint32_t* const)0x58020824U,   /** @brief GPIO alternate function high register */
    [3]  = (RW_ uint32_t* const)0x58020C24U,   /** @brief GPIO alternate function high register */
    [4]  = (RW_ uint32_t* const)0x58021024U,   /** @brief GPIO alternate function high register */
    [5]  = (RW_ uint32_t* const)0x58021424U,   /** @brief GPIO alternate function high register */
    [6]  = (RW_ uint32_t* const)0x58021824U,   /** @brief GPIO alternate function high register */
    [7]  = (RW_ uint32_t* const)0x58021C24U,   /** @brief GPIO alternate function high register */
    [8]  = (RW_ uint32_t* const)0x58022024U,   /** @brief GPIO alternate function high register */
    [9]  = (RW_ uint32_t* const)0x58022424U,   /** @brief GPIO alternate function high register */
    [10] = (RW_ uint32_t* const)0x58022824U,   /** @brief GPIO alternate function high register */
  };

  /**** @subsection GPIOx Register Field Masks ****/

  static const uint32_t GPIOx_LCKR_LCKK_MSK = 0x00010000U;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

  /**** @subsection Enumerated GPIOx Register Field Masks ****/

  static const uint32_t GPIOx_MODER_MODEx_MSK[16] = {
    [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
  };

  static const uint32_t GPIOx_OTYPER_OTx_MSK[16] = {
    [0]  = 0x00000001U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [1]  = 0x00000002U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [2]  = 0x00000004U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [3]  = 0x00000008U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [4]  = 0x00000010U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [5]  = 0x00000020U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [6]  = 0x00000040U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [7]  = 0x00000080U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [8]  = 0x00000100U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [9]  = 0x00000200U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [10] = 0x00000400U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [11] = 0x00000800U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [12] = 0x00001000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [13] = 0x00002000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [14] = 0x00004000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [15] = 0x00008000U,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
  };

  static const uint32_t GPIOx_OSPEEDR_OSPEEDx_MSK[16] = {
    [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
  };

  static const uint32_t GPIOx_PUPDR_PUPDx_MSK[16] = {
    [0]  = 0x00000003U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [1]  = 0x0000000CU,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [2]  = 0x00000030U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [3]  = 0x000000C0U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [4]  = 0x00000300U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [5]  = 0x00000C00U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [6]  = 0x00003000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [7]  = 0x0000C000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [8]  = 0x00030000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [9]  = 0x000C0000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [10] = 0x00300000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [11] = 0x00C00000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [12] = 0x03000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [13] = 0x0C000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [14] = 0x30000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [15] = 0xC0000000U,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
  };

  static const uint32_t GPIOx_IDR_IDx_MSK[16] = {
    [0]  = 0x00000001U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [1]  = 0x00000002U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [2]  = 0x00000004U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [3]  = 0x00000008U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [4]  = 0x00000010U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [5]  = 0x00000020U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [6]  = 0x00000040U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [7]  = 0x00000080U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [8]  = 0x00000100U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [9]  = 0x00000200U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [10] = 0x00000400U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [11] = 0x00000800U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [12] = 0x00001000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [13] = 0x00002000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [14] = 0x00004000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [15] = 0x00008000U,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
  };

  static const uint32_t GPIOx_ODR_ODx_MSK[16] = {
    [0]  = 0x00000001U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [1]  = 0x00000002U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [2]  = 0x00000004U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [3]  = 0x00000008U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [4]  = 0x00000010U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [5]  = 0x00000020U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [6]  = 0x00000040U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [7]  = 0x00000080U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [8]  = 0x00000100U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [9]  = 0x00000200U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [10] = 0x00000400U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [11] = 0x00000800U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [12] = 0x00001000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [13] = 0x00002000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [14] = 0x00004000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [15] = 0x00008000U,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
  };

  static const uint32_t GPIOx_BSRR_BSx_MSK[16] = {
    [0]  = 0x00000001U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [1]  = 0x00000002U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [2]  = 0x00000004U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [3]  = 0x00000008U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [4]  = 0x00000010U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [5]  = 0x00000020U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [6]  = 0x00000040U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [7]  = 0x00000080U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [8]  = 0x00000100U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [9]  = 0x00000200U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [10] = 0x00000400U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [11] = 0x00000800U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [12] = 0x00001000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [13] = 0x00002000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [14] = 0x00004000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [15] = 0x00008000U,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
  };

  static const uint32_t GPIOx_BSRR_BRx_MSK[16] = {
    [0]  = 0x00010000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [1]  = 0x00020000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [2]  = 0x00040000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [3]  = 0x00080000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [4]  = 0x00100000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [5]  = 0x00200000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [6]  = 0x00400000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [7]  = 0x00800000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [8]  = 0x01000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [9]  = 0x02000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [10] = 0x04000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [11] = 0x08000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [12] = 0x10000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [13] = 0x20000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [14] = 0x40000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [15] = 0x80000000U,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
  };

  static const uint32_t GPIOx_LCKR_LCKx_MSK[16] = {
    [0]  = 0x00000001U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [1]  = 0x00000002U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [2]  = 0x00000004U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [3]  = 0x00000008U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [4]  = 0x00000010U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [5]  = 0x00000020U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [6]  = 0x00000040U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [7]  = 0x00000080U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [8]  = 0x00000100U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [9]  = 0x00000200U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [10] = 0x00000400U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [11] = 0x00000800U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [12] = 0x00001000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [13] = 0x00002000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [14] = 0x00004000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [15] = 0x00008000U,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
  };

  static const uint32_t GPIOx_AFRL_AFSELx_MSK[8] = {
    [0] = 0x0000000FU,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [1] = 0x000000F0U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [2] = 0x00000F00U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [3] = 0x0000F000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [4] = 0x000F0000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [5] = 0x00F00000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [6] = 0x0F000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [7] = 0xF0000000U,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
  };

  /**** @subsection GPIOx Register Field Positions ****/

  static const int32_t GPIOx_LCKR_LCKK_POS = 16;   /** @brief Lock key this bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) note: during the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset. */

  /**** @subsection Enumerated GPIOx Register Field Positions ****/

  static const int32_t GPIOx_MODER_MODEx_POS[16] = {
    [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
    [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O mode. */
  };

  static const int32_t GPIOx_OTYPER_OTx_POS[16] = {
    [0]  = 0,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [1]  = 1,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [2]  = 2,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [3]  = 3,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [4]  = 4,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [5]  = 5,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [6]  = 6,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [7]  = 7,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [8]  = 8,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [9]  = 9,    /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [10] = 10,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [11] = 11,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [12] = 12,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [13] = 13,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [14] = 14,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
    [15] = 15,   /** @brief Port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output type. */
  };

  static const int32_t GPIOx_OSPEEDR_OSPEEDx_POS[16] = {
    [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
    [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O output speed. Note: refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed. */
  };

  static const int32_t GPIOx_PUPDR_PUPDx_POS[16] = {
    [0]  = 0,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [1]  = 2,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [2]  = 4,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [3]  = 6,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [4]  = 8,    /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [5]  = 10,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [6]  = 12,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [7]  = 14,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [8]  = 16,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [9]  = 18,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [10] = 20,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [11] = 22,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [12] = 24,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [13] = 26,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [14] = 28,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
    [15] = 30,   /** @brief [1:0]: port x configuration bits (y = 0..15) these bits are written by software to configure the I/O pull-up or pull-down */
  };

  static const int32_t GPIOx_IDR_IDx_POS[16] = {
    [0]  = 0,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [1]  = 1,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [2]  = 2,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [3]  = 3,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [4]  = 4,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [5]  = 5,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [6]  = 6,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [7]  = 7,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [8]  = 8,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [9]  = 9,    /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [10] = 10,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [11] = 11,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [12] = 12,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [13] = 13,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [14] = 14,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
    [15] = 15,   /** @brief Port input data bit (y = 0..15) these bits are read-only. They contain the input value of the corresponding I/O port. */
  };

  static const int32_t GPIOx_ODR_ODx_POS[16] = {
    [0]  = 0,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [1]  = 1,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [2]  = 2,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [3]  = 3,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [4]  = 4,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [5]  = 5,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [6]  = 6,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [7]  = 7,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [8]  = 8,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [9]  = 9,    /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [10] = 10,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [11] = 11,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [12] = 12,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [13] = 13,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [14] = 14,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
    [15] = 15,   /** @brief Port output data bit these bits can be read and written by software. Note: for atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the gpiox_bsrr or gpiox_brr registers (x = A..F). */
  };

  static const int32_t GPIOx_BSRR_BSx_POS[16] = {
    [0]  = 0,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [1]  = 1,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [2]  = 2,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [3]  = 3,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [4]  = 4,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [5]  = 5,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [6]  = 6,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [7]  = 7,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [8]  = 8,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [9]  = 9,    /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [10] = 10,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [11] = 11,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [12] = 12,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [13] = 13,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [14] = 14,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
    [15] = 15,   /** @brief Port x set bit y (y= 0..15) these bits are write-only. A read to these bits returns the value 0x0000. */
  };

  static const int32_t GPIOx_BSRR_BRx_POS[16] = {
    [0]  = 16,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [1]  = 17,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [2]  = 18,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [3]  = 19,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [4]  = 20,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [5]  = 21,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [6]  = 22,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [7]  = 23,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [8]  = 24,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [9]  = 25,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [10] = 26,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [11] = 27,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [12] = 28,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [13] = 29,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [14] = 30,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
    [15] = 31,   /** @brief Port x reset bit y (y = 0..15) these bits are write-only. A read to these bits returns the value 0x0000. Note: if both bsx and brx are set, bsx has priority. */
  };

  static const int32_t GPIOx_LCKR_LCKx_POS[16] = {
    [0]  = 0,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [1]  = 1,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [2]  = 2,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [3]  = 3,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [4]  = 4,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [5]  = 5,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [6]  = 6,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [7]  = 7,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [8]  = 8,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [9]  = 9,    /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [10] = 10,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [11] = 11,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [12] = 12,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [13] = 13,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [14] = 14,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
    [15] = 15,   /** @brief Port x lock bit y (y= 0..15) these bits are read/write but can only be written when the LCKK bit is 0. */
  };

  static const int32_t GPIOx_AFRL_AFSELx_POS[8] = {
    [0] = 0,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [1] = 4,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [2] = 8,    /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [3] = 12,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [4] = 16,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [5] = 20,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [6] = 24,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
    [7] = 28,   /** @brief [3:0]: alternate function selection for port x pin y (y = 0..7) these bits are written by software to configure alternate function i/os afsely selection: */
  };

  /**********************************************************************************************
   * @section JPEG Register Information
   **********************************************************************************************/

  /**** @subsection JPEG Register Pointers ****/

  static RW_ uint32_t* const JPEG_CR_PTR  = (RW_ uint32_t* const)0x52003030U;   /** @brief JPEG control register */
  static RO_ uint32_t* const JPEG_SR_PTR  = (RO_ uint32_t* const)0x52003034U;   /** @brief JPEG status register */
  static RW_ uint32_t* const JPEG_CFR_PTR = (RW_ uint32_t* const)0x52003038U;   /** @brief JPEG clear flag register */
  static WO_ uint32_t* const JPEG_DIR_PTR = (WO_ uint32_t* const)0x52003040U;   /** @brief JPEG data input register */
  static RO_ uint32_t* const JPEG_DOR_PTR = (RO_ uint32_t* const)0x52003044U;   /** @brief JPEG data output register */

  /**** @subsection Enumerated JPEG Register Pointers ****/

  static WO_ uint32_t* const JPEG_CONFRx_PTR[4] = {
    [0] = (WO_ uint32_t* const)0x52003000U,   /** @brief JPEG codec control register */
    [1] = (WO_ uint32_t* const)0x52003004U,   /** @brief JPEG codec configuration register 1 */
    [2] = (WO_ uint32_t* const)0x52003008U,   /** @brief JPEG codec configuration register 2 */
    [3] = (WO_ uint32_t* const)0x5200300CU,   /** @brief JPEG codec configuration register 3 */
  };

  static RW_ uint32_t* const JPEG_CONFRNx_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x52003010U,   /** @brief JPEG codec configuration register 4-7 */
    [2] = (RW_ uint32_t* const)0x52003014U,   /** @brief JPEG codec configuration register 4-7 */
    [3] = (RW_ uint32_t* const)0x52003018U,   /** @brief JPEG codec configuration register 4-7 */
    [4] = (RW_ uint32_t* const)0x5200301CU,   /** @brief JPEG codec configuration register 4-7 */
  };

  /**** @subsection JPEG Register Field Masks ****/

  static const uint32_t JPEG_CONFRx_START_MSK = 0x00000001U;   /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
  static const uint32_t JPEG_CONFRNx_HD_MSK   = 0x00000001U;   /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
  static const uint32_t JPEG_CONFRNx_HA_MSK   = 0x00000002U;   /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
  static const uint32_t JPEG_CONFRNx_QT_MSK   = 0x0000000CU;   /** @brief Quantization table selects quantization table associated with a color component. */
  static const uint32_t JPEG_CONFRNx_NB_MSK   = 0x000000F0U;   /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
  static const uint32_t JPEG_CONFRNx_VSF_MSK  = 0x00000F00U;   /** @brief Vertical sampling factor vertical sampling factor for component i. */
  static const uint32_t JPEG_CONFRNx_HSF_MSK  = 0x0000F000U;   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
  static const uint32_t JPEG_CR_JCEN_MSK      = 0x00000001U;   /** @brief JPEG core enable enable the JPEG codec core. */
  static const uint32_t JPEG_CR_IFTIE_MSK     = 0x00000002U;   /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
  static const uint32_t JPEG_CR_IFNFIE_MSK    = 0x00000004U;   /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
  static const uint32_t JPEG_CR_OFTIE_MSK     = 0x00000008U;   /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
  static const uint32_t JPEG_CR_OFNEIE_MSK    = 0x00000010U;   /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
  static const uint32_t JPEG_CR_EOCIE_MSK     = 0x00000020U;   /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
  static const uint32_t JPEG_CR_HPDIE_MSK     = 0x00000040U;   /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
  static const uint32_t JPEG_CR_IDMAEN_MSK    = 0x00000800U;   /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
  static const uint32_t JPEG_CR_ODMAEN_MSK    = 0x00001000U;   /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
  static const uint32_t JPEG_CR_IFF_MSK       = 0x00002000U;   /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
  static const uint32_t JPEG_CR_OFF_MSK       = 0x00004000U;   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
  static const uint32_t JPEG_SR_IFTF_MSK      = 0x00000002U;   /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
  static const uint32_t JPEG_SR_IFNFF_MSK     = 0x00000004U;   /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
  static const uint32_t JPEG_SR_OFTF_MSK      = 0x00000008U;   /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
  static const uint32_t JPEG_SR_OFNEF_MSK     = 0x00000010U;   /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
  static const uint32_t JPEG_SR_EOCF_MSK      = 0x00000020U;   /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
  static const uint32_t JPEG_SR_HPDF_MSK      = 0x00000040U;   /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
  static const uint32_t JPEG_SR_COF_MSK       = 0x00000080U;   /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
  static const uint32_t JPEG_CFR_CEOCF_MSK    = 0x00000020U;   /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
  static const uint32_t JPEG_CFR_CHPDF_MSK    = 0x00000040U;   /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

  /**** @subsection JPEG Register Field Positions ****/

  static const int32_t JPEG_CONFRx_START_POS = 0;    /** @brief Start this bit start or stop the encoding or decoding process. Read this register always return 0. */
  static const int32_t JPEG_CONFRNx_HD_POS   = 0;    /** @brief Huffman DC selects the huffman table for encoding the DC coefficients. */
  static const int32_t JPEG_CONFRNx_HA_POS   = 1;    /** @brief Huffman AC selects the huffman table for encoding the AC coefficients. */
  static const int32_t JPEG_CONFRNx_QT_POS   = 2;    /** @brief Quantization table selects quantization table associated with a color component. */
  static const int32_t JPEG_CONFRNx_NB_POS   = 4;    /** @brief Number of block number of data units minus 1 that belong to a particular color in the MCU. */
  static const int32_t JPEG_CONFRNx_VSF_POS  = 8;    /** @brief Vertical sampling factor vertical sampling factor for component i. */
  static const int32_t JPEG_CONFRNx_HSF_POS  = 12;   /** @brief Horizontal sampling factor horizontal sampling factor for component i. */
  static const int32_t JPEG_CR_JCEN_POS      = 0;    /** @brief JPEG core enable enable the JPEG codec core. */
  static const int32_t JPEG_CR_IFTIE_POS     = 1;    /** @brief Input FIFO threshold interrupt enable this bit enables the interrupt generation when input FIFO reach the threshold. */
  static const int32_t JPEG_CR_IFNFIE_POS    = 2;    /** @brief Input FIFO not full interrupt enable this bit enables the interrupt generation when input FIFO is not empty. */
  static const int32_t JPEG_CR_OFTIE_POS     = 3;    /** @brief Output FIFO threshold interrupt enable this bit enables the interrupt generation when output FIFO reach the threshold. */
  static const int32_t JPEG_CR_OFNEIE_POS    = 4;    /** @brief Output FIFO not empty interrupt enable this bit enables the interrupt generation when output FIFO is not empty. */
  static const int32_t JPEG_CR_EOCIE_POS     = 5;    /** @brief End of conversion interrupt enable this bit enables the interrupt generation on the end of conversion. */
  static const int32_t JPEG_CR_HPDIE_POS     = 6;    /** @brief Header parsing done interrupt enable this bit enables the interrupt generation on the header parsing operation. */
  static const int32_t JPEG_CR_IDMAEN_POS    = 11;   /** @brief Input DMA enable enable the DMA request generation for the input FIFO. */
  static const int32_t JPEG_CR_ODMAEN_POS    = 12;   /** @brief Output DMA enable enable the DMA request generation for the output FIFO. */
  static const int32_t JPEG_CR_IFF_POS       = 13;   /** @brief Input FIFO flush this bit flush the input FIFO. This bit is always read as 0. */
  static const int32_t JPEG_CR_OFF_POS       = 14;   /** @brief Output FIFO flush this bit flush the output FIFO. This bit is always read as 0. */
  static const int32_t JPEG_SR_IFTF_POS      = 1;    /** @brief Input FIFO threshold flag this bit is set when the input FIFO is not full and is bellow its threshold. */
  static const int32_t JPEG_SR_IFNFF_POS     = 2;    /** @brief Input FIFO not full flag this bit is set when the input FIFO is not full (a data can be written). */
  static const int32_t JPEG_SR_OFTF_POS      = 3;    /** @brief Output FIFO threshold flag this bit is set when the output FIFO is not empty and has reach its threshold. */
  static const int32_t JPEG_SR_OFNEF_POS     = 4;    /** @brief Output FIFO not empty flag this bit is set when the output FIFO is not empty (a data is available). */
  static const int32_t JPEG_SR_EOCF_POS      = 5;    /** @brief End of conversion flag this bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO. */
  static const int32_t JPEG_SR_HPDF_POS      = 6;    /** @brief Header parsing done flag this bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated. */
  static const int32_t JPEG_SR_COF_POS       = 7;    /** @brief Codec operation flag this bit is set when when a JPEG codec operation is on going (encoding or decoding). */
  static const int32_t JPEG_CFR_CEOCF_POS    = 5;    /** @brief Clear end of conversion flag writing 1 clears the end of conversion flag of the JPEG status register. */
  static const int32_t JPEG_CFR_CHPDF_POS    = 6;    /** @brief Clear header parsing done flag writing 1 clears the header parsing done flag of the JPEG status register. */

  /**********************************************************************************************
   * @section QUADSPI Register Information
   **********************************************************************************************/

  /**** @subsection QUADSPI Register Pointers ****/

  static RW_ uint32_t* const QUADSPI_CR_PTR    = (RW_ uint32_t* const)0x52005000U;   /** @brief QUADSPI control register */
  static RW_ uint32_t* const QUADSPI_DCR_PTR   = (RW_ uint32_t* const)0x52005004U;   /** @brief QUADSPI device configuration register */
  static RO_ uint32_t* const QUADSPI_SR_PTR    = (RO_ uint32_t* const)0x52005008U;   /** @brief QUADSPI status register */
  static RW_ uint32_t* const QUADSPI_FCR_PTR   = (RW_ uint32_t* const)0x5200500CU;   /** @brief QUADSPI flag clear register */
  static RW_ uint32_t* const QUADSPI_DLR_PTR   = (RW_ uint32_t* const)0x52005010U;   /** @brief QUADSPI data length register */
  static RW_ uint32_t* const QUADSPI_CCR_PTR   = (RW_ uint32_t* const)0x52005014U;   /** @brief QUADSPI communication configuration register */
  static RW_ uint32_t* const QUADSPI_AR_PTR    = (RW_ uint32_t* const)0x52005018U;   /** @brief QUADSPI address register */
  static RW_ uint32_t* const QUADSPI_ABR_PTR   = (RW_ uint32_t* const)0x5200501CU;   /** @brief QUADSPI alternate bytes registers */
  static RW_ uint32_t* const QUADSPI_DR_PTR    = (RW_ uint32_t* const)0x52005020U;   /** @brief QUADSPI data register */
  static RW_ uint32_t* const QUADSPI_PSMKR_PTR = (RW_ uint32_t* const)0x52005024U;   /** @brief QUADSPI polling status mask register */
  static RW_ uint32_t* const QUADSPI_PSMAR_PTR = (RW_ uint32_t* const)0x52005028U;   /** @brief QUADSPI polling status match register */
  static RW_ uint32_t* const QUADSPI_PIR_PTR   = (RW_ uint32_t* const)0x5200502CU;   /** @brief QUADSPI polling interval register */
  static RW_ uint32_t* const QUADSPI_LPTR_PTR  = (RW_ uint32_t* const)0x52005030U;   /** @brief QUADSPI low-power timeout register */

  /**** @subsection QUADSPI Register Field Masks ****/

  static const uint32_t QUADSPI_CR_EN_MSK           = 0x00000001U;   /** @brief Enable enable the QUADSPI. */
  static const uint32_t QUADSPI_CR_ABORT_MSK        = 0x00000002U;   /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
  static const uint32_t QUADSPI_CR_DMAEN_MSK        = 0x00000004U;   /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
  static const uint32_t QUADSPI_CR_TCEN_MSK         = 0x00000008U;   /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_CR_SSHIFT_MSK       = 0x00000010U;   /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_CR_DFM_MSK          = 0x00000040U;   /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_CR_FSEL_MSK         = 0x00000080U;   /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
  static const uint32_t QUADSPI_CR_FTHRES_MSK       = 0x00001F00U;   /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
  static const uint32_t QUADSPI_CR_TEIE_MSK         = 0x00010000U;   /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
  static const uint32_t QUADSPI_CR_TCIE_MSK         = 0x00020000U;   /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
  static const uint32_t QUADSPI_CR_FTIE_MSK         = 0x00040000U;   /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
  static const uint32_t QUADSPI_CR_SMIE_MSK         = 0x00080000U;   /** @brief Status match interrupt enable this bit enables the status match interrupt. */
  static const uint32_t QUADSPI_CR_TOIE_MSK         = 0x00100000U;   /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
  static const uint32_t QUADSPI_CR_APMS_MSK         = 0x00400000U;   /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_CR_PMM_MSK          = 0x00800000U;   /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_CR_PRESCALER_MSK    = 0xFF000000U;   /** @brief Clock prescaler */
  static const uint32_t QUADSPI_DCR_CKMODE_MSK      = 0x00000001U;   /** @brief Indicates the level that clk takes between command */
  static const uint32_t QUADSPI_DCR_CSHT_MSK        = 0x00000700U;   /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_DCR_FSIZE_MSK       = 0x001F0000U;   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
  static const uint32_t QUADSPI_SR_TEF_MSK          = 0x00000001U;   /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
  static const uint32_t QUADSPI_SR_TCF_MSK          = 0x00000002U;   /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
  static const uint32_t QUADSPI_SR_FTF_MSK          = 0x00000004U;   /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
  static const uint32_t QUADSPI_SR_SMF_MSK          = 0x00000008U;   /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
  static const uint32_t QUADSPI_SR_TOF_MSK          = 0x00000010U;   /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
  static const uint32_t QUADSPI_SR_BUSY_MSK         = 0x00000020U;   /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
  static const uint32_t QUADSPI_SR_FLEVEL_MSK       = 0x00003F00U;   /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
  static const uint32_t QUADSPI_FCR_CTEF_MSK        = 0x00000001U;   /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
  static const uint32_t QUADSPI_FCR_CTCF_MSK        = 0x00000002U;   /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
  static const uint32_t QUADSPI_FCR_CSMF_MSK        = 0x00000008U;   /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
  static const uint32_t QUADSPI_FCR_CTOF_MSK        = 0x00000010U;   /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
  static const uint32_t QUADSPI_CCR_INSTRUCTION_MSK = 0x000000FFU;   /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_IMODE_MSK       = 0x00000300U;   /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_ADMODE_MSK      = 0x00000C00U;   /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_ADSIZE_MSK      = 0x00003000U;   /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_ABMODE_MSK      = 0x0000C000U;   /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_ABSIZE_MSK      = 0x00030000U;   /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_DCYC_MSK        = 0x007C0000U;   /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_DMODE_MSK       = 0x03000000U;   /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_FMODE_MSK       = 0x0C000000U;   /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_SIOO_MSK        = 0x10000000U;   /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_DHHC_MSK        = 0x40000000U;   /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_CCR_DDRM_MSK        = 0x80000000U;   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_PIR_INTERVAL_MSK    = 0x0000FFFFU;   /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
  static const uint32_t QUADSPI_LPTR_TIMEOUT_MSK    = 0x0000FFFFU;   /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

  /**** @subsection QUADSPI Register Field Positions ****/

  static const int32_t QUADSPI_CR_EN_POS           = 0;    /** @brief Enable enable the QUADSPI. */
  static const int32_t QUADSPI_CR_ABORT_POS        = 1;    /** @brief Abort request this bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit. */
  static const int32_t QUADSPI_CR_DMAEN_POS        = 2;    /** @brief DMA enable in indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set. */
  static const int32_t QUADSPI_CR_TCEN_POS         = 3;    /** @brief Timeout counter enable this bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (ncs) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with ncs maintained low, even if no access to the flash memory occurs for a long time. Since flash memories tend to consume more when ncs is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that ncs is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_CR_SSHIFT_POS       = 4;    /** @brief Sample shift by default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_CR_DFM_POS          = 6;    /** @brief Dual-flash mode this bit activates dual-flash mode, where two external flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_CR_FSEL_POS         = 7;    /** @brief Flash memory selection this bit selects the flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1. */
  static const int32_t QUADSPI_CR_FTHRES_POS       = 8;    /** @brief FIFO threshold level defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value. */
  static const int32_t QUADSPI_CR_TEIE_POS         = 16;   /** @brief Transfer error interrupt enable this bit enables the transfer error interrupt. */
  static const int32_t QUADSPI_CR_TCIE_POS         = 17;   /** @brief Transfer complete interrupt enable this bit enables the transfer complete interrupt. */
  static const int32_t QUADSPI_CR_FTIE_POS         = 18;   /** @brief FIFO threshold interrupt enable this bit enables the FIFO threshold interrupt. */
  static const int32_t QUADSPI_CR_SMIE_POS         = 19;   /** @brief Status match interrupt enable this bit enables the status match interrupt. */
  static const int32_t QUADSPI_CR_TOIE_POS         = 20;   /** @brief TimeOut interrupt enable this bit enables the timeout interrupt. */
  static const int32_t QUADSPI_CR_APMS_POS         = 22;   /** @brief Automatic poll mode stop this bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_CR_PMM_POS          = 23;   /** @brief Polling match mode this bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_CR_PRESCALER_POS    = 24;   /** @brief Clock prescaler */
  static const int32_t QUADSPI_DCR_CKMODE_POS      = 0;    /** @brief Indicates the level that clk takes between command */
  static const int32_t QUADSPI_DCR_CSHT_POS        = 8;    /** @brief Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (ncs) must remain high between commands issued to the flash memory. ... This field can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_DCR_FSIZE_POS       = 16;   /** @brief Flash memory size this field defines the size of external memory using the following formula: number of bytes in flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the flash memory. The flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two flash memories together. This field can be modified only when BUSY = 0. */
  static const int32_t QUADSPI_SR_TEF_POS          = 0;    /** @brief Transfer error flag this bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF. */
  static const int32_t QUADSPI_SR_TCF_POS          = 1;    /** @brief Transfer complete flag this bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.it is cleared by writing 1 to CTCF. */
  static const int32_t QUADSPI_SR_FTF_POS          = 2;    /** @brief FIFO threshold flag in indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read. */
  static const int32_t QUADSPI_SR_SMF_POS          = 3;    /** @brief Status match flag this bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF. */
  static const int32_t QUADSPI_SR_TOF_POS          = 4;    /** @brief Timeout flag this bit is set when timeout occurs. It is cleared by writing 1 to CTOF. */
  static const int32_t QUADSPI_SR_BUSY_POS         = 5;    /** @brief Busy this bit is set when an operation is on going. This bit clears automatically when the operation with the flash memory is finished and the FIFO is empty. */
  static const int32_t QUADSPI_SR_FLEVEL_POS       = 8;    /** @brief FIFO level this field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero. */
  static const int32_t QUADSPI_FCR_CTEF_POS        = 0;    /** @brief Clear transfer error flag writing 1 clears the TEF flag in the QUADSPI_SR register */
  static const int32_t QUADSPI_FCR_CTCF_POS        = 1;    /** @brief Clear transfer complete flag writing 1 clears the TCF flag in the QUADSPI_SR register */
  static const int32_t QUADSPI_FCR_CSMF_POS        = 3;    /** @brief Clear status match flag writing 1 clears the SMF flag in the QUADSPI_SR register */
  static const int32_t QUADSPI_FCR_CTOF_POS        = 4;    /** @brief Clear timeout flag writing 1 clears the TOF flag in the QUADSPI_SR register */
  static const int32_t QUADSPI_CCR_INSTRUCTION_POS = 0;    /** @brief Instruction instruction to be send to the external SPI device. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_IMODE_POS       = 8;    /** @brief Instruction mode this field defines the instruction phase mode of operation: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_ADMODE_POS      = 10;   /** @brief Address mode this field defines the address phase mode of operation: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_ADSIZE_POS      = 12;   /** @brief Address size this bit defines address size: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_ABMODE_POS      = 14;   /** @brief Alternate bytes mode this field defines the alternate-bytes phase mode of operation: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_ABSIZE_POS      = 16;   /** @brief Alternate bytes size this bit defines alternate bytes size: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_DCYC_POS        = 18;   /** @brief Number of dummy cycles this field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_DMODE_POS       = 24;   /** @brief Data mode this field defines the data phases mode of operation: this field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_FMODE_POS       = 26;   /** @brief Functional mode this field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_SIOO_POS        = 28;   /** @brief Send instruction only once mode see section15.3.11: sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_DHHC_POS        = 30;   /** @brief DDR hold delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: this feature is only active in DDR mode. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_CCR_DDRM_POS        = 31;   /** @brief Double data rate mode this bit sets the DDR mode for the address, alternate byte and data phase: this field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_PIR_INTERVAL_POS    = 0;    /** @brief Polling interval number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0. */
  static const int32_t QUADSPI_LPTR_TIMEOUT_POS    = 0;    /** @brief Timeout period after each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises ncs, putting the flash memory in a lower-consumption state. This field can be written only when BUSY = 0. */

  /**********************************************************************************************
   * @section RNG Register Information
   **********************************************************************************************/

  /**** @subsection RNG Register Pointers ****/

  static RW_ uint32_t* const RNG_CR_PTR = (RW_ uint32_t* const)0x48021800U;   /** @brief RNG control register */
  static RW_ uint32_t* const RNG_SR_PTR = (RW_ uint32_t* const)0x48021804U;   /** @brief RNG status register */
  static RO_ uint32_t* const RNG_DR_PTR = (RO_ uint32_t* const)0x48021808U;   /** @brief The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0. */

  /**** @subsection RNG Register Field Masks ****/

  static const uint32_t RNG_CR_RNGEN_MSK = 0x00000004U;   /** @brief Random number generator enable */
  static const uint32_t RNG_CR_IE_MSK    = 0x00000008U;   /** @brief Interrupt enable */
  static const uint32_t RNG_CR_CED_MSK   = 0x00000020U;   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
  static const uint32_t RNG_SR_DRDY_MSK  = 0x00000001U;   /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
  static const uint32_t RNG_SR_CECS_MSK  = 0x00000002U;   /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const uint32_t RNG_SR_SECS_MSK  = 0x00000004U;   /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
  static const uint32_t RNG_SR_CEIS_MSK  = 0x00000020U;   /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const uint32_t RNG_SR_SEIS_MSK  = 0x00000040U;   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

  /**** @subsection RNG Register Field Positions ****/

  static const int32_t RNG_CR_RNGEN_POS = 2;   /** @brief Random number generator enable */
  static const int32_t RNG_CR_IE_POS    = 3;   /** @brief Interrupt enable */
  static const int32_t RNG_CR_CED_POS   = 5;   /** @brief Clock error detection note: the clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48mhz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled. */
  static const int32_t RNG_SR_DRDY_POS  = 0;   /** @brief Data ready note: if IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated. */
  static const int32_t RNG_SR_CECS_POS  = 1;   /** @brief Clock error current status note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const int32_t RNG_SR_SECS_POS  = 2;   /** @brief Seed error current status ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) */
  static const int32_t RNG_SR_CEIS_POS  = 5;   /** @brief Clock error interrupt status this bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: this bit is meaningless if CED (clock error detection) bit in RNG_CR is equal to 1. */
  static const int32_t RNG_SR_SEIS_POS  = 6;   /** @brief Seed error interrupt status this bit is set at the same time as SECS. It is cleared by writing it to 0. ** more than 64 consecutive bits at the same value (0 or 1) ** more than 32 consecutive alternances of 0 and 1 (0101010101...01) an interrupt is pending if IE = 1 in the RNG_CR register. */

  /**********************************************************************************************
   * @section RxC Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated RxC Register Pointers ****/

  static RW_ uint32_t* const RxC_RTC_TR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024400U,   /** @brief Clock control register */
    [19] = (RW_ uint32_t* const)0x58004000U,   /** @brief The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_DR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024404U,   /** @brief RCC internal clock source calibration register */
    [19] = (RW_ uint32_t* const)0x58004004U,   /** @brief The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to calendar initialization and configuration on page9 and reading the calendar on page10.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_CR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024408U,   /** @brief RCC clock recovery RC register */
    [19] = (RW_ uint32_t* const)0x58004008U,   /** @brief RTC control register */
  };

  static RW_ uint32_t* const RxC_RTC_ISR_PTR[20] = {
    [19] = (RW_ uint32_t* const)0x5800400CU,   /** @brief This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_PRER_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024410U,   /** @brief RCC clock configuration register */
    [19] = (RW_ uint32_t* const)0x58004010U,   /** @brief This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to calendar initialization and configuration on page9.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_WUTR_PTR[20] = {
    [19] = (RW_ uint32_t* const)0x58004014U,   /** @brief This register can be written only when WUTWF is set to 1 in rtc_isr.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_ALRMAR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x5802441CU,   /** @brief RCC domain 2 clock configuration register */
    [19] = (RW_ uint32_t* const)0x5800401CU,   /** @brief This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_ALRMBR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024420U,   /** @brief RCC domain 3 clock configuration register */
    [19] = (RW_ uint32_t* const)0x58004020U,   /** @brief This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static WO_ uint32_t* const RxC_RTC_WPR_PTR[20] = {
    [19] = (WO_ uint32_t* const)0x58004024U,   /** @brief RTC write protection register */
  };

  static RO_ uint32_t* const RxC_RTC_SSR_PTR[20] = {
    [2]  = (RO_ uint32_t* const)0x58024428U,   /** @brief RCC plls clock source selection register */
    [19] = (RO_ uint32_t* const)0x58004028U,   /** @brief RTC sub second register */
  };

  static WO_ uint32_t* const RxC_RTC_SHIFTR_PTR[20] = {
    [2]  = (WO_ uint32_t* const)0x5802442CU,   /** @brief RCC plls configuration register */
    [19] = (WO_ uint32_t* const)0x5800402CU,   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RO_ uint32_t* const RxC_RTC_TSTR_PTR[20] = {
    [2]  = (RO_ uint32_t* const)0x58024430U,   /** @brief RCC PLL1 dividers configuration register */
    [19] = (RO_ uint32_t* const)0x58004030U,   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
  };

  static RO_ uint32_t* const RxC_RTC_TSDR_PTR[20] = {
    [2]  = (RO_ uint32_t* const)0x58024434U,   /** @brief RCC PLL1 fractional divider register */
    [19] = (RO_ uint32_t* const)0x58004034U,   /** @brief The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset. */
  };

  static RO_ uint32_t* const RxC_RTC_TSSSR_PTR[20] = {
    [2]  = (RO_ uint32_t* const)0x58024438U,   /** @brief RCC PLL2 dividers configuration register */
    [19] = (RO_ uint32_t* const)0x58004038U,   /** @brief The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset. */
  };

  static RW_ uint32_t* const RxC_RTC_CALR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x5802443CU,   /** @brief RCC PLL2 fractional divider register */
    [19] = (RW_ uint32_t* const)0x5800403CU,   /** @brief This register is write protected. The write access procedure is described in RTC register write protection on page9. */
  };

  static RW_ uint32_t* const RxC_RTC_TAMPCR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024440U,   /** @brief RCC PLL3 dividers configuration register */
    [19] = (RW_ uint32_t* const)0x58004040U,   /** @brief RTC tamper and alternate function configuration register */
  };

  static RW_ uint32_t* const RxC_RTC_ALRMASSR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x58024444U,   /** @brief RCC PLL3 fractional divider register */
    [19] = (RW_ uint32_t* const)0x58004044U,   /** @brief This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.this register is write protected. The write access procedure is described in RTC register write protection on page9 */
  };

  static RW_ uint32_t* const RxC_RTC_ALRMBSSR_PTR[20] = {
    [19] = (RW_ uint32_t* const)0x58004048U,   /** @brief This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.this register is write protected.the write access procedure is described in section: RTC register write protection. */
  };

  static RW_ uint32_t* const RxC_RTC_OR_PTR[20] = {
    [2]  = (RW_ uint32_t* const)0x5802444CU,   /** @brief RCC domain 1 kernel clock configuration register */
    [19] = (RW_ uint32_t* const)0x5800404CU,   /** @brief RTC option register */
  };

  /**** @subsection RxC Register Field Masks ****/

  static const uint32_t RxC_RTC_TR_SU_MSK             = 0x0000000FU;   /** @brief Second units in BCD format */
  static const uint32_t RxC_RTC_TR_ST_MSK             = 0x00000070U;   /** @brief Second tens in BCD format */
  static const uint32_t RxC_RTC_TR_MNU_MSK            = 0x00000F00U;   /** @brief Minute units in BCD format */
  static const uint32_t RxC_RTC_TR_MNT_MSK            = 0x00007000U;   /** @brief Minute tens in BCD format */
  static const uint32_t RxC_RTC_TR_HU_MSK             = 0x000F0000U;   /** @brief Hour units in BCD format */
  static const uint32_t RxC_RTC_TR_HT_MSK             = 0x00300000U;   /** @brief Hour tens in BCD format */
  static const uint32_t RxC_RTC_TR_PM_MSK             = 0x00400000U;   /** @brief AM/PM notation */
  static const uint32_t RxC_RTC_DR_DU_MSK             = 0x0000000FU;   /** @brief Date units in BCD format */
  static const uint32_t RxC_RTC_DR_DT_MSK             = 0x00000030U;   /** @brief Date tens in BCD format */
  static const uint32_t RxC_RTC_DR_MU_MSK             = 0x00000F00U;   /** @brief Month units in BCD format */
  static const uint32_t RxC_RTC_DR_MT_MSK             = 0x00001000U;   /** @brief Month tens in BCD format */
  static const uint32_t RxC_RTC_DR_WDU_MSK            = 0x0000E000U;   /** @brief Week day units */
  static const uint32_t RxC_RTC_DR_YU_MSK             = 0x000F0000U;   /** @brief Year units in BCD format */
  static const uint32_t RxC_RTC_DR_YT_MSK             = 0x00F00000U;   /** @brief Year tens in BCD format */
  static const uint32_t RxC_RTC_CR_WUCKSEL_MSK        = 0x00000007U;   /** @brief Wakeup clock selection */
  static const uint32_t RxC_RTC_CR_TSEDGE_MSK         = 0x00000008U;   /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
  static const uint32_t RxC_RTC_CR_REFCKON_MSK        = 0x00000010U;   /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
  static const uint32_t RxC_RTC_CR_BYPSHAD_MSK        = 0x00000020U;   /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
  static const uint32_t RxC_RTC_CR_FMT_MSK            = 0x00000040U;   /** @brief Hour format */
  static const uint32_t RxC_RTC_CR_ALRAE_MSK          = 0x00000100U;   /** @brief Alarm A enable */
  static const uint32_t RxC_RTC_CR_ALRBE_MSK          = 0x00000200U;   /** @brief Alarm B enable */
  static const uint32_t RxC_RTC_CR_WUTE_MSK           = 0x00000400U;   /** @brief Wakeup timer enable */
  static const uint32_t RxC_RTC_CR_TSE_MSK            = 0x00000800U;   /** @brief Timestamp enable */
  static const uint32_t RxC_RTC_CR_ALRAIE_MSK         = 0x00001000U;   /** @brief Alarm A interrupt enable */
  static const uint32_t RxC_RTC_CR_ALRBIE_MSK         = 0x00002000U;   /** @brief Alarm B interrupt enable */
  static const uint32_t RxC_RTC_CR_WUTIE_MSK          = 0x00004000U;   /** @brief Wakeup timer interrupt enable */
  static const uint32_t RxC_RTC_CR_TSIE_MSK           = 0x00008000U;   /** @brief Time-stamp interrupt enable */
  static const uint32_t RxC_RTC_CR_ADD1H_MSK          = 0x00010000U;   /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
  static const uint32_t RxC_RTC_CR_SUB1H_MSK          = 0x00020000U;   /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
  static const uint32_t RxC_RTC_CR_BKP_MSK            = 0x00040000U;   /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
  static const uint32_t RxC_RTC_CR_COSEL_MSK          = 0x00080000U;   /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
  static const uint32_t RxC_RTC_CR_POL_MSK            = 0x00100000U;   /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
  static const uint32_t RxC_RTC_CR_OSEL_MSK           = 0x00600000U;   /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
  static const uint32_t RxC_RTC_CR_COE_MSK            = 0x00800000U;   /** @brief Calibration output enable this bit enables the RTC_CALIB output */
  static const uint32_t RxC_RTC_CR_ITSE_MSK           = 0x01000000U;   /** @brief Timestamp on internal event enable */
  static const uint32_t RxC_RTC_ISR_ALRAWF_MSK        = 0x00000001U;   /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const uint32_t RxC_RTC_ISR_ALRBWF_MSK        = 0x00000002U;   /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const uint32_t RxC_RTC_ISR_WUTWF_MSK         = 0x00000004U;   /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
  static const uint32_t RxC_RTC_ISR_SHPF_MSK          = 0x00000008U;   /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
  static const uint32_t RxC_RTC_ISR_INITS_MSK         = 0x00000010U;   /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
  static const uint32_t RxC_RTC_ISR_RSF_MSK           = 0x00000020U;   /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
  static const uint32_t RxC_RTC_ISR_INITF_MSK         = 0x00000040U;   /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
  static const uint32_t RxC_RTC_ISR_INIT_MSK          = 0x00000080U;   /** @brief Initialization mode */
  static const uint32_t RxC_RTC_ISR_ALRAF_MSK         = 0x00000100U;   /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
  static const uint32_t RxC_RTC_ISR_ALRBF_MSK         = 0x00000200U;   /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
  static const uint32_t RxC_RTC_ISR_WUTF_MSK          = 0x00000400U;   /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
  static const uint32_t RxC_RTC_ISR_TSF_MSK           = 0x00000800U;   /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
  static const uint32_t RxC_RTC_ISR_TSOVF_MSK         = 0x00001000U;   /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
  static const uint32_t RxC_RTC_ISR_RECALPF_MSK       = 0x00010000U;   /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
  static const uint32_t RxC_RTC_ISR_ITSF_MSK          = 0x00020000U;   /** @brief Internal ttime-stamp flag */
  static const uint32_t RxC_RTC_PRER_PREDIV_S_MSK     = 0x00007FFFU;   /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
  static const uint32_t RxC_RTC_PRER_PREDIV_A_MSK     = 0x007F0000U;   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
  static const uint32_t RxC_RTC_WUTR_WUT_MSK          = 0x0000FFFFU;   /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
  static const uint32_t RxC_RTC_ALRMAR_SU_MSK         = 0x0000000FU;   /** @brief Second units in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_ST_MSK         = 0x00000070U;   /** @brief Second tens in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_MNU_MSK        = 0x00000F00U;   /** @brief Minute units in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_MNT_MSK        = 0x00007000U;   /** @brief Minute tens in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_HU_MSK         = 0x000F0000U;   /** @brief Hour units in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_HT_MSK         = 0x00300000U;   /** @brief Hour tens in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_PM_MSK         = 0x00400000U;   /** @brief AM/PM notation */
  static const uint32_t RxC_RTC_ALRMAR_DU_MSK         = 0x0F000000U;   /** @brief Date units or day in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_DT_MSK         = 0x30000000U;   /** @brief Date tens in BCD format. */
  static const uint32_t RxC_RTC_ALRMAR_WDSEL_MSK      = 0x40000000U;   /** @brief Week day selection */
  static const uint32_t RxC_RTC_ALRMBR_SU_MSK         = 0x0000000FU;   /** @brief Second units in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_ST_MSK         = 0x00000070U;   /** @brief Second tens in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_MNU_MSK        = 0x00000F00U;   /** @brief Minute units in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_MNT_MSK        = 0x00007000U;   /** @brief Minute tens in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_HU_MSK         = 0x000F0000U;   /** @brief Hour units in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_HT_MSK         = 0x00300000U;   /** @brief Hour tens in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_PM_MSK         = 0x00400000U;   /** @brief AM/PM notation */
  static const uint32_t RxC_RTC_ALRMBR_DU_MSK         = 0x0F000000U;   /** @brief Date units or day in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_DT_MSK         = 0x30000000U;   /** @brief Date tens in BCD format */
  static const uint32_t RxC_RTC_ALRMBR_WDSEL_MSK      = 0x40000000U;   /** @brief Week day selection */
  static const uint32_t RxC_RTC_WPR_KEY_MSK           = 0x000000FFU;   /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
  static const uint32_t RxC_RTC_SSR_SS_MSK            = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
  static const uint32_t RxC_RTC_SHIFTR_SUBFS_MSK      = 0x00007FFFU;   /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
  static const uint32_t RxC_RTC_SHIFTR_ADD1S_MSK      = 0x80000000U;   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
  static const uint32_t RxC_RTC_TSTR_SU_MSK           = 0x0000000FU;   /** @brief Second units in BCD format. */
  static const uint32_t RxC_RTC_TSTR_ST_MSK           = 0x00000070U;   /** @brief Second tens in BCD format. */
  static const uint32_t RxC_RTC_TSTR_MNU_MSK          = 0x00000F00U;   /** @brief Minute units in BCD format. */
  static const uint32_t RxC_RTC_TSTR_MNT_MSK          = 0x00007000U;   /** @brief Minute tens in BCD format. */
  static const uint32_t RxC_RTC_TSTR_HU_MSK           = 0x000F0000U;   /** @brief Hour units in BCD format. */
  static const uint32_t RxC_RTC_TSTR_HT_MSK           = 0x00300000U;   /** @brief Hour tens in BCD format. */
  static const uint32_t RxC_RTC_TSTR_PM_MSK           = 0x00400000U;   /** @brief AM/PM notation */
  static const uint32_t RxC_RTC_TSDR_DU_MSK           = 0x0000000FU;   /** @brief Date units in BCD format */
  static const uint32_t RxC_RTC_TSDR_DT_MSK           = 0x00000030U;   /** @brief Date tens in BCD format */
  static const uint32_t RxC_RTC_TSDR_MU_MSK           = 0x00000F00U;   /** @brief Month units in BCD format */
  static const uint32_t RxC_RTC_TSDR_MT_MSK           = 0x00001000U;   /** @brief Month tens in BCD format */
  static const uint32_t RxC_RTC_TSDR_WDU_MSK          = 0x0000E000U;   /** @brief Week day units */
  static const uint32_t RxC_RTC_TSSSR_SS_MSK          = 0x0000FFFFU;   /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
  static const uint32_t RxC_RTC_CALR_CALM_MSK         = 0x000001FFU;   /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
  static const uint32_t RxC_RTC_CALR_CALP_MSK         = 0x00008000U;   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
  static const uint32_t RxC_RTC_TAMPCR_TAMPIE_MSK     = 0x00000004U;   /** @brief Tamper interrupt enable */
  static const uint32_t RxC_RTC_TAMPCR_TAMPTS_MSK     = 0x00000080U;   /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
  static const uint32_t RxC_RTC_TAMPCR_TAMPFREQ_MSK   = 0x00000700U;   /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
  static const uint32_t RxC_RTC_TAMPCR_TAMPFLT_MSK    = 0x00001800U;   /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
  static const uint32_t RxC_RTC_TAMPCR_TAMPPRCH_MSK   = 0x00006000U;   /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
  static const uint32_t RxC_RTC_TAMPCR_TAMPPUDIS_MSK  = 0x00008000U;   /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
  static const uint32_t RxC_RTC_ALRMASSR_SS_MSK       = 0x00007FFFU;   /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
  static const uint32_t RxC_RTC_ALRMASSR_MASKSS_MSK   = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const uint32_t RxC_RTC_ALRMBSSR_SS_MSK       = 0x00007FFFU;   /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
  static const uint32_t RxC_RTC_ALRMBSSR_MASKSS_MSK   = 0x0F000000U;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const uint32_t RxC_RTC_OR_RTC_ALARM_TYPE_MSK = 0x00000001U;   /** @brief RTC_ALARM output type on PC13 */
  static const uint32_t RxC_RTC_OR_RTC_OUT_RMP_MSK    = 0x00000002U;   /** @brief RTC_OUT remap */

  /**** @subsection Enumerated RxC Register Field Masks ****/

  static const uint32_t RxC_RTC_ISR_TAMPxF_MSK[4] = {
    [1] = 0x00002000U,   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
    [2] = 0x00004000U,   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
    [3] = 0x00008000U,   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
  };

  static const uint32_t RxC_RTC_ALRMAR_MSKx_MSK[5] = {
    [1] = 0x00000080U,   /** @brief Alarm A seconds mask */
    [2] = 0x00008000U,   /** @brief Alarm A minutes mask */
    [3] = 0x00800000U,   /** @brief Alarm A hours mask */
    [4] = 0x80000000U,   /** @brief Alarm A date mask */
  };

  static const uint32_t RxC_RTC_CALR_CALWx_MSK[17] = {
    [8]  = 0x00004000U,   /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    [16] = 0x00002000U,   /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
  };

  static const uint32_t RxC_RTC_TAMPCR_TAMPxE_MSK[4] = {
    [1] = 0x00000001U,   /** @brief RTC_TAMP1 input detection enable */
    [2] = 0x00000008U,   /** @brief RTC_TAMP2 input detection enable */
    [3] = 0x00000020U,   /** @brief RTC_TAMP3 detection enable */
  };

  static const uint32_t RxC_RTC_TAMPCR_TAMPxTRG_MSK[4] = {
    [1] = 0x00000002U,   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
    [2] = 0x00000010U,   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
    [3] = 0x00000040U,   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
  };

  static const uint32_t RxC_RTC_TAMPCR_TAMPxIE_MSK[4] = {
    [1] = 0x00010000U,   /** @brief Tamper 1 interrupt enable */
    [2] = 0x00080000U,   /** @brief Tamper 2 interrupt enable */
    [3] = 0x00400000U,   /** @brief Tamper 3 interrupt enable */
  };

  static const uint32_t RxC_RTC_TAMPCR_TAMPxNOERASE_MSK[4] = {
    [1] = 0x00020000U,   /** @brief Tamper 1 no erase */
    [2] = 0x00100000U,   /** @brief Tamper 2 no erase */
    [3] = 0x00800000U,   /** @brief Tamper 3 no erase */
  };

  static const uint32_t RxC_RTC_TAMPCR_TAMPxMF_MSK[4] = {
    [1] = 0x00040000U,   /** @brief Tamper 1 mask flag */
    [2] = 0x00200000U,   /** @brief Tamper 2 mask flag */
    [3] = 0x01000000U,   /** @brief Tamper 3 mask flag */
  };

  /**** @subsection RxC Register Field Positions ****/

  static const int32_t RxC_RTC_TR_SU_POS             = 0;    /** @brief Second units in BCD format */
  static const int32_t RxC_RTC_TR_ST_POS             = 4;    /** @brief Second tens in BCD format */
  static const int32_t RxC_RTC_TR_MNU_POS            = 8;    /** @brief Minute units in BCD format */
  static const int32_t RxC_RTC_TR_MNT_POS            = 12;   /** @brief Minute tens in BCD format */
  static const int32_t RxC_RTC_TR_HU_POS             = 16;   /** @brief Hour units in BCD format */
  static const int32_t RxC_RTC_TR_HT_POS             = 20;   /** @brief Hour tens in BCD format */
  static const int32_t RxC_RTC_TR_PM_POS             = 22;   /** @brief AM/PM notation */
  static const int32_t RxC_RTC_DR_DU_POS             = 0;    /** @brief Date units in BCD format */
  static const int32_t RxC_RTC_DR_DT_POS             = 4;    /** @brief Date tens in BCD format */
  static const int32_t RxC_RTC_DR_MU_POS             = 8;    /** @brief Month units in BCD format */
  static const int32_t RxC_RTC_DR_MT_POS             = 12;   /** @brief Month tens in BCD format */
  static const int32_t RxC_RTC_DR_WDU_POS            = 13;   /** @brief Week day units */
  static const int32_t RxC_RTC_DR_YU_POS             = 16;   /** @brief Year units in BCD format */
  static const int32_t RxC_RTC_DR_YT_POS             = 20;   /** @brief Year tens in BCD format */
  static const int32_t RxC_RTC_CR_WUCKSEL_POS        = 0;    /** @brief Wakeup clock selection */
  static const int32_t RxC_RTC_CR_TSEDGE_POS         = 3;    /** @brief Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting. */
  static const int32_t RxC_RTC_CR_REFCKON_POS        = 4;    /** @brief RTC_REFIN reference clock detection enable (50 or 60hz) note: PREDIV_S must be 0x00ff. */
  static const int32_t RxC_RTC_CR_BYPSHAD_POS        = 5;    /** @brief Bypass the shadow registers note: if the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1. */
  static const int32_t RxC_RTC_CR_FMT_POS            = 6;    /** @brief Hour format */
  static const int32_t RxC_RTC_CR_ALRAE_POS          = 8;    /** @brief Alarm A enable */
  static const int32_t RxC_RTC_CR_ALRBE_POS          = 9;    /** @brief Alarm B enable */
  static const int32_t RxC_RTC_CR_WUTE_POS           = 10;   /** @brief Wakeup timer enable */
  static const int32_t RxC_RTC_CR_TSE_POS            = 11;   /** @brief Timestamp enable */
  static const int32_t RxC_RTC_CR_ALRAIE_POS         = 12;   /** @brief Alarm A interrupt enable */
  static const int32_t RxC_RTC_CR_ALRBIE_POS         = 13;   /** @brief Alarm B interrupt enable */
  static const int32_t RxC_RTC_CR_WUTIE_POS          = 14;   /** @brief Wakeup timer interrupt enable */
  static const int32_t RxC_RTC_CR_TSIE_POS           = 15;   /** @brief Time-stamp interrupt enable */
  static const int32_t RxC_RTC_CR_ADD1H_POS          = 16;   /** @brief Add 1 hour (summer time change) when this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0. */
  static const int32_t RxC_RTC_CR_SUB1H_POS          = 17;   /** @brief Subtract 1 hour (winter time change) when this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0. */
  static const int32_t RxC_RTC_CR_BKP_POS            = 18;   /** @brief Backup this bit can be written by the user to memorize whether the daylight saving time change has been performed or not. */
  static const int32_t RxC_RTC_CR_COSEL_POS          = 19;   /** @brief Calibration output selection when COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 khz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to section24.3.15: calibration clock output */
  static const int32_t RxC_RTC_CR_POL_POS            = 20;   /** @brief Output polarity this bit is used to configure the polarity of RTC_ALARM output */
  static const int32_t RxC_RTC_CR_OSEL_POS           = 21;   /** @brief Output selection these bits are used to select the flag to be routed to RTC_ALARM output */
  static const int32_t RxC_RTC_CR_COE_POS            = 23;   /** @brief Calibration output enable this bit enables the RTC_CALIB output */
  static const int32_t RxC_RTC_CR_ITSE_POS           = 24;   /** @brief Timestamp on internal event enable */
  static const int32_t RxC_RTC_ISR_ALRAWF_POS        = 0;    /** @brief Alarm A write flag this bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const int32_t RxC_RTC_ISR_ALRBWF_POS        = 1;    /** @brief Alarm B write flag this bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode. */
  static const int32_t RxC_RTC_ISR_WUTWF_POS         = 2;    /** @brief Wakeup timer write flag this bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set. */
  static const int32_t RxC_RTC_ISR_SHPF_POS          = 3;    /** @brief Shift operation pending this flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect. */
  static const int32_t RxC_RTC_ISR_INITS_POS         = 4;    /** @brief Initialization status flag this bit is set by hardware when the calendar year field is different from 0 (backup domain reset state). */
  static const int32_t RxC_RTC_ISR_RSF_POS           = 5;    /** @brief Registers synchronization flag this bit is set by hardware each time the calendar registers are copied into the shadow registers (rtc_ssrx, rtc_trx and rtc_drx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode. */
  static const int32_t RxC_RTC_ISR_INITF_POS         = 6;    /** @brief Initialization flag when this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated. */
  static const int32_t RxC_RTC_ISR_INIT_POS          = 7;    /** @brief Initialization mode */
  static const int32_t RxC_RTC_ISR_ALRAF_POS         = 8;    /** @brief Alarm A flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0. */
  static const int32_t RxC_RTC_ISR_ALRBF_POS         = 9;    /** @brief Alarm B flag this flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0. */
  static const int32_t RxC_RTC_ISR_WUTF_POS          = 10;   /** @brief Wakeup timer flag this flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again. */
  static const int32_t RxC_RTC_ISR_TSF_POS           = 11;   /** @brief Time-stamp flag this flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0. */
  static const int32_t RxC_RTC_ISR_TSOVF_POS         = 12;   /** @brief Time-stamp overflow flag this flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared. */
  static const int32_t RxC_RTC_ISR_RECALPF_POS       = 16;   /** @brief Recalibration pending flag the RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to re-calibration on-the-fly. */
  static const int32_t RxC_RTC_ISR_ITSF_POS          = 17;   /** @brief Internal ttime-stamp flag */
  static const int32_t RxC_RTC_PRER_PREDIV_S_POS     = 0;    /** @brief Synchronous prescaler factor this is the synchronous division factor: ck_spre frequency = ck_apre frequency/(prediv_s+1) */
  static const int32_t RxC_RTC_PRER_PREDIV_A_POS     = 16;   /** @brief Asynchronous prescaler factor this is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(prediv_a+1) */
  static const int32_t RxC_RTC_WUTR_WUT_POS          = 0;    /** @brief Wakeup auto-reload value bits when the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register when WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden. */
  static const int32_t RxC_RTC_ALRMAR_SU_POS         = 0;    /** @brief Second units in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_ST_POS         = 4;    /** @brief Second tens in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_MNU_POS        = 8;    /** @brief Minute units in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_MNT_POS        = 12;   /** @brief Minute tens in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_HU_POS         = 16;   /** @brief Hour units in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_HT_POS         = 20;   /** @brief Hour tens in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_PM_POS         = 22;   /** @brief AM/PM notation */
  static const int32_t RxC_RTC_ALRMAR_DU_POS         = 24;   /** @brief Date units or day in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_DT_POS         = 28;   /** @brief Date tens in BCD format. */
  static const int32_t RxC_RTC_ALRMAR_WDSEL_POS      = 30;   /** @brief Week day selection */
  static const int32_t RxC_RTC_ALRMBR_SU_POS         = 0;    /** @brief Second units in BCD format */
  static const int32_t RxC_RTC_ALRMBR_ST_POS         = 4;    /** @brief Second tens in BCD format */
  static const int32_t RxC_RTC_ALRMBR_MNU_POS        = 8;    /** @brief Minute units in BCD format */
  static const int32_t RxC_RTC_ALRMBR_MNT_POS        = 12;   /** @brief Minute tens in BCD format */
  static const int32_t RxC_RTC_ALRMBR_HU_POS         = 16;   /** @brief Hour units in BCD format */
  static const int32_t RxC_RTC_ALRMBR_HT_POS         = 20;   /** @brief Hour tens in BCD format */
  static const int32_t RxC_RTC_ALRMBR_PM_POS         = 22;   /** @brief AM/PM notation */
  static const int32_t RxC_RTC_ALRMBR_DU_POS         = 24;   /** @brief Date units or day in BCD format */
  static const int32_t RxC_RTC_ALRMBR_DT_POS         = 28;   /** @brief Date tens in BCD format */
  static const int32_t RxC_RTC_ALRMBR_WDSEL_POS      = 30;   /** @brief Week day selection */
  static const int32_t RxC_RTC_WPR_KEY_POS           = 0;    /** @brief Write protection key this byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection. */
  static const int32_t RxC_RTC_SSR_SS_POS            = 0;    /** @brief Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR. */
  static const int32_t RxC_RTC_SHIFTR_SUBFS_POS      = 0;    /** @brief Subtract a fraction of a second these bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time. */
  static const int32_t RxC_RTC_SHIFTR_ADD1S_POS      = 31;   /** @brief Add one second this bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation. */
  static const int32_t RxC_RTC_TSTR_SU_POS           = 0;    /** @brief Second units in BCD format. */
  static const int32_t RxC_RTC_TSTR_ST_POS           = 4;    /** @brief Second tens in BCD format. */
  static const int32_t RxC_RTC_TSTR_MNU_POS          = 8;    /** @brief Minute units in BCD format. */
  static const int32_t RxC_RTC_TSTR_MNT_POS          = 12;   /** @brief Minute tens in BCD format. */
  static const int32_t RxC_RTC_TSTR_HU_POS           = 16;   /** @brief Hour units in BCD format. */
  static const int32_t RxC_RTC_TSTR_HT_POS           = 20;   /** @brief Hour tens in BCD format. */
  static const int32_t RxC_RTC_TSTR_PM_POS           = 22;   /** @brief AM/PM notation */
  static const int32_t RxC_RTC_TSDR_DU_POS           = 0;    /** @brief Date units in BCD format */
  static const int32_t RxC_RTC_TSDR_DT_POS           = 4;    /** @brief Date tens in BCD format */
  static const int32_t RxC_RTC_TSDR_MU_POS           = 8;    /** @brief Month units in BCD format */
  static const int32_t RxC_RTC_TSDR_MT_POS           = 12;   /** @brief Month tens in BCD format */
  static const int32_t RxC_RTC_TSDR_WDU_POS          = 13;   /** @brief Week day units */
  static const int32_t RxC_RTC_TSSSR_SS_POS          = 0;    /** @brief Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred. */
  static const int32_t RxC_RTC_CALR_CALM_POS         = 0;    /** @brief Calibration minus the frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See section24.3.12: RTC smooth digital calibration on page13. */
  static const int32_t RxC_RTC_CALR_CALP_POS         = 15;   /** @brief Increase frequency of RTC by 488.5 ppm this feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. If the input frequency is 32768 hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to section24.3.12: RTC smooth digital calibration. */
  static const int32_t RxC_RTC_TAMPCR_TAMPIE_POS     = 2;    /** @brief Tamper interrupt enable */
  static const int32_t RxC_RTC_TAMPCR_TAMPTS_POS     = 7;    /** @brief Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register. */
  static const int32_t RxC_RTC_TAMPCR_TAMPFREQ_POS   = 8;    /** @brief Tamper sampling frequency determines the frequency at which each of the rtc_tampx inputs are sampled. */
  static const int32_t RxC_RTC_TAMPCR_TAMPFLT_POS    = 11;   /** @brief RTC_TAMPx filter count these bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the rtc_tampx inputs. */
  static const int32_t RxC_RTC_TAMPCR_TAMPPRCH_POS   = 13;   /** @brief RTC_TAMPx precharge duration these bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the rtc_tampx inputs. */
  static const int32_t RxC_RTC_TAMPCR_TAMPPUDIS_POS  = 15;   /** @brief RTC_TAMPx pull-up disable this bit determines if each of the rtc_tampx pins are pre-charged before each sample. */
  static const int32_t RxC_RTC_ALRMASSR_SS_POS       = 0;    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared. */
  static const int32_t RxC_RTC_ALRMASSR_MASKSS_POS   = 24;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const int32_t RxC_RTC_ALRMBSSR_SS_POS       = 0;    /** @brief Sub seconds value this value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared. */
  static const int32_t RxC_RTC_ALRMBSSR_MASKSS_POS   = 24;   /** @brief Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation. */
  static const int32_t RxC_RTC_OR_RTC_ALARM_TYPE_POS = 0;    /** @brief RTC_ALARM output type on PC13 */
  static const int32_t RxC_RTC_OR_RTC_OUT_RMP_POS    = 1;    /** @brief RTC_OUT remap */

  /**** @subsection Enumerated RxC Register Field Positions ****/

  static const int32_t RxC_RTC_ISR_TAMPxF_POS[4] = {
    [1] = 13,   /** @brief RTC_TAMP1 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0 */
    [2] = 14,   /** @brief RTC_TAMP2 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0 */
    [3] = 15,   /** @brief RTC_TAMP3 detection flag this flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0 */
  };

  static const int32_t RxC_RTC_ALRMAR_MSKx_POS[5] = {
    [1] = 7,    /** @brief Alarm A seconds mask */
    [2] = 15,   /** @brief Alarm A minutes mask */
    [3] = 23,   /** @brief Alarm A hours mask */
    [4] = 31,   /** @brief Alarm A date mask */
  };

  static const int32_t RxC_RTC_CALR_CALWx_POS[17] = {
    [8]  = 14,   /** @brief Use an 8-second calibration cycle period when CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to section24.3.12: RTC smooth digital calibration. */
    [16] = 13,   /** @brief Use a 16-second calibration cycle period when CALW16 is set to 1, the 16-second calibration cycle period is selected.this bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to section24.3.12: RTC smooth digital calibration. */
  };

  static const int32_t RxC_RTC_TAMPCR_TAMPxE_POS[4] = {
    [1] = 0,   /** @brief RTC_TAMP1 input detection enable */
    [2] = 3,   /** @brief RTC_TAMP2 input detection enable */
    [3] = 5,   /** @brief RTC_TAMP3 detection enable */
  };

  static const int32_t RxC_RTC_TAMPCR_TAMPxTRG_POS[4] = {
    [1] = 1,   /** @brief Active level for RTC_TAMP1 input if TAMPFLT != 00 if TAMPFLT = 00: */
    [2] = 4,   /** @brief Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00: */
    [3] = 6,   /** @brief Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00: */
  };

  static const int32_t RxC_RTC_TAMPCR_TAMPxIE_POS[4] = {
    [1] = 16,   /** @brief Tamper 1 interrupt enable */
    [2] = 19,   /** @brief Tamper 2 interrupt enable */
    [3] = 22,   /** @brief Tamper 3 interrupt enable */
  };

  static const int32_t RxC_RTC_TAMPCR_TAMPxNOERASE_POS[4] = {
    [1] = 17,   /** @brief Tamper 1 no erase */
    [2] = 20,   /** @brief Tamper 2 no erase */
    [3] = 23,   /** @brief Tamper 3 no erase */
  };

  static const int32_t RxC_RTC_TAMPCR_TAMPxMF_POS[4] = {
    [1] = 18,   /** @brief Tamper 1 mask flag */
    [2] = 21,   /** @brief Tamper 2 mask flag */
    [3] = 24,   /** @brief Tamper 3 mask flag */
  };

  /**********************************************************************************************
   * @section SxI4 Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated SxI4 Register Pointers ****/

  static RW_ uint32_t* const SxI4_SAI_GCR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005400U,   /** @brief Global configuration register */
    [15] = (RW_ uint32_t* const)0x40013400U,   /** @brief Control register 1 */
  };

  static RW_ uint32_t* const SxI4_SAI_AFRCR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x5800540CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [15] = (RW_ uint32_t* const)0x4001340CU,   /** @brief Configuration register 2 */
  };

  static RW_ uint32_t* const SxI4_SAI_ASLOTR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005410U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [15] = (RW_ uint32_t* const)0x40013410U,   /** @brief Interrupt enable register */
  };

  static RW_ uint32_t* const SxI4_SAI_AIM_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005414U,   /** @brief Interrupt mask register 2 */
    [15] = (RW_ uint32_t* const)0x40013414U,   /** @brief Status register */
  };

  static RW_ uint32_t* const SxI4_SAI_ASR_PTR[16] = {
    [0]  = (RO_ uint32_t* const)0x58005418U,   /** @brief Status register */
    [15] = (RO_ uint32_t* const)0x40013418U,   /** @brief Interrupt/Status flags clear register */
  };

  static RO_ uint32_t* const SxI4_SAI_ACLRFR_PTR[16] = {
    [0]  = (WO_ uint32_t* const)0x5800541CU,   /** @brief Clear flag register */
  };

  static WO_ uint32_t* const SxI4_SAI_ADR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005420U,   /** @brief Data register */
    [15] = (RW_ uint32_t* const)0x40013420U,   /** @brief Transmit data register */
  };

  static RW_ uint32_t* const SxI4_SAI_BFRCR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x5800542CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
  };

  static RW_ uint32_t* const SxI4_SAI_BSLOTR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005430U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [15] = (RW_ uint32_t* const)0x40013430U,   /** @brief Receive data register */
  };

  static RW_ uint32_t* const SxI4_SAI_BIM_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005434U,   /** @brief Interrupt mask register 2 */
  };

  static RW_ uint32_t* const SxI4_SAI_BSR_PTR[16] = {
    [0]  = (RO_ uint32_t* const)0x58005438U,   /** @brief Status register */
  };

  static RW_ uint32_t* const SxI4_SAI_BCLRFR_PTR[16] = {
    [0]  = (WO_ uint32_t* const)0x5800543CU,   /** @brief Clear flag register */
  };

  static RO_ uint32_t* const SxI4_SAI_BDR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005440U,   /** @brief Data register */
    [15] = (RW_ uint32_t* const)0x40013440U,   /** @brief Polynomial register */
  };

  static WO_ uint32_t* const SxI4_SAI_PDMCR_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005444U,   /** @brief PDM control register */
    [15] = (RW_ uint32_t* const)0x40013444U,   /** @brief Transmitter CRC register */
  };

  static RW_ uint32_t* const SxI4_SAI_PDMDLY_PTR[16] = {
    [0]  = (RW_ uint32_t* const)0x58005448U,   /** @brief PDM delay register */
    [15] = (RW_ uint32_t* const)0x40013448U,   /** @brief Receiver CRC register */
  };

  /**** @subsection SxI4 Register Field Masks ****/

  static const uint32_t SxI4_SAI_GCR_SYNCOUT_MSK     = 0x00000030U;   /** @brief Synchronization outputs these bits are set and cleared by software. */
  static const uint32_t SxI4_SAI_GCR_SYNCIN_MSK      = 0x00000003U;   /** @brief Synchronization inputs */
  static const uint32_t SxI4_SAI_ACRx_MODE_MSK       = 0x00000003U;   /** @brief SAIx audio block mode immediately */
  static const uint32_t SxI4_SAI_ACRx_PRTCFG_MSK     = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_ACRx_DS_MSK         = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_ACRx_LSBFIRST_MSK   = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const uint32_t SxI4_SAI_ACRx_CKSTR_MSK      = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const uint32_t SxI4_SAI_ACRx_SYNCEN_MSK     = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const uint32_t SxI4_SAI_ACRx_MONO_MSK       = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const uint32_t SxI4_SAI_ACRx_OUTDRIV_MSK    = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const uint32_t SxI4_SAI_ACRx_SAIXEN_MSK     = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const uint32_t SxI4_SAI_ACRx_DMAEN_MSK      = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const uint32_t SxI4_SAI_ACRx_NOMCK_MSK      = 0x00080000U;   /** @brief No divider */
  static const uint32_t SxI4_SAI_ACRx_MCKDIV_MSK     = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const uint32_t SxI4_SAI_ACRx_OSR_MSK        = 0x04000000U;   /** @brief Oversampling ratio for master clock */
  static const uint32_t SxI4_SAI_AFRCR_FRL_MSK       = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const uint32_t SxI4_SAI_AFRCR_FSALL_MSK     = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_AFRCR_FSDEF_MSK     = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_AFRCR_FSPOL_MSK     = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_AFRCR_FSOFF_MSK     = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_ASLOTR_FBOFF_MSK    = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_ASLOTR_SLOTSZ_MSK   = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_ASLOTR_NBSLOT_MSK   = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_ASLOTR_SLOTEN_MSK   = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_AIM_OVRUDRIE_MSK    = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const uint32_t SxI4_SAI_AIM_MUTEDETIE_MSK   = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const uint32_t SxI4_SAI_AIM_WCKCFGIE_MSK    = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const uint32_t SxI4_SAI_AIM_FREQIE_MSK      = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const uint32_t SxI4_SAI_AIM_CNRDYIE_MSK     = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const uint32_t SxI4_SAI_AIM_AFSDETIE_MSK    = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SxI4_SAI_AIM_LFSDETIE_MSK    = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SxI4_SAI_ASR_OVRUDR_MSK      = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_ASR_MUTEDET_MSK     = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const uint32_t SxI4_SAI_ASR_WCKCFG_MSK      = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_ASR_FREQ_MSK        = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const uint32_t SxI4_SAI_ASR_CNRDY_MSK       = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_ASR_AFSDET_MSK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_ASR_LFSDET_MSK      = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const uint32_t SxI4_SAI_ASR_FLVL_MSK        = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const uint32_t SxI4_SAI_ACLRFR_COVRUDR_MSK  = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_ACLRFR_CMUTEDET_MSK = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_ACLRFR_CWCKCFG_MSK  = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_ACLRFR_CCNRDY_MSK   = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_ACLRFR_CAFSDET_MSK  = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_ACLRFR_CLFSDET_MSK  = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCRx_MODE_MSK       = 0x00000003U;   /** @brief SAIx audio block mode immediately */
  static const uint32_t SxI4_SAI_BCRx_PRTCFG_MSK     = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BCRx_DS_MSK         = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BCRx_LSBFIRST_MSK   = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const uint32_t SxI4_SAI_BCRx_CKSTR_MSK      = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const uint32_t SxI4_SAI_BCRx_SYNCEN_MSK     = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const uint32_t SxI4_SAI_BCRx_MONO_MSK       = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const uint32_t SxI4_SAI_BCRx_OUTDRIV_MSK    = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const uint32_t SxI4_SAI_BCRx_SAIXEN_MSK     = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const uint32_t SxI4_SAI_BCRx_DMAEN_MSK      = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const uint32_t SxI4_SAI_BCRx_NOMCK_MSK      = 0x00080000U;   /** @brief No divider */
  static const uint32_t SxI4_SAI_BCRx_MCKDIV_MSK     = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const uint32_t SxI4_SAI_BCRx_OSR_MSK        = 0x04000000U;   /** @brief Oversampling ratio for master clock */
  static const uint32_t SxI4_SAI_BFRCR_FRL_MSK       = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const uint32_t SxI4_SAI_BFRCR_FSALL_MSK     = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BFRCR_FSDEF_MSK     = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BFRCR_FSPOL_MSK     = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BFRCR_FSOFF_MSK     = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SxI4_SAI_BSLOTR_FBOFF_MSK    = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_BSLOTR_SLOTSZ_MSK   = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_BSLOTR_NBSLOT_MSK   = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_BSLOTR_SLOTEN_MSK   = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SxI4_SAI_BIM_OVRUDRIE_MSK    = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const uint32_t SxI4_SAI_BIM_MUTEDETIE_MSK   = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const uint32_t SxI4_SAI_BIM_WCKCFGIE_MSK    = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const uint32_t SxI4_SAI_BIM_FREQIE_MSK      = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const uint32_t SxI4_SAI_BIM_CNRDYIE_MSK     = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const uint32_t SxI4_SAI_BIM_AFSDETIE_MSK    = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SxI4_SAI_BIM_LFSDETIE_MSK    = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SxI4_SAI_BSR_OVRUDR_MSK      = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_BSR_MUTEDET_MSK     = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const uint32_t SxI4_SAI_BSR_WCKCFG_MSK      = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_BSR_FREQ_MSK        = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const uint32_t SxI4_SAI_BSR_CNRDY_MSK       = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_BSR_AFSDET_MSK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const uint32_t SxI4_SAI_BSR_LFSDET_MSK      = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const uint32_t SxI4_SAI_BSR_FLVL_MSK        = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const uint32_t SxI4_SAI_BCLRFR_COVRUDR_MSK  = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCLRFR_CMUTEDET_MSK = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCLRFR_CWCKCFG_MSK  = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCLRFR_CCNRDY_MSK   = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCLRFR_CAFSDET_MSK  = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_BCLRFR_CLFSDET_MSK  = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const uint32_t SxI4_SAI_PDMCR_PDMEN_MSK     = 0x00000001U;   /** @brief PDM enable */
  static const uint32_t SxI4_SAI_PDMCR_MICNBR_MSK    = 0x00000030U;   /** @brief Number of microphones */

  /**** @subsection Enumerated SxI4 Register Field Masks ****/

  static const uint32_t SxI4_SAI_PDMCR_CKENx_MSK[5] = {
    [1] = 0x00000100U,   /** @brief Clock enable of bitstream clock number 1 */
    [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
    [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
    [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
  };

  static const uint32_t SxI4_SAI_PDMDLY_DLYMxL_MSK[5] = {
    [1] = 0x00000007U,   /** @brief Delay line adjust for first microphone of pair 1 */
    [2] = 0x00000700U,   /** @brief Delay line for first microphone of pair 2 */
    [3] = 0x00070000U,   /** @brief Delay line for first microphone of pair 3 */
    [4] = 0x07000000U,   /** @brief Delay line for first microphone of pair 4 */
  };

  static const uint32_t SxI4_SAI_PDMDLY_DLYMxR_MSK[5] = {
    [1] = 0x00000070U,   /** @brief Delay line adjust for second microphone of pair 1 */
    [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
    [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
    [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
  };

  /**** @subsection SxI4 Register Field Positions ****/

  static const int32_t SxI4_SAI_GCR_SYNCOUT_POS     = 4;    /** @brief Synchronization outputs these bits are set and cleared by software. */
  static const int32_t SxI4_SAI_GCR_SYNCIN_POS      = 0;    /** @brief Synchronization inputs */
  static const int32_t SxI4_SAI_ACRx_MODE_POS       = 0;    /** @brief SAIx audio block mode immediately */
  static const int32_t SxI4_SAI_ACRx_PRTCFG_POS     = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_ACRx_DS_POS         = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_ACRx_LSBFIRST_POS   = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const int32_t SxI4_SAI_ACRx_CKSTR_POS      = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const int32_t SxI4_SAI_ACRx_SYNCEN_POS     = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const int32_t SxI4_SAI_ACRx_MONO_POS       = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const int32_t SxI4_SAI_ACRx_OUTDRIV_POS    = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const int32_t SxI4_SAI_ACRx_SAIXEN_POS     = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const int32_t SxI4_SAI_ACRx_DMAEN_POS      = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const int32_t SxI4_SAI_ACRx_NOMCK_POS      = 19;   /** @brief No divider */
  static const int32_t SxI4_SAI_ACRx_MCKDIV_POS     = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const int32_t SxI4_SAI_ACRx_OSR_POS        = 26;   /** @brief Oversampling ratio for master clock */
  static const int32_t SxI4_SAI_AFRCR_FRL_POS       = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const int32_t SxI4_SAI_AFRCR_FSALL_POS     = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_AFRCR_FSDEF_POS     = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_AFRCR_FSPOL_POS     = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_AFRCR_FSOFF_POS     = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_ASLOTR_FBOFF_POS    = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_ASLOTR_SLOTSZ_POS   = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_ASLOTR_NBSLOT_POS   = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_ASLOTR_SLOTEN_POS   = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_AIM_OVRUDRIE_POS    = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const int32_t SxI4_SAI_AIM_MUTEDETIE_POS   = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const int32_t SxI4_SAI_AIM_WCKCFGIE_POS    = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const int32_t SxI4_SAI_AIM_FREQIE_POS      = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const int32_t SxI4_SAI_AIM_CNRDYIE_POS     = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const int32_t SxI4_SAI_AIM_AFSDETIE_POS    = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SxI4_SAI_AIM_LFSDETIE_POS    = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SxI4_SAI_ASR_OVRUDR_POS      = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_ASR_MUTEDET_POS     = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const int32_t SxI4_SAI_ASR_WCKCFG_POS      = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_ASR_FREQ_POS        = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const int32_t SxI4_SAI_ASR_CNRDY_POS       = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_ASR_AFSDET_POS      = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_ASR_LFSDET_POS      = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const int32_t SxI4_SAI_ASR_FLVL_POS        = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const int32_t SxI4_SAI_ACLRFR_COVRUDR_POS  = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_ACLRFR_CMUTEDET_POS = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_ACLRFR_CWCKCFG_POS  = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_ACLRFR_CCNRDY_POS   = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_ACLRFR_CAFSDET_POS  = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_ACLRFR_CLFSDET_POS  = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCRx_MODE_POS       = 0;    /** @brief SAIx audio block mode immediately */
  static const int32_t SxI4_SAI_BCRx_PRTCFG_POS     = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BCRx_DS_POS         = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BCRx_LSBFIRST_POS   = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const int32_t SxI4_SAI_BCRx_CKSTR_POS      = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const int32_t SxI4_SAI_BCRx_SYNCEN_POS     = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const int32_t SxI4_SAI_BCRx_MONO_POS       = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const int32_t SxI4_SAI_BCRx_OUTDRIV_POS    = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const int32_t SxI4_SAI_BCRx_SAIXEN_POS     = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const int32_t SxI4_SAI_BCRx_DMAEN_POS      = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const int32_t SxI4_SAI_BCRx_NOMCK_POS      = 19;   /** @brief No divider */
  static const int32_t SxI4_SAI_BCRx_MCKDIV_POS     = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const int32_t SxI4_SAI_BCRx_OSR_POS        = 26;   /** @brief Oversampling ratio for master clock */
  static const int32_t SxI4_SAI_BFRCR_FRL_POS       = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const int32_t SxI4_SAI_BFRCR_FSALL_POS     = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BFRCR_FSDEF_POS     = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BFRCR_FSPOL_POS     = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BFRCR_FSOFF_POS     = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SxI4_SAI_BSLOTR_FBOFF_POS    = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_BSLOTR_SLOTSZ_POS   = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_BSLOTR_NBSLOT_POS   = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_BSLOTR_SLOTEN_POS   = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SxI4_SAI_BIM_OVRUDRIE_POS    = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const int32_t SxI4_SAI_BIM_MUTEDETIE_POS   = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const int32_t SxI4_SAI_BIM_WCKCFGIE_POS    = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const int32_t SxI4_SAI_BIM_FREQIE_POS      = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const int32_t SxI4_SAI_BIM_CNRDYIE_POS     = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const int32_t SxI4_SAI_BIM_AFSDETIE_POS    = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SxI4_SAI_BIM_LFSDETIE_POS    = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SxI4_SAI_BSR_OVRUDR_POS      = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_BSR_MUTEDET_POS     = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const int32_t SxI4_SAI_BSR_WCKCFG_POS      = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_BSR_FREQ_POS        = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const int32_t SxI4_SAI_BSR_CNRDY_POS       = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_BSR_AFSDET_POS      = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const int32_t SxI4_SAI_BSR_LFSDET_POS      = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const int32_t SxI4_SAI_BSR_FLVL_POS        = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const int32_t SxI4_SAI_BCLRFR_COVRUDR_POS  = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCLRFR_CMUTEDET_POS = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCLRFR_CWCKCFG_POS  = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCLRFR_CCNRDY_POS   = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCLRFR_CAFSDET_POS  = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_BCLRFR_CLFSDET_POS  = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const int32_t SxI4_SAI_PDMCR_PDMEN_POS     = 0;    /** @brief PDM enable */
  static const int32_t SxI4_SAI_PDMCR_MICNBR_POS    = 4;    /** @brief Number of microphones */

  /**** @subsection Enumerated SxI4 Register Field Positions ****/

  static const int32_t SxI4_SAI_PDMCR_CKENx_POS[5] = {
    [1] = 8,    /** @brief Clock enable of bitstream clock number 1 */
    [2] = 9,    /** @brief Clock enable of bitstream clock number 2 */
    [3] = 10,   /** @brief Clock enable of bitstream clock number 3 */
    [4] = 11,   /** @brief Clock enable of bitstream clock number 4 */
  };

  static const int32_t SxI4_SAI_PDMDLY_DLYMxL_POS[5] = {
    [1] = 0,    /** @brief Delay line adjust for first microphone of pair 1 */
    [2] = 8,    /** @brief Delay line for first microphone of pair 2 */
    [3] = 16,   /** @brief Delay line for first microphone of pair 3 */
    [4] = 24,   /** @brief Delay line for first microphone of pair 4 */
  };

  static const int32_t SxI4_SAI_PDMDLY_DLYMxR_POS[5] = {
    [1] = 4,    /** @brief Delay line adjust for second microphone of pair 1 */
    [2] = 12,   /** @brief Delay line for second microphone of pair 2 */
    [3] = 20,   /** @brief Delay line for second microphone of pair 3 */
    [4] = 28,   /** @brief Delay line for second microphone of pair 4 */
  };

  /**********************************************************************************************
   * @section SAIx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated SAIx Register Pointers ****/

  static RW_ uint32_t* const SAIx_SAI_GCR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015800U,   /** @brief Global configuration register */
    [2] = (RW_ uint32_t* const)0x40015C00U,   /** @brief Global configuration register */
    [3] = (RW_ uint32_t* const)0x40016000U,   /** @brief Global configuration register */
  };

  static RW_ uint32_t* const SAIx_SAI_ACRx_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40015804U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015808U,   /** @brief Configuration register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40015C04U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015C08U,   /** @brief Configuration register 2 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40016004U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40016008U,   /** @brief Configuration register 2 */
    },
  };

  static RW_ uint32_t* const SAIx_SAI_AFRCR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x4001580CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [2] = (RW_ uint32_t* const)0x40015C0CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [3] = (RW_ uint32_t* const)0x4001600CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
  };

  static RW_ uint32_t* const SAIx_SAI_ASLOTR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015810U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [2] = (RW_ uint32_t* const)0x40015C10U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [3] = (RW_ uint32_t* const)0x40016010U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
  };

  static RW_ uint32_t* const SAIx_SAI_AIM_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015814U,   /** @brief Interrupt mask register 2 */
    [2] = (RW_ uint32_t* const)0x40015C14U,   /** @brief Interrupt mask register 2 */
    [3] = (RW_ uint32_t* const)0x40016014U,   /** @brief Interrupt mask register 2 */
  };

  static RO_ uint32_t* const SAIx_SAI_ASR_PTR[5] = {
    [1] = (RO_ uint32_t* const)0x40015818U,   /** @brief Status register */
    [2] = (RO_ uint32_t* const)0x40015C18U,   /** @brief Status register */
    [3] = (RO_ uint32_t* const)0x40016018U,   /** @brief Status register */
  };

  static WO_ uint32_t* const SAIx_SAI_ACLRFR_PTR[5] = {
    [1] = (WO_ uint32_t* const)0x4001581CU,   /** @brief Clear flag register */
    [2] = (WO_ uint32_t* const)0x40015C1CU,   /** @brief Clear flag register */
    [3] = (WO_ uint32_t* const)0x4001601CU,   /** @brief Clear flag register */
  };

  static RW_ uint32_t* const SAIx_SAI_ADR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015820U,   /** @brief Data register */
    [2] = (RW_ uint32_t* const)0x40015C20U,   /** @brief Data register */
    [3] = (RW_ uint32_t* const)0x40016020U,   /** @brief Data register */
  };

  static RW_ uint32_t* const SAIx_SAI_BCRx_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40015824U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015828U,   /** @brief Configuration register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40015C24U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40015C28U,   /** @brief Configuration register 2 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40016024U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40016028U,   /** @brief Configuration register 2 */
    },
  };

  static RW_ uint32_t* const SAIx_SAI_BFRCR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x4001582CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [2] = (RW_ uint32_t* const)0x40015C2CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [3] = (RW_ uint32_t* const)0x4001602CU,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
  };

  static RW_ uint32_t* const SAIx_SAI_BSLOTR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015830U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [2] = (RW_ uint32_t* const)0x40015C30U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
    [3] = (RW_ uint32_t* const)0x40016030U,   /** @brief This register has no meaning in AC97 and SPDIF audio protocol */
  };

  static RW_ uint32_t* const SAIx_SAI_BIM_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015834U,   /** @brief Interrupt mask register 2 */
    [2] = (RW_ uint32_t* const)0x40015C34U,   /** @brief Interrupt mask register 2 */
    [3] = (RW_ uint32_t* const)0x40016034U,   /** @brief Interrupt mask register 2 */
  };

  static RO_ uint32_t* const SAIx_SAI_BSR_PTR[5] = {
    [1] = (RO_ uint32_t* const)0x40015838U,   /** @brief Status register */
    [2] = (RO_ uint32_t* const)0x40015C38U,   /** @brief Status register */
    [3] = (RO_ uint32_t* const)0x40016038U,   /** @brief Status register */
  };

  static WO_ uint32_t* const SAIx_SAI_BCLRFR_PTR[5] = {
    [1] = (WO_ uint32_t* const)0x4001583CU,   /** @brief Clear flag register */
    [2] = (WO_ uint32_t* const)0x40015C3CU,   /** @brief Clear flag register */
    [3] = (WO_ uint32_t* const)0x4001603CU,   /** @brief Clear flag register */
  };

  static RW_ uint32_t* const SAIx_SAI_BDR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015840U,   /** @brief Data register */
    [2] = (RW_ uint32_t* const)0x40015C40U,   /** @brief Data register */
    [3] = (RW_ uint32_t* const)0x40016040U,   /** @brief Data register */
  };

  static RW_ uint32_t* const SAIx_SAI_PDMCR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015844U,   /** @brief PDM control register */
    [2] = (RW_ uint32_t* const)0x40015C44U,   /** @brief PDM control register */
    [3] = (RW_ uint32_t* const)0x40016044U,   /** @brief PDM control register */
  };

  static RW_ uint32_t* const SAIx_SAI_PDMDLY_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x40015848U,   /** @brief PDM delay register */
    [2] = (RW_ uint32_t* const)0x40015C48U,   /** @brief PDM delay register */
    [3] = (RW_ uint32_t* const)0x40016048U,   /** @brief PDM delay register */
  };

  /**** @subsection SAIx Register Field Masks ****/

  static const uint32_t SAIx_SAI_GCR_SYNCOUT_MSK     = 0x00000030U;   /** @brief Synchronization outputs these bits are set and cleared by software. */
  static const uint32_t SAIx_SAI_GCR_SYNCIN_MSK      = 0x00000003U;   /** @brief Synchronization inputs */
  static const uint32_t SAIx_SAI_ACRx_MODE_MSK       = 0x00000003U;   /** @brief SAIx audio block mode immediately */
  static const uint32_t SAIx_SAI_ACRx_PRTCFG_MSK     = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_ACRx_DS_MSK         = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_ACRx_LSBFIRST_MSK   = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const uint32_t SAIx_SAI_ACRx_CKSTR_MSK      = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const uint32_t SAIx_SAI_ACRx_SYNCEN_MSK     = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const uint32_t SAIx_SAI_ACRx_MONO_MSK       = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const uint32_t SAIx_SAI_ACRx_OUTDRIV_MSK    = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const uint32_t SAIx_SAI_ACRx_SAIXEN_MSK     = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const uint32_t SAIx_SAI_ACRx_DMAEN_MSK      = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const uint32_t SAIx_SAI_ACRx_NOMCK_MSK      = 0x00080000U;   /** @brief No divider */
  static const uint32_t SAIx_SAI_ACRx_MCKDIV_MSK     = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const uint32_t SAIx_SAI_ACRx_OSR_MSK        = 0x04000000U;   /** @brief Oversampling ratio for master clock */
  static const uint32_t SAIx_SAI_AFRCR_FRL_MSK       = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const uint32_t SAIx_SAI_AFRCR_FSALL_MSK     = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_AFRCR_FSDEF_MSK     = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_AFRCR_FSPOL_MSK     = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_AFRCR_FSOFF_MSK     = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_ASLOTR_FBOFF_MSK    = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_ASLOTR_SLOTSZ_MSK   = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_ASLOTR_NBSLOT_MSK   = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_ASLOTR_SLOTEN_MSK   = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_AIM_OVRUDRIE_MSK    = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const uint32_t SAIx_SAI_AIM_MUTEDETIE_MSK   = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const uint32_t SAIx_SAI_AIM_WCKCFGIE_MSK    = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const uint32_t SAIx_SAI_AIM_FREQIE_MSK      = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const uint32_t SAIx_SAI_AIM_CNRDYIE_MSK     = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const uint32_t SAIx_SAI_AIM_AFSDETIE_MSK    = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SAIx_SAI_AIM_LFSDETIE_MSK    = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SAIx_SAI_ASR_OVRUDR_MSK      = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_ASR_MUTEDET_MSK     = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const uint32_t SAIx_SAI_ASR_WCKCFG_MSK      = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_ASR_FREQ_MSK        = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const uint32_t SAIx_SAI_ASR_CNRDY_MSK       = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_ASR_AFSDET_MSK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_ASR_LFSDET_MSK      = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const uint32_t SAIx_SAI_ASR_FLVL_MSK        = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const uint32_t SAIx_SAI_ACLRFR_COVRUDR_MSK  = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_ACLRFR_CMUTEDET_MSK = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_ACLRFR_CWCKCFG_MSK  = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_ACLRFR_CCNRDY_MSK   = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_ACLRFR_CAFSDET_MSK  = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_ACLRFR_CLFSDET_MSK  = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCRx_MODE_MSK       = 0x00000003U;   /** @brief SAIx audio block mode immediately */
  static const uint32_t SAIx_SAI_BCRx_PRTCFG_MSK     = 0x0000000CU;   /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BCRx_DS_MSK         = 0x000000E0U;   /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BCRx_LSBFIRST_MSK   = 0x00000100U;   /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const uint32_t SAIx_SAI_BCRx_CKSTR_MSK      = 0x00000200U;   /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const uint32_t SAIx_SAI_BCRx_SYNCEN_MSK     = 0x00000C00U;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const uint32_t SAIx_SAI_BCRx_MONO_MSK       = 0x00001000U;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const uint32_t SAIx_SAI_BCRx_OUTDRIV_MSK    = 0x00002000U;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const uint32_t SAIx_SAI_BCRx_SAIXEN_MSK     = 0x00010000U;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const uint32_t SAIx_SAI_BCRx_DMAEN_MSK      = 0x00020000U;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const uint32_t SAIx_SAI_BCRx_NOMCK_MSK      = 0x00080000U;   /** @brief No divider */
  static const uint32_t SAIx_SAI_BCRx_MCKDIV_MSK     = 0x00F00000U;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const uint32_t SAIx_SAI_BCRx_OSR_MSK        = 0x04000000U;   /** @brief Oversampling ratio for master clock */
  static const uint32_t SAIx_SAI_BFRCR_FRL_MSK       = 0x000000FFU;   /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const uint32_t SAIx_SAI_BFRCR_FSALL_MSK     = 0x00007F00U;   /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BFRCR_FSDEF_MSK     = 0x00010000U;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BFRCR_FSPOL_MSK     = 0x00020000U;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BFRCR_FSOFF_MSK     = 0x00040000U;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const uint32_t SAIx_SAI_BSLOTR_FBOFF_MSK    = 0x0000001FU;   /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_BSLOTR_SLOTSZ_MSK   = 0x000000C0U;   /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_BSLOTR_NBSLOT_MSK   = 0x00000F00U;   /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_BSLOTR_SLOTEN_MSK   = 0xFFFF0000U;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const uint32_t SAIx_SAI_BIM_OVRUDRIE_MSK    = 0x00000001U;   /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const uint32_t SAIx_SAI_BIM_MUTEDETIE_MSK   = 0x00000002U;   /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const uint32_t SAIx_SAI_BIM_WCKCFGIE_MSK    = 0x00000004U;   /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const uint32_t SAIx_SAI_BIM_FREQIE_MSK      = 0x00000008U;   /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const uint32_t SAIx_SAI_BIM_CNRDYIE_MSK     = 0x00000010U;   /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const uint32_t SAIx_SAI_BIM_AFSDETIE_MSK    = 0x00000020U;   /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SAIx_SAI_BIM_LFSDETIE_MSK    = 0x00000040U;   /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const uint32_t SAIx_SAI_BSR_OVRUDR_MSK      = 0x00000001U;   /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_BSR_MUTEDET_MSK     = 0x00000002U;   /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const uint32_t SAIx_SAI_BSR_WCKCFG_MSK      = 0x00000004U;   /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_BSR_FREQ_MSK        = 0x00000008U;   /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const uint32_t SAIx_SAI_BSR_CNRDY_MSK       = 0x00000010U;   /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_BSR_AFSDET_MSK      = 0x00000020U;   /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const uint32_t SAIx_SAI_BSR_LFSDET_MSK      = 0x00000040U;   /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const uint32_t SAIx_SAI_BSR_FLVL_MSK        = 0x00070000U;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const uint32_t SAIx_SAI_BCLRFR_COVRUDR_MSK  = 0x00000001U;   /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCLRFR_CMUTEDET_MSK = 0x00000002U;   /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCLRFR_CWCKCFG_MSK  = 0x00000004U;   /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCLRFR_CCNRDY_MSK   = 0x00000010U;   /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCLRFR_CAFSDET_MSK  = 0x00000020U;   /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_BCLRFR_CLFSDET_MSK  = 0x00000040U;   /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const uint32_t SAIx_SAI_PDMCR_PDMEN_MSK     = 0x00000001U;   /** @brief PDM enable */
  static const uint32_t SAIx_SAI_PDMCR_MICNBR_MSK    = 0x00000030U;   /** @brief Number of microphones */

  /**** @subsection Enumerated SAIx Register Field Masks ****/

  static const uint32_t SAIx_SAI_PDMCR_CKENx_MSK[5] = {
    [1] = 0x00000100U,   /** @brief Clock enable of bitstream clock number 1 */
    [2] = 0x00000200U,   /** @brief Clock enable of bitstream clock number 2 */
    [3] = 0x00000400U,   /** @brief Clock enable of bitstream clock number 3 */
    [4] = 0x00000800U,   /** @brief Clock enable of bitstream clock number 4 */
  };

  static const uint32_t SAIx_SAI_PDMDLY_DLYMxL_MSK[5] = {
    [1] = 0x00000007U,   /** @brief Delay line adjust for first microphone of pair 1 */
    [2] = 0x00000700U,   /** @brief Delay line for first microphone of pair 2 */
    [3] = 0x00070000U,   /** @brief Delay line for first microphone of pair 3 */
    [4] = 0x07000000U,   /** @brief Delay line for first microphone of pair 4 */
  };

  static const uint32_t SAIx_SAI_PDMDLY_DLYMxR_MSK[5] = {
    [1] = 0x00000070U,   /** @brief Delay line adjust for second microphone of pair 1 */
    [2] = 0x00007000U,   /** @brief Delay line for second microphone of pair 2 */
    [3] = 0x00700000U,   /** @brief Delay line for second microphone of pair 3 */
    [4] = 0x70000000U,   /** @brief Delay line for second microphone of pair 4 */
  };

  /**** @subsection SAIx Register Field Positions ****/

  static const int32_t SAIx_SAI_GCR_SYNCOUT_POS     = 4;    /** @brief Synchronization outputs these bits are set and cleared by software. */
  static const int32_t SAIx_SAI_GCR_SYNCIN_POS      = 0;    /** @brief Synchronization inputs */
  static const int32_t SAIx_SAI_ACRx_MODE_POS       = 0;    /** @brief SAIx audio block mode immediately */
  static const int32_t SAIx_SAI_ACRx_PRTCFG_POS     = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_ACRx_DS_POS         = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_ACRx_LSBFIRST_POS   = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const int32_t SAIx_SAI_ACRx_CKSTR_POS      = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const int32_t SAIx_SAI_ACRx_SYNCEN_POS     = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const int32_t SAIx_SAI_ACRx_MONO_POS       = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const int32_t SAIx_SAI_ACRx_OUTDRIV_POS    = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const int32_t SAIx_SAI_ACRx_SAIXEN_POS     = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const int32_t SAIx_SAI_ACRx_DMAEN_POS      = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const int32_t SAIx_SAI_ACRx_NOMCK_POS      = 19;   /** @brief No divider */
  static const int32_t SAIx_SAI_ACRx_MCKDIV_POS     = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const int32_t SAIx_SAI_ACRx_OSR_POS        = 26;   /** @brief Oversampling ratio for master clock */
  static const int32_t SAIx_SAI_AFRCR_FRL_POS       = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const int32_t SAIx_SAI_AFRCR_FSALL_POS     = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_AFRCR_FSDEF_POS     = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_AFRCR_FSPOL_POS     = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_AFRCR_FSOFF_POS     = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_ASLOTR_FBOFF_POS    = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_ASLOTR_SLOTSZ_POS   = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_ASLOTR_NBSLOT_POS   = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_ASLOTR_SLOTEN_POS   = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_AIM_OVRUDRIE_POS    = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const int32_t SAIx_SAI_AIM_MUTEDETIE_POS   = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const int32_t SAIx_SAI_AIM_WCKCFGIE_POS    = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const int32_t SAIx_SAI_AIM_FREQIE_POS      = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const int32_t SAIx_SAI_AIM_CNRDYIE_POS     = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const int32_t SAIx_SAI_AIM_AFSDETIE_POS    = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SAIx_SAI_AIM_LFSDETIE_POS    = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SAIx_SAI_ASR_OVRUDR_POS      = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_ASR_MUTEDET_POS     = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const int32_t SAIx_SAI_ASR_WCKCFG_POS      = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_ASR_FREQ_POS        = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const int32_t SAIx_SAI_ASR_CNRDY_POS       = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_ASR_AFSDET_POS      = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_ASR_LFSDET_POS      = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const int32_t SAIx_SAI_ASR_FLVL_POS        = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const int32_t SAIx_SAI_ACLRFR_COVRUDR_POS  = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_ACLRFR_CMUTEDET_POS = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_ACLRFR_CWCKCFG_POS  = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_ACLRFR_CCNRDY_POS   = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_ACLRFR_CAFSDET_POS  = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_ACLRFR_CLFSDET_POS  = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCRx_MODE_POS       = 0;    /** @brief SAIx audio block mode immediately */
  static const int32_t SAIx_SAI_BCRx_PRTCFG_POS     = 2;    /** @brief Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BCRx_DS_POS         = 5;    /** @brief Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BCRx_LSBFIRST_POS   = 8;    /** @brief Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first. */
  static const int32_t SAIx_SAI_BCRx_CKSTR_POS      = 9;    /** @brief Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol. */
  static const int32_t SAIx_SAI_BCRx_SYNCEN_POS     = 10;   /** @brief Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: the audio sub-block should be configured as asynchronous when SPDIF mode is enabled. */
  static const int32_t SAIx_SAI_BCRx_MONO_POS       = 12;   /** @brief Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to section: mono/stereo mode for more details. */
  static const int32_t SAIx_SAI_BCRx_OUTDRIV_POS    = 13;   /** @brief Output drive. This bit is set and cleared by software. Note: this bit has to be set before enabling the audio block and after the audio block configuration. */
  static const int32_t SAIx_SAI_BCRx_SAIXEN_POS     = 16;   /** @brief Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of saix audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: when saix block is configured in master mode, the clock must be present on the input of saix before setting SAIXEN bit. */
  static const int32_t SAIx_SAI_BCRx_DMAEN_POS      = 17;   /** @brief DMA enable. This bit is set and cleared by software. Note: since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode. */
  static const int32_t SAIx_SAI_BCRx_NOMCK_POS      = 19;   /** @brief No divider */
  static const int32_t SAIx_SAI_BCRx_MCKDIV_POS     = 20;   /** @brief Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula: */
  static const int32_t SAIx_SAI_BCRx_OSR_POS        = 26;   /** @brief Oversampling ratio for master clock */
  static const int32_t SAIx_SAI_BFRCR_FRL_POS       = 0;    /** @brief Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of sai_xslotr register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on mclk_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. */
  static const int32_t SAIx_SAI_BFRCR_FSALL_POS     = 8;    /** @brief Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame these bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BFRCR_FSDEF_POS     = 16;   /** @brief Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the sai_xslotr register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or msb/lsb-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BFRCR_FSPOL_POS     = 17;   /** @brief Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BFRCR_FSOFF_POS     = 18;   /** @brief Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled. */
  static const int32_t SAIx_SAI_BSLOTR_FBOFF_POS    = 0;    /** @brief First bit offset these bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_BSLOTR_SLOTSZ_POS   = 6;    /** @brief Slot size this bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to section: output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_BSLOTR_NBSLOT_POS   = 8;    /** @brief Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the sai_xfrcr register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_BSLOTR_SLOTEN_POS   = 16;   /** @brief Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode. */
  static const int32_t SAIx_SAI_BIM_OVRUDRIE_POS    = 0;    /** @brief Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the sai_xsr register is set. */
  static const int32_t SAIx_SAI_BIM_MUTEDETIE_POS   = 1;    /** @brief Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the sai_xsr register is set. This bit has a meaning only if the audio block is configured in receiver mode. */
  static const int32_t SAIx_SAI_BIM_WCKCFGIE_POS    = 2;    /** @brief Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the sai_xsr register is set. Note: this bit is used only in TDM mode and is meaningless in other modes. */
  static const int32_t SAIx_SAI_BIM_FREQIE_POS      = 3;    /** @brief FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the sai_xsr register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode, */
  static const int32_t SAIx_SAI_BIM_CNRDYIE_POS     = 4;    /** @brief Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the sai_xsr register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver. */
  static const int32_t SAIx_SAI_BIM_AFSDETIE_POS    = 5;    /** @brief Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the sai_xsr register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SAIx_SAI_BIM_LFSDETIE_POS    = 6;    /** @brief Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the sai_xsr register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master. */
  static const int32_t SAIx_SAI_BSR_OVRUDR_POS      = 0;    /** @brief Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in sai_xim register. This flag is cleared when the software sets COVRUDR bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_BSR_MUTEDET_POS     = 1;    /** @brief Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the sai_xcr2 register). It can generate an interrupt if MUTEDETIE bit is set in sai_xim register. This flag is cleared when the software sets bit CMUTEDET in the sai_xclrfr register. */
  static const int32_t SAIx_SAI_BSR_WCKCFG_POS      = 2;    /** @brief Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in sai_xim register. This flag is cleared when the software sets CWCKCFG bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_BSR_FREQ_POS        = 3;    /** @brief FIFO request. This bit is read only. The request depends on the audio block configuration: if the block is configured in transmission mode, the FIFO request is related to a write request operation in the sai_xdr. If the block configured in reception, the FIFO request related to a read request operation from the sai_xdr. This flag can generate an interrupt if FREQIE bit is set in sai_xim register. */
  static const int32_t SAIx_SAI_BSR_CNRDY_POS       = 4;    /** @brief Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in sai_xim register. This flag is cleared when the software sets CCNRDY bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_BSR_AFSDET_POS      = 5;    /** @brief Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in ac97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in sai_xim register. This flag is cleared when the software sets CAFSDET bit in sai_xclrfr register. */
  static const int32_t SAIx_SAI_BSR_LFSDET_POS      = 6;    /** @brief Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the sai_xim register. This flag is cleared when the software sets bit CLFSDET in sai_xclrfr register */
  static const int32_t SAIx_SAI_BSR_FLVL_POS        = 16;   /** @brief FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: if SAI block is configured as receiver: */
  static const int32_t SAIx_SAI_BCLRFR_COVRUDR_POS  = 0;    /** @brief Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCLRFR_CMUTEDET_POS = 1;    /** @brief Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the sai_xsr register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCLRFR_CWCKCFG_POS  = 2;    /** @brief Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the sai_xsr register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCLRFR_CCNRDY_POS   = 4;    /** @brief Clear codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the sai_xsr register. This bit is used only when the AC97 audio protocol is selected in the sai_xcr1 register. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCLRFR_CAFSDET_POS  = 5;    /** @brief Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the sai_xsr register. It is not used in ac97or SPDIF mode. Reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_BCLRFR_CLFSDET_POS  = 6;    /** @brief Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the sai_xsr register. This bit is not used in ac97or SPDIF mode reading this bit always returns the value 0. */
  static const int32_t SAIx_SAI_PDMCR_PDMEN_POS     = 0;    /** @brief PDM enable */
  static const int32_t SAIx_SAI_PDMCR_MICNBR_POS    = 4;    /** @brief Number of microphones */

  /**** @subsection Enumerated SAIx Register Field Positions ****/

  static const int32_t SAIx_SAI_PDMCR_CKENx_POS[5] = {
    [1] = 8,    /** @brief Clock enable of bitstream clock number 1 */
    [2] = 9,    /** @brief Clock enable of bitstream clock number 2 */
    [3] = 10,   /** @brief Clock enable of bitstream clock number 3 */
    [4] = 11,   /** @brief Clock enable of bitstream clock number 4 */
  };

  static const int32_t SAIx_SAI_PDMDLY_DLYMxL_POS[5] = {
    [1] = 0,    /** @brief Delay line adjust for first microphone of pair 1 */
    [2] = 8,    /** @brief Delay line for first microphone of pair 2 */
    [3] = 16,   /** @brief Delay line for first microphone of pair 3 */
    [4] = 24,   /** @brief Delay line for first microphone of pair 4 */
  };

  static const int32_t SAIx_SAI_PDMDLY_DLYMxR_POS[5] = {
    [1] = 4,    /** @brief Delay line adjust for second microphone of pair 1 */
    [2] = 12,   /** @brief Delay line for second microphone of pair 2 */
    [3] = 20,   /** @brief Delay line for second microphone of pair 3 */
    [4] = 28,   /** @brief Delay line for second microphone of pair 4 */
  };

  /**********************************************************************************************
   * @section SDMMCx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated SDMMCx Register Pointers ****/

  static RW_ uint32_t* const SDMMCx_POWER_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007000U,   /** @brief SDMMC power control register */
    [2] = (RW_ uint32_t* const)0x48022400U,   /** @brief SDMMC power control register */
  };

  static RW_ uint32_t* const SDMMCx_CLKCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007004U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
    [2] = (RW_ uint32_t* const)0x48022404U,   /** @brief The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width. */
  };

  static RW_ uint32_t* const SDMMCx_ARGR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007008U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
    [2] = (RW_ uint32_t* const)0x48022408U,   /** @brief The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message. */
  };

  static RW_ uint32_t* const SDMMCx_CMDR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200700CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
    [2] = (RW_ uint32_t* const)0x4802240CU,   /** @brief The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM). */
  };

  static RO_ uint32_t* const SDMMCx_RESPxR_PTR[3][5] = {
    [0] = {
      [1] = (RO_ uint32_t* const)0x52007014U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [2] = (RO_ uint32_t* const)0x52007018U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [3] = (RO_ uint32_t* const)0x5200701CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [4] = (RO_ uint32_t* const)0x52007020U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
    },
    [1] = {
      [1] = (RO_ uint32_t* const)0x48022414U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [2] = (RO_ uint32_t* const)0x48022418U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [3] = (RO_ uint32_t* const)0x4802241CU,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
      [4] = (RO_ uint32_t* const)0x48022420U,   /** @brief The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response. */
    },
  };

  static RW_ uint32_t* const SDMMCx_DTIMER_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007024U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
    [2] = (RW_ uint32_t* const)0x48022424U,   /** @brief The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_r or busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set. */
  };

  static RW_ uint32_t* const SDMMCx_DLENR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007028U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
    [2] = (RW_ uint32_t* const)0x48022428U,   /** @brief The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts. */
  };

  static RW_ uint32_t* const SDMMCx_DCTRL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200702CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
    [2] = (RW_ uint32_t* const)0x4802242CU,   /** @brief The SDMMC_DCTRL register control the data path state machine (DPSM). */
  };

  static RO_ uint32_t* const SDMMCx_DCNTR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52007030U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
    [2] = (RO_ uint32_t* const)0x48022430U,   /** @brief The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the idle state to the wait_r or wait_s state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the idle state and when there has been no error, the data status end flag (DATAEND) is set. */
  };

  static RO_ uint32_t* const SDMMCx_STAR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52007034U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
    [2] = (RO_ uint32_t* const)0x48022434U,   /** @brief The SDMMC_STAR register is a read-only register. It contains two types of flag:static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt clear register (see sdmmc_icr)dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO) */
  };

  static RW_ uint32_t* const SDMMCx_ICR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007038U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
    [2] = (RW_ uint32_t* const)0x48022438U,   /** @brief The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register. */
  };

  static RW_ uint32_t* const SDMMCx_MASKR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200703CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
    [2] = (RW_ uint32_t* const)0x4802243CU,   /** @brief The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1. */
  };

  static RW_ uint32_t* const SDMMCx_ACKTIMER_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007040U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
    [2] = (RW_ uint32_t* const)0x48022440U,   /** @brief The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the wait_ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set. */
  };

  static RW_ uint32_t* const SDMMCx_IDMACTRLR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007050U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
    [2] = (RW_ uint32_t* const)0x48022450U,   /** @brief The receive and transmit fifos can be read or written as 32-bit wide registers. The fifos contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO. */
  };

  static RW_ uint32_t* const SDMMCx_IDMABSIZER_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007054U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
    [2] = (RW_ uint32_t* const)0x48022454U,   /** @brief The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration. */
  };

  static RW_ uint32_t* const SDMMCx_IDMABASExR_PTR[3][2] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x52007058U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
      [1] = (RW_ uint32_t* const)0x5200705CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x48022458U,   /** @brief The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration. */
      [1] = (RW_ uint32_t* const)0x4802245CU,   /** @brief The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address. */
    },
  };

  static RW_ uint32_t* const SDMMCx_FIFOR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52007080U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
    [2] = (RW_ uint32_t* const)0x48022480U,   /** @brief The receive and transmit fifos can be only read or written as word (32-bit) wide registers. The fifos contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the fifo.when accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated. */
  };

  static RO_ uint32_t* const SDMMCx_RESPCMDR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52007010U,   /** @brief SDMMC command response register */
    [2] = (RO_ uint32_t* const)0x48022410U,   /** @brief SDMMC command response register */
  };

  /**** @subsection SDMMCx Register Field Masks ****/

  static const uint32_t SDMMCx_POWER_PWRCTRL_MSK       = 0x00000003U;   /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
  static const uint32_t SDMMCx_POWER_VSWITCH_MSK       = 0x00000004U;   /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
  static const uint32_t SDMMCx_POWER_VSWITCHEN_MSK     = 0x00000008U;   /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
  static const uint32_t SDMMCx_POWER_DIRPOL_MSK        = 0x00000010U;   /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
  static const uint32_t SDMMCx_CLKCR_CLKDIV_MSK        = 0x000003FFU;   /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
  static const uint32_t SDMMCx_CLKCR_PWRSAV_MSK        = 0x00001000U;   /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
  static const uint32_t SDMMCx_CLKCR_WIDBUS_MSK        = 0x0000C000U;   /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const uint32_t SDMMCx_CLKCR_NEGEDGE_MSK       = 0x00010000U;   /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
  static const uint32_t SDMMCx_CLKCR_HWFC_EN_MSK       = 0x00020000U;   /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
  static const uint32_t SDMMCx_CLKCR_DDR_MSK           = 0x00040000U;   /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
  static const uint32_t SDMMCx_CLKCR_BUSSPEED_MSK      = 0x00080000U;   /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const uint32_t SDMMCx_CLKCR_SELCLKRX_MSK      = 0x00300000U;   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const uint32_t SDMMCx_CMDR_CMDINDEX_MSK       = 0x0000003FU;   /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
  static const uint32_t SDMMCx_CMDR_CMDTRANS_MSK       = 0x00000040U;   /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
  static const uint32_t SDMMCx_CMDR_CMDSTOP_MSK        = 0x00000080U;   /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
  static const uint32_t SDMMCx_CMDR_WAITRESP_MSK       = 0x00000300U;   /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
  static const uint32_t SDMMCx_CMDR_WAITINT_MSK        = 0x00000400U;   /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
  static const uint32_t SDMMCx_CMDR_WAITPEND_MSK       = 0x00000800U;   /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
  static const uint32_t SDMMCx_CMDR_CPSMEN_MSK         = 0x00001000U;   /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
  static const uint32_t SDMMCx_CMDR_DTHOLD_MSK         = 0x00002000U;   /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
  static const uint32_t SDMMCx_CMDR_BOOTMODE_MSK       = 0x00004000U;   /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
  static const uint32_t SDMMCx_CMDR_BOOTEN_MSK         = 0x00008000U;   /** @brief Enable boot mode procedure. */
  static const uint32_t SDMMCx_CMDR_CMDSUSPEND_MSK     = 0x00010000U;   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
  static const uint32_t SDMMCx_DLENR_DATALENGTH_MSK    = 0x01FFFFFFU;   /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
  static const uint32_t SDMMCx_DCTRL_DTEN_MSK          = 0x00000001U;   /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
  static const uint32_t SDMMCx_DCTRL_DTDIR_MSK         = 0x00000002U;   /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_DCTRL_DTMODE_MSK        = 0x0000000CU;   /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_DCTRL_DBLOCKSIZE_MSK    = 0x000000F0U;   /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
  static const uint32_t SDMMCx_DCTRL_RWSTART_MSK       = 0x00000100U;   /** @brief Read wait start. If this bit is set, read wait operation starts. */
  static const uint32_t SDMMCx_DCTRL_RWSTOP_MSK        = 0x00000200U;   /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
  static const uint32_t SDMMCx_DCTRL_RWMOD_MSK         = 0x00000400U;   /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_DCTRL_SDIOEN_MSK        = 0x00000800U;   /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
  static const uint32_t SDMMCx_DCTRL_BOOTACKEN_MSK     = 0x00001000U;   /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_DCTRL_FIFORST_MSK       = 0x00002000U;   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
  static const uint32_t SDMMCx_DCNTR_DATACOUNT_MSK     = 0x01FFFFFFU;   /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
  static const uint32_t SDMMCx_STAR_CCRCFAIL_MSK       = 0x00000001U;   /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DCRCFAIL_MSK       = 0x00000002U;   /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_CTIMEOUT_MSK       = 0x00000004U;   /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
  static const uint32_t SDMMCx_STAR_DTIMEOUT_MSK       = 0x00000008U;   /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_TXUNDERR_MSK       = 0x00000010U;   /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_RXOVERR_MSK        = 0x00000020U;   /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_CMDREND_MSK        = 0x00000040U;   /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_CMDSENT_MSK        = 0x00000080U;   /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DATAEND_MSK        = 0x00000100U;   /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DHOLD_MSK          = 0x00000200U;   /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DBCKEND_MSK        = 0x00000400U;   /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DABORT_MSK         = 0x00000800U;   /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_DPSMACT_MSK        = 0x00001000U;   /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const uint32_t SDMMCx_STAR_CPSMACT_MSK        = 0x00002000U;   /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const uint32_t SDMMCx_STAR_TXFIFOHE_MSK       = 0x00004000U;   /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
  static const uint32_t SDMMCx_STAR_RXFIFOHF_MSK       = 0x00008000U;   /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
  static const uint32_t SDMMCx_STAR_TXFIFOF_MSK        = 0x00010000U;   /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
  static const uint32_t SDMMCx_STAR_RXFIFOF_MSK        = 0x00020000U;   /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
  static const uint32_t SDMMCx_STAR_TXFIFOE_MSK        = 0x00040000U;   /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
  static const uint32_t SDMMCx_STAR_RXFIFOE_MSK        = 0x00080000U;   /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
  static const uint32_t SDMMCx_STAR_BUSYD0_MSK         = 0x00100000U;   /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
  static const uint32_t SDMMCx_STAR_BUSYD0END_MSK      = 0x00200000U;   /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_SDIOIT_MSK         = 0x00400000U;   /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_ACKFAIL_MSK        = 0x00800000U;   /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_ACKTIMEOUT_MSK     = 0x01000000U;   /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_VSWEND_MSK         = 0x02000000U;   /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_CKSTOP_MSK         = 0x04000000U;   /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_IDMATE_MSK         = 0x08000000U;   /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_STAR_IDMABTC_MSK        = 0x10000000U;   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const uint32_t SDMMCx_ICR_CCRCFAILC_MSK       = 0x00000001U;   /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
  static const uint32_t SDMMCx_ICR_DCRCFAILC_MSK       = 0x00000002U;   /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
  static const uint32_t SDMMCx_ICR_CTIMEOUTC_MSK       = 0x00000004U;   /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
  static const uint32_t SDMMCx_ICR_DTIMEOUTC_MSK       = 0x00000008U;   /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
  static const uint32_t SDMMCx_ICR_TXUNDERRC_MSK       = 0x00000010U;   /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
  static const uint32_t SDMMCx_ICR_RXOVERRC_MSK        = 0x00000020U;   /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
  static const uint32_t SDMMCx_ICR_CMDRENDC_MSK        = 0x00000040U;   /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
  static const uint32_t SDMMCx_ICR_CMDSENTC_MSK        = 0x00000080U;   /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
  static const uint32_t SDMMCx_ICR_DATAENDC_MSK        = 0x00000100U;   /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
  static const uint32_t SDMMCx_ICR_DHOLDC_MSK          = 0x00000200U;   /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
  static const uint32_t SDMMCx_ICR_DBCKENDC_MSK        = 0x00000400U;   /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
  static const uint32_t SDMMCx_ICR_DABORTC_MSK         = 0x00000800U;   /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
  static const uint32_t SDMMCx_ICR_BUSYD0ENDC_MSK      = 0x00200000U;   /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
  static const uint32_t SDMMCx_ICR_SDIOITC_MSK         = 0x00400000U;   /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
  static const uint32_t SDMMCx_ICR_ACKFAILC_MSK        = 0x00800000U;   /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
  static const uint32_t SDMMCx_ICR_ACKTIMEOUTC_MSK     = 0x01000000U;   /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
  static const uint32_t SDMMCx_ICR_VSWENDC_MSK         = 0x02000000U;   /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
  static const uint32_t SDMMCx_ICR_CKSTOPC_MSK         = 0x04000000U;   /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
  static const uint32_t SDMMCx_ICR_IDMATEC_MSK         = 0x08000000U;   /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
  static const uint32_t SDMMCx_ICR_IDMABTCC_MSK        = 0x10000000U;   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
  static const uint32_t SDMMCx_MASKR_CCRCFAILIE_MSK    = 0x00000001U;   /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
  static const uint32_t SDMMCx_MASKR_DCRCFAILIE_MSK    = 0x00000002U;   /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
  static const uint32_t SDMMCx_MASKR_CTIMEOUTIE_MSK    = 0x00000004U;   /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
  static const uint32_t SDMMCx_MASKR_DTIMEOUTIE_MSK    = 0x00000008U;   /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
  static const uint32_t SDMMCx_MASKR_TXUNDERRIE_MSK    = 0x00000010U;   /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
  static const uint32_t SDMMCx_MASKR_RXOVERRIE_MSK     = 0x00000020U;   /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
  static const uint32_t SDMMCx_MASKR_CMDRENDIE_MSK     = 0x00000040U;   /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
  static const uint32_t SDMMCx_MASKR_CMDSENTIE_MSK     = 0x00000080U;   /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
  static const uint32_t SDMMCx_MASKR_DATAENDIE_MSK     = 0x00000100U;   /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
  static const uint32_t SDMMCx_MASKR_DHOLDIE_MSK       = 0x00000200U;   /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
  static const uint32_t SDMMCx_MASKR_DBCKENDIE_MSK     = 0x00000400U;   /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
  static const uint32_t SDMMCx_MASKR_DABORTIE_MSK      = 0x00000800U;   /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
  static const uint32_t SDMMCx_MASKR_TXFIFOHEIE_MSK    = 0x00004000U;   /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
  static const uint32_t SDMMCx_MASKR_RXFIFOHFIE_MSK    = 0x00008000U;   /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
  static const uint32_t SDMMCx_MASKR_RXFIFOFIE_MSK     = 0x00020000U;   /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
  static const uint32_t SDMMCx_MASKR_TXFIFOEIE_MSK     = 0x00040000U;   /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
  static const uint32_t SDMMCx_MASKR_BUSYD0ENDIE_MSK   = 0x00200000U;   /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
  static const uint32_t SDMMCx_MASKR_SDIOITIE_MSK      = 0x00400000U;   /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
  static const uint32_t SDMMCx_MASKR_ACKFAILIE_MSK     = 0x00800000U;   /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
  static const uint32_t SDMMCx_MASKR_ACKTIMEOUTIE_MSK  = 0x01000000U;   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
  static const uint32_t SDMMCx_MASKR_VSWENDIE_MSK      = 0x02000000U;   /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
  static const uint32_t SDMMCx_MASKR_CKSTOPIE_MSK      = 0x04000000U;   /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
  static const uint32_t SDMMCx_MASKR_IDMABTCIE_MSK     = 0x10000000U;   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
  static const uint32_t SDMMCx_ACKTIMER_ACKTIME_MSK    = 0x01FFFFFFU;   /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
  static const uint32_t SDMMCx_IDMACTRLR_IDMAEN_MSK    = 0x00000001U;   /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_IDMACTRLR_IDMABMODE_MSK = 0x00000002U;   /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_IDMACTRLR_IDMABACT_MSK  = 0x00000004U;   /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
  static const uint32_t SDMMCx_IDMABSIZER_IDMABNDT_MSK = 0x00001FE0U;   /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const uint32_t SDMMCx_RESPCMDR_RESPCMD_MSK    = 0x0000003FU;   /** @brief Response command index */

  /**** @subsection SDMMCx Register Field Positions ****/

  static const int32_t SDMMCx_POWER_PWRCTRL_POS       = 0;    /** @brief SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: any further write will be ignored, PWRCTRL value will keep 11. */
  static const int32_t SDMMCx_POWER_VSWITCH_POS       = 2;    /** @brief Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence: */
  static const int32_t SDMMCx_POWER_VSWITCHEN_POS     = 3;    /** @brief Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response: */
  static const int32_t SDMMCx_POWER_DIRPOL_POS        = 4;    /** @brief Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00). */
  static const int32_t SDMMCx_CLKCR_CLKDIV_POS        = 0;    /** @brief Clock divide factor this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. Xxx: etc.. */
  static const int32_t SDMMCx_CLKCR_PWRSAV_POS        = 12;   /** @brief Power saving configuration bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) for power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV: */
  static const int32_t SDMMCx_CLKCR_WIDBUS_POS        = 14;   /** @brief Wide bus mode enable bit this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const int32_t SDMMCx_CLKCR_NEGEDGE_POS       = 16;   /** @brief SDMMC_CK dephasing selection bit for data and command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. */
  static const int32_t SDMMCx_CLKCR_HWFC_EN_POS       = 17;   /** @brief Hardware flow control enable this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) when hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in section56.8.11. */
  static const int32_t SDMMCx_CLKCR_DDR_POS           = 18;   /** @brief Data rate signaling selection this bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0) */
  static const int32_t SDMMCx_CLKCR_BUSSPEED_POS      = 19;   /** @brief Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const int32_t SDMMCx_CLKCR_SELCLKRX_POS      = 20;   /** @brief Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) */
  static const int32_t SDMMCx_CMDR_CMDINDEX_POS       = 0;    /** @brief Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message. */
  static const int32_t SDMMCx_CMDR_CMDTRANS_POS       = 6;    /** @brief The CPSM treats the command as a data transfer command, stops the interrupt period, and signals dataenable to the DPSM this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues dataenable signal to the DPSM when the command is sent. */
  static const int32_t SDMMCx_CMDR_CMDSTOP_POS        = 7;    /** @brief The CPSM treats the command as a stop transmission command and signals abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the abort signal to the DPSM when the command is sent. */
  static const int32_t SDMMCx_CMDR_WAITRESP_POS       = 8;    /** @brief Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response. */
  static const int32_t SDMMCx_CMDR_WAITINT_POS        = 10;   /** @brief CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (response). If this bit is cleared in the CPSM wait state, will cause the abort of the interrupt mode. */
  static const int32_t SDMMCx_CMDR_WAITPEND_POS       = 11;   /** @brief CPSM waits for end of data transfer (cmdpend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card. */
  static const int32_t SDMMCx_CMDR_CPSMEN_POS         = 12;   /** @brief Command path state machine (CPSM) enable bit this bit is written 1 by firmware, and cleared by hardware when the CPSM enters the idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0. */
  static const int32_t SDMMCx_CMDR_DTHOLD_POS         = 13;   /** @brief Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the wait_s state to the send state or from the wait_r state to the receive state. */
  static const int32_t SDMMCx_CMDR_BOOTMODE_POS       = 14;   /** @brief Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0) */
  static const int32_t SDMMCx_CMDR_BOOTEN_POS         = 15;   /** @brief Enable boot mode procedure. */
  static const int32_t SDMMCx_CMDR_CMDSUSPEND_POS     = 16;   /** @brief The CPSM treats the command as a suspend or resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 resume command with data, end interrupt period when response bit DF=1. */
  static const int32_t SDMMCx_DLENR_DATALENGTH_POS    = 0;    /** @brief Data length value this register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) when DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0. */
  static const int32_t SDMMCx_DCTRL_DTEN_POS          = 0;    /** @brief Data transfer enable bit this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. Shall not be used with SD or emmc cards. */
  static const int32_t SDMMCx_DCTRL_DTDIR_POS         = 1;    /** @brief Data transfer direction selection this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_DCTRL_DTMODE_POS        = 2;    /** @brief Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_DCTRL_DBLOCKSIZE_POS    = 4;    /** @brief Data block size this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: when DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) when DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered) */
  static const int32_t SDMMCx_DCTRL_RWSTART_POS       = 8;    /** @brief Read wait start. If this bit is set, read wait operation starts. */
  static const int32_t SDMMCx_DCTRL_RWSTOP_POS        = 9;    /** @brief Read wait stop this bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state. */
  static const int32_t SDMMCx_DCTRL_RWMOD_POS         = 10;   /** @brief Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_DCTRL_SDIOEN_POS        = 11;   /** @brief SD I/O interrupt enable functions this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation. */
  static const int32_t SDMMCx_DCTRL_BOOTACKEN_POS     = 12;   /** @brief Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_DCTRL_FIFORST_POS       = 13;   /** @brief FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs. */
  static const int32_t SDMMCx_DCNTR_DATACOUNT_POS     = 0;    /** @brief Data count value when read, the number of remaining data bytes to be transferred is returned. Write has no effect. */
  static const int32_t SDMMCx_STAR_CCRCFAIL_POS       = 0;    /** @brief Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DCRCFAIL_POS       = 1;    /** @brief Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_CTIMEOUT_POS       = 2;    /** @brief Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The command timeout period has a fixed value of 64 SDMMC_CK clock periods. */
  static const int32_t SDMMCx_STAR_DTIMEOUT_POS       = 3;    /** @brief Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_TXUNDERR_POS       = 4;    /** @brief Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_RXOVERR_POS        = 5;    /** @brief Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_CMDREND_POS        = 6;    /** @brief Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_CMDSENT_POS        = 7;    /** @brief Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DATAEND_POS        = 8;    /** @brief Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DHOLD_POS          = 9;    /** @brief Data transfer hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DBCKEND_POS        = 10;   /** @brief Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DABORT_POS         = 11;   /** @brief Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_DPSMACT_POS        = 12;   /** @brief Data path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const int32_t SDMMCx_STAR_CPSMACT_POS        = 13;   /** @brief Command path state machine active, i.e. Not in idle state. This is a hardware status flag only, does not generate an interrupt. */
  static const int32_t SDMMCx_STAR_TXFIFOHE_POS       = 14;   /** @brief Transmit FIFO half empty at least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full. */
  static const int32_t SDMMCx_STAR_RXFIFOHF_POS       = 15;   /** @brief Receive FIFO half full there are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty. */
  static const int32_t SDMMCx_STAR_TXFIFOF_POS        = 16;   /** @brief Transmit FIFO full this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty. */
  static const int32_t SDMMCx_STAR_RXFIFOF_POS        = 17;   /** @brief Receive FIFO full this bit is cleared when one FIFO location becomes empty. */
  static const int32_t SDMMCx_STAR_TXFIFOE_POS        = 18;   /** @brief Transmit FIFO empty this bit is cleared when one FIFO location becomes full. */
  static const int32_t SDMMCx_STAR_RXFIFOE_POS        = 19;   /** @brief Receive FIFO empty this is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full. */
  static const int32_t SDMMCx_STAR_BUSYD0_POS         = 20;   /** @brief Inverted value of SDMMC_D0 line (busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt. */
  static const int32_t SDMMCx_STAR_BUSYD0END_POS      = 21;   /** @brief End of SDMMC_D0 busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_SDIOIT_POS         = 22;   /** @brief SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_ACKFAIL_POS        = 23;   /** @brief Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_ACKTIMEOUT_POS     = 24;   /** @brief Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_VSWEND_POS         = 25;   /** @brief Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_CKSTOP_POS         = 26;   /** @brief SDMMC_CK stopped in voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_IDMATE_POS         = 27;   /** @brief IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_STAR_IDMABTC_POS        = 28;   /** @brief IDMA buffer transfer complete. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. */
  static const int32_t SDMMCx_ICR_CCRCFAILC_POS       = 0;    /** @brief CCRCFAIL flag clear bit set by software to clear the CCRCFAIL flag. */
  static const int32_t SDMMCx_ICR_DCRCFAILC_POS       = 1;    /** @brief DCRCFAIL flag clear bit set by software to clear the DCRCFAIL flag. */
  static const int32_t SDMMCx_ICR_CTIMEOUTC_POS       = 2;    /** @brief CTIMEOUT flag clear bit set by software to clear the CTIMEOUT flag. */
  static const int32_t SDMMCx_ICR_DTIMEOUTC_POS       = 3;    /** @brief DTIMEOUT flag clear bit set by software to clear the DTIMEOUT flag. */
  static const int32_t SDMMCx_ICR_TXUNDERRC_POS       = 4;    /** @brief TXUNDERR flag clear bit set by software to clear TXUNDERR flag. */
  static const int32_t SDMMCx_ICR_RXOVERRC_POS        = 5;    /** @brief RXOVERR flag clear bit set by software to clear the RXOVERR flag. */
  static const int32_t SDMMCx_ICR_CMDRENDC_POS        = 6;    /** @brief CMDREND flag clear bit set by software to clear the CMDREND flag. */
  static const int32_t SDMMCx_ICR_CMDSENTC_POS        = 7;    /** @brief CMDSENT flag clear bit set by software to clear the CMDSENT flag. */
  static const int32_t SDMMCx_ICR_DATAENDC_POS        = 8;    /** @brief DATAEND flag clear bit set by software to clear the DATAEND flag. */
  static const int32_t SDMMCx_ICR_DHOLDC_POS          = 9;    /** @brief DHOLD flag clear bit set by software to clear the DHOLD flag. */
  static const int32_t SDMMCx_ICR_DBCKENDC_POS        = 10;   /** @brief DBCKEND flag clear bit set by software to clear the DBCKEND flag. */
  static const int32_t SDMMCx_ICR_DABORTC_POS         = 11;   /** @brief DABORT flag clear bit set by software to clear the DABORT flag. */
  static const int32_t SDMMCx_ICR_BUSYD0ENDC_POS      = 21;   /** @brief BUSYD0END flag clear bit set by software to clear the BUSYD0END flag. */
  static const int32_t SDMMCx_ICR_SDIOITC_POS         = 22;   /** @brief SDIOIT flag clear bit set by software to clear the SDIOIT flag. */
  static const int32_t SDMMCx_ICR_ACKFAILC_POS        = 23;   /** @brief ACKFAIL flag clear bit set by software to clear the ACKFAIL flag. */
  static const int32_t SDMMCx_ICR_ACKTIMEOUTC_POS     = 24;   /** @brief ACKTIMEOUT flag clear bit set by software to clear the ACKTIMEOUT flag. */
  static const int32_t SDMMCx_ICR_VSWENDC_POS         = 25;   /** @brief VSWEND flag clear bit set by software to clear the VSWEND flag. */
  static const int32_t SDMMCx_ICR_CKSTOPC_POS         = 26;   /** @brief CKSTOP flag clear bit set by software to clear the CKSTOP flag. */
  static const int32_t SDMMCx_ICR_IDMATEC_POS         = 27;   /** @brief IDMA transfer error clear bit set by software to clear the IDMATE flag. */
  static const int32_t SDMMCx_ICR_IDMABTCC_POS        = 28;   /** @brief IDMA buffer transfer complete clear bit set by software to clear the IDMABTC flag. */
  static const int32_t SDMMCx_MASKR_CCRCFAILIE_POS    = 0;    /** @brief Command CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by command CRC failure. */
  static const int32_t SDMMCx_MASKR_DCRCFAILIE_POS    = 1;    /** @brief Data CRC fail interrupt enable set and cleared by software to enable/disable interrupt caused by data CRC failure. */
  static const int32_t SDMMCx_MASKR_CTIMEOUTIE_POS    = 2;    /** @brief Command timeout interrupt enable set and cleared by software to enable/disable interrupt caused by command timeout. */
  static const int32_t SDMMCx_MASKR_DTIMEOUTIE_POS    = 3;    /** @brief Data timeout interrupt enable set and cleared by software to enable/disable interrupt caused by data timeout. */
  static const int32_t SDMMCx_MASKR_TXUNDERRIE_POS    = 4;    /** @brief Tx FIFO underrun error interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO underrun error. */
  static const int32_t SDMMCx_MASKR_RXOVERRIE_POS     = 5;    /** @brief Rx FIFO overrun error interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO overrun error. */
  static const int32_t SDMMCx_MASKR_CMDRENDIE_POS     = 6;    /** @brief Command response received interrupt enable set and cleared by software to enable/disable interrupt caused by receiving command response. */
  static const int32_t SDMMCx_MASKR_CMDSENTIE_POS     = 7;    /** @brief Command sent interrupt enable set and cleared by software to enable/disable interrupt caused by sending command. */
  static const int32_t SDMMCx_MASKR_DATAENDIE_POS     = 8;    /** @brief Data end interrupt enable set and cleared by software to enable/disable interrupt caused by data end. */
  static const int32_t SDMMCx_MASKR_DHOLDIE_POS       = 9;    /** @brief Data hold interrupt enable set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM wait_s state. */
  static const int32_t SDMMCx_MASKR_DBCKENDIE_POS     = 10;   /** @brief Data block end interrupt enable set and cleared by software to enable/disable interrupt caused by data block end. */
  static const int32_t SDMMCx_MASKR_DABORTIE_POS      = 11;   /** @brief Data transfer aborted interrupt enable set and cleared by software to enable/disable interrupt caused by a data transfer being aborted. */
  static const int32_t SDMMCx_MASKR_TXFIFOHEIE_POS    = 14;   /** @brief Tx FIFO half empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO half empty. */
  static const int32_t SDMMCx_MASKR_RXFIFOHFIE_POS    = 15;   /** @brief Rx FIFO half full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO half full. */
  static const int32_t SDMMCx_MASKR_RXFIFOFIE_POS     = 17;   /** @brief Rx FIFO full interrupt enable set and cleared by software to enable/disable interrupt caused by rx FIFO full. */
  static const int32_t SDMMCx_MASKR_TXFIFOEIE_POS     = 18;   /** @brief Tx FIFO empty interrupt enable set and cleared by software to enable/disable interrupt caused by tx FIFO empty. */
  static const int32_t SDMMCx_MASKR_BUSYD0ENDIE_POS   = 21;   /** @brief BUSYD0END interrupt enable set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response. */
  static const int32_t SDMMCx_MASKR_SDIOITIE_POS      = 22;   /** @brief SDIO mode interrupt received interrupt enable set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt. */
  static const int32_t SDMMCx_MASKR_ACKFAILIE_POS     = 23;   /** @brief Acknowledgment fail interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment fail. */
  static const int32_t SDMMCx_MASKR_ACKTIMEOUTIE_POS  = 24;   /** @brief Acknowledgment timeout interrupt enable set and cleared by software to enable/disable interrupt caused by acknowledgment timeout. */
  static const int32_t SDMMCx_MASKR_VSWENDIE_POS      = 25;   /** @brief Voltage switch critical timing section completion interrupt enable set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion. */
  static const int32_t SDMMCx_MASKR_CKSTOPIE_POS      = 26;   /** @brief Voltage switch clock stopped interrupt enable set and cleared by software to enable/disable interrupt caused by voltage switch clock stopped. */
  static const int32_t SDMMCx_MASKR_IDMABTCIE_POS     = 28;   /** @brief IDMA buffer transfer complete interrupt enable set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer. */
  static const int32_t SDMMCx_ACKTIMER_ACKTIME_POS    = 0;    /** @brief Boot acknowledgment timeout period this bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods. */
  static const int32_t SDMMCx_IDMACTRLR_IDMAEN_POS    = 0;    /** @brief IDMA enable this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_IDMACTRLR_IDMABMODE_POS = 1;    /** @brief Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_IDMACTRLR_IDMABACT_POS  = 2;    /** @brief Double buffer mode active buffer indication this bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware. */
  static const int32_t SDMMCx_IDMABSIZER_IDMABNDT_POS = 5;    /** @brief Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0). */
  static const int32_t SDMMCx_RESPCMDR_RESPCMD_POS    = 0;    /** @brief Response command index */

  /**********************************************************************************************
   * @section VREFBUF Register Information
   **********************************************************************************************/

  /**** @subsection VREFBUF Register Pointers ****/

  static RW_ uint32_t* const VREFBUF_CSR_PTR = (RW_ uint32_t* const)0x58003C00U;   /** @brief VREFBUF control and status register */
  static RW_ uint32_t* const VREFBUF_CCR_PTR = (RW_ uint32_t* const)0x58003C04U;   /** @brief VREFBUF calibration control register */

  /**** @subsection VREFBUF Register Field Masks ****/

  static const uint32_t VREFBUF_CSR_ENVR_MSK = 0x00000001U;   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
  static const uint32_t VREFBUF_CSR_HIZ_MSK  = 0x00000002U;   /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
  static const uint32_t VREFBUF_CSR_VRR_MSK  = 0x00000008U;   /** @brief Voltage reference buffer ready */
  static const uint32_t VREFBUF_CSR_VRS_MSK  = 0x00000070U;   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
  static const uint32_t VREFBUF_CCR_TRIM_MSK = 0x0000003FU;   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

  /**** @subsection VREFBUF Register Field Positions ****/

  static const int32_t VREFBUF_CSR_ENVR_POS = 0;   /** @brief Voltage reference buffer mode enable this bit is used to enable the voltage reference buffer mode. */
  static const int32_t VREFBUF_CSR_HIZ_POS  = 1;   /** @brief High impedance mode this bit controls the analog switch to connect or not the VREF+ pin. Refer to table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration. */
  static const int32_t VREFBUF_CSR_VRR_POS  = 3;   /** @brief Voltage reference buffer ready */
  static const int32_t VREFBUF_CSR_VRS_POS  = 4;   /** @brief Voltage reference scale these bits select the value generated by the voltage reference buffer. Other: reserved */
  static const int32_t VREFBUF_CCR_TRIM_POS = 0;   /** @brief Trimming code these bits are automatically initialized after reset with the trimming value stored in the flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */

  /**********************************************************************************************
   * @section xWDG1 Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated xWDG1 Register Pointers ****/

  static WO_ uint32_t* const xWDG1_KR_PTR[23] = {
    [8]  = (WO_ uint32_t* const)0x58004800U,   /** @brief Key register */
    [22] = (WO_ uint32_t* const)0x50003000U,   /** @brief Control register */
  };

  static RW_ uint32_t* const xWDG1_PR_PTR[23] = {
    [8]  = (RW_ uint32_t* const)0x58004804U,   /** @brief Prescaler register */
    [22] = (RW_ uint32_t* const)0x50003004U,   /** @brief Configuration register */
  };

  static RW_ uint32_t* const xWDG1_RLR_PTR[23] = {
    [8]  = (RW_ uint32_t* const)0x58004808U,   /** @brief Reload register */
    [22] = (RW_ uint32_t* const)0x50003008U,   /** @brief Status register */
  };

  static RO_ uint32_t* const xWDG1_SR_PTR[23] = {
    [8]  = (RO_ uint32_t* const)0x5800480CU,   /** @brief Status register */
  };

  static RW_ uint32_t* const xWDG1_WINR_PTR[23] = {
    [8]  = (RW_ uint32_t* const)0x58004810U,   /** @brief Window register */
  };

  /**** @subsection xWDG1 Register Field Masks ****/

  static const uint32_t xWDG1_KR_KEY_MSK   = 0x0000FFFFU;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
  static const uint32_t xWDG1_PR_PR_MSK    = 0x00000007U;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
  static const uint32_t xWDG1_RLR_RL_MSK   = 0x00000FFFU;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
  static const uint32_t xWDG1_SR_PVU_MSK   = 0x00000001U;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
  static const uint32_t xWDG1_SR_RVU_MSK   = 0x00000002U;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
  static const uint32_t xWDG1_SR_WVU_MSK   = 0x00000004U;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
  static const uint32_t xWDG1_WINR_WIN_MSK = 0x00000FFFU;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

  /**** @subsection xWDG1 Register Field Positions ****/

  static const int32_t xWDG1_KR_KEY_POS   = 0;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
  static const int32_t xWDG1_PR_PR_POS    = 0;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
  static const int32_t xWDG1_RLR_RL_POS   = 0;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
  static const int32_t xWDG1_SR_PVU_POS   = 0;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
  static const int32_t xWDG1_SR_RVU_POS   = 1;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
  static const int32_t xWDG1_SR_WVU_POS   = 2;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
  static const int32_t xWDG1_WINR_WIN_POS = 0;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

  /**********************************************************************************************
   * @section IWDGx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated IWDGx Register Pointers ****/

  static WO_ uint32_t* const IWDGx_KR_PTR[3] = {
    [2] = (WO_ uint32_t* const)0x58004C00U,   /** @brief Key register */
  };

  static RW_ uint32_t* const IWDGx_PR_PTR[3] = {
    [2] = (RW_ uint32_t* const)0x58004C04U,   /** @brief Prescaler register */
  };

  static RW_ uint32_t* const IWDGx_RLR_PTR[3] = {
    [2] = (RW_ uint32_t* const)0x58004C08U,   /** @brief Reload register */
  };

  static RO_ uint32_t* const IWDGx_SR_PTR[3] = {
    [2] = (RO_ uint32_t* const)0x58004C0CU,   /** @brief Status register */
  };

  static RW_ uint32_t* const IWDGx_WINR_PTR[3] = {
    [2] = (RW_ uint32_t* const)0x58004C10U,   /** @brief Window register */
  };

  /**** @subsection IWDGx Register Field Masks ****/

  static const uint32_t IWDGx_KR_KEY_MSK   = 0x0000FFFFU;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
  static const uint32_t IWDGx_PR_PR_MSK    = 0x00000007U;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
  static const uint32_t IWDGx_RLR_RL_MSK   = 0x00000FFFU;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
  static const uint32_t IWDGx_SR_PVU_MSK   = 0x00000001U;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
  static const uint32_t IWDGx_SR_RVU_MSK   = 0x00000002U;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
  static const uint32_t IWDGx_SR_WVU_MSK   = 0x00000004U;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
  static const uint32_t IWDGx_WINR_WIN_MSK = 0x00000FFFU;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

  /**** @subsection IWDGx Register Field Positions ****/

  static const int32_t IWDGx_KR_KEY_POS   = 0;   /** @brief Key value (write only, read 0x0000) these bits must be written by software at regular intervals with the key value 0xaaaa, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see section23.3.6: register access protection) writing the key value cccch starts the watchdog (except if the hardware watchdog option is selected) */
  static const int32_t IWDGx_PR_PR_POS    = 0;   /** @brief Prescaler divider these bits are write access protected see section23.3.6: register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset. */
  static const int32_t IWDGx_RLR_RL_POS   = 0;   /** @brief Watchdog counter reload value these bits are write access protected see section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xaaaa is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset. */
  static const int32_t IWDGx_SR_PVU_POS   = 0;   /** @brief Watchdog prescaler value update this bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Prescaler value can be updated only when PVU bit is reset. */
  static const int32_t IWDGx_SR_RVU_POS   = 1;   /** @brief Watchdog counter reload value update this bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Reload value can be updated only when RVU bit is reset. */
  static const int32_t IWDGx_SR_WVU_POS   = 2;   /** @brief Watchdog counter window value update this bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 khz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1 */
  static const int32_t IWDGx_WINR_WIN_POS = 0;   /** @brief Watchdog counter window value these bits are write access protected see section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 the WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset. */

  /**********************************************************************************************
   * @section WWDG2 Register Information
   **********************************************************************************************/

  /**** @subsection WWDG2 Register Pointers ****/

  static RW_ uint32_t* const WWDG2_CR_PTR  = (RW_ uint32_t* const)0x40002C00U;   /** @brief Control register */
  static RW_ uint32_t* const WWDG2_CFR_PTR = (RW_ uint32_t* const)0x40002C04U;   /** @brief Configuration register */
  static RW_ uint32_t* const WWDG2_SR_PTR  = (RW_ uint32_t* const)0x40002C08U;   /** @brief Status register */

  /**** @subsection WWDG2 Register Field Masks ****/

  static const uint32_t WWDG2_CR_T_MSK      = 0x0000007FU;   /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
  static const uint32_t WWDG2_CR_WDGA_MSK   = 0x00000080U;   /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
  static const uint32_t WWDG2_CFR_W_MSK     = 0x0000007FU;   /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
  static const uint32_t WWDG2_CFR_WDGTB_MSK = 0x00001800U;   /** @brief Timer base the time base of the prescaler can be modified as follows: */
  static const uint32_t WWDG2_CFR_EWI_MSK   = 0x00000200U;   /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
  static const uint32_t WWDG2_SR_EWIF_MSK   = 0x00000001U;   /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

  /**** @subsection WWDG2 Register Field Positions ****/

  static const int32_t WWDG2_CR_T_POS      = 0;    /** @brief 7-bit counter (MSB to LSB) these bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3f (T6 becomes cleared). */
  static const int32_t WWDG2_CR_WDGA_POS   = 7;    /** @brief Activation bit this bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset. */
  static const int32_t WWDG2_CFR_W_POS     = 0;    /** @brief 7-bit window value these bits contain the window value to be compared to the downcounter. */
  static const int32_t WWDG2_CFR_WDGTB_POS = 11;   /** @brief Timer base the time base of the prescaler can be modified as follows: */
  static const int32_t WWDG2_CFR_EWI_POS   = 9;    /** @brief Early wakeup interrupt when set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset. */
  static const int32_t WWDG2_SR_EWIF_POS   = 0;    /** @brief Early wakeup interrupt flag this bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled. */

  /**********************************************************************************************
   * @section PWR Register Information
   **********************************************************************************************/

  /**** @subsection PWR Register Pointers ****/

  static RO_ uint32_t* const PWR_CSR1_PTR    = (RO_ uint32_t* const)0x58024804U;   /** @brief PWR control status register 1 */
  static RW_ uint32_t* const PWR_CPUCR_PTR   = (RW_ uint32_t* const)0x58024810U;   /** @brief This register allows controlling CPU1 power. */
  static RW_ uint32_t* const PWR_D3CR_PTR    = (RW_ uint32_t* const)0x58024818U;   /** @brief This register allows controlling D3 domain power.following reset VOSRDY will be read 1 by software */
  static RW_ uint32_t* const PWR_WKUPCR_PTR  = (RW_ uint32_t* const)0x58024820U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared). */
  static RW_ uint32_t* const PWR_WKUPFR_PTR  = (RW_ uint32_t* const)0x58024824U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */
  static RW_ uint32_t* const PWR_WKUPEPR_PTR = (RW_ uint32_t* const)0x58024828U;   /** @brief Reset only by system reset, not reset by wakeup from standby mode */

  /**** @subsection Enumerated PWR Register Pointers ****/

  static RW_ uint32_t* const PWR_CRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58024800U,   /** @brief PWR control register 1 */
    [2] = (RW_ uint32_t* const)0x58024808U,   /** @brief This register is not reset by wakeup from standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.after reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection. */
    [3] = (RW_ uint32_t* const)0x5802480CU,   /** @brief Reset only by POR only, not reset by wakeup from standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value. */
  };

  /**** @subsection PWR Register Field Masks ****/

  static const uint32_t PWR_CRx_LPDS_MSK       = 0x00000001U;   /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
  static const uint32_t PWR_CRx_PVDE_MSK       = 0x00000010U;   /** @brief Programmable voltage detector enable */
  static const uint32_t PWR_CRx_PLS_MSK        = 0x000000E0U;   /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
  static const uint32_t PWR_CRx_DBP_MSK        = 0x00000100U;   /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
  static const uint32_t PWR_CRx_FLPS_MSK       = 0x00000200U;   /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
  static const uint32_t PWR_CRx_SVOS_MSK       = 0x0000C000U;   /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
  static const uint32_t PWR_CRx_AVDEN_MSK      = 0x00010000U;   /** @brief Peripheral voltage monitor on VDDA enable */
  static const uint32_t PWR_CRx_ALS_MSK        = 0x00060000U;   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
  static const uint32_t PWR_CSR1_PVDO_MSK      = 0x00000010U;   /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
  static const uint32_t PWR_CSR1_ACTVOSRDY_MSK = 0x00002000U;   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const uint32_t PWR_CSR1_ACTVOS_MSK    = 0x0000C000U;   /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
  static const uint32_t PWR_CSR1_AVDO_MSK      = 0x00010000U;   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
  static const uint32_t PWR_CPUCR_STOPF_MSK    = 0x00000020U;   /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
  static const uint32_t PWR_CPUCR_SBF_MSK      = 0x00000040U;   /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
  static const uint32_t PWR_CPUCR_CSSF_MSK     = 0x00000200U;   /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
  static const uint32_t PWR_CPUCR_RUN_D3_MSK   = 0x00000800U;   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
  static const uint32_t PWR_D3CR_VOSRDY_MSK    = 0x00002000U;   /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const uint32_t PWR_D3CR_VOS_MSK       = 0x0000C000U;   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
  static const uint32_t PWR_WKUPCR_WKUPC_MSK   = 0x0000003FU;   /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

  /**** @subsection Enumerated PWR Register Field Masks ****/

  static const uint32_t PWR_CPUCR_PDDS_Dx_MSK[4] = {
    [1] = 0x00000001U,   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
    [2] = 0x00000002U,   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
    [3] = 0x00000004U,   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
  };

  static const uint32_t PWR_CPUCR_SBF_Dx_MSK[3] = {
    [1] = 0x00000080U,   /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
    [2] = 0x00000100U,   /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
  };

  static const uint32_t PWR_WKUPFR_WKUPFx_MSK[7] = {
    [1] = 0x00000001U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [2] = 0x00000002U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [3] = 0x00000004U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [4] = 0x00000008U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [5] = 0x00000010U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [6] = 0x00000020U,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
  };

  static const uint32_t PWR_WKUPEPR_WKUPENx_MSK[7] = {
    [1] = 0x00000001U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [2] = 0x00000002U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [3] = 0x00000004U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [4] = 0x00000008U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [5] = 0x00000010U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [6] = 0x00000020U,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
  };

  static const uint32_t PWR_WKUPEPR_WKUPPx_MSK[7] = {
    [1] = 0x00000100U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [2] = 0x00000200U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [3] = 0x00000400U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [4] = 0x00000800U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [5] = 0x00001000U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [6] = 0x00002000U,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
  };

  static const uint32_t PWR_WKUPEPR_WKUPPUPDx_MSK[7] = {
    [1] = 0x00030000U,   /** @brief Wakeup pin pull configuration */
    [2] = 0x000C0000U,   /** @brief Wakeup pin pull configuration */
    [3] = 0x00300000U,   /** @brief Wakeup pin pull configuration */
    [4] = 0x00C00000U,   /** @brief Wakeup pin pull configuration */
    [5] = 0x03000000U,   /** @brief Wakeup pin pull configuration */
    [6] = 0x0C000000U,   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
  };

  /**** @subsection PWR Register Field Positions ****/

  static const int32_t PWR_CRx_LPDS_POS       = 0;    /** @brief Low-power deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit) */
  static const int32_t PWR_CRx_PVDE_POS       = 4;    /** @brief Programmable voltage detector enable */
  static const int32_t PWR_CRx_PLS_POS        = 5;    /** @brief Programmable voltage detector level selection these bits select the voltage threshold detected by the PVD. Note: refer to section electrical characteristics of the product datasheet for more details. */
  static const int32_t PWR_CRx_DBP_POS        = 8;    /** @brief Disable backup domain write protection in reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers. */
  static const int32_t PWR_CRx_FLPS_POS       = 9;    /** @brief Flash low-power mode in dstop mode this bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from dstop mode. When it is set, the flash memory enters low-power mode when D1 domain is in dstop mode. */
  static const int32_t PWR_CRx_SVOS_POS       = 14;   /** @brief System stop mode voltage scaling selection these bits control the VCORE voltage level in system stop mode, to obtain the best trade-off between power consumption and performance. */
  static const int32_t PWR_CRx_AVDEN_POS      = 16;   /** @brief Peripheral voltage monitor on VDDA enable */
  static const int32_t PWR_CRx_ALS_POS        = 17;   /** @brief Analog voltage detector level selection these bits select the voltage threshold detected by the AVD. */
  static const int32_t PWR_CSR1_PVDO_POS      = 4;    /** @brief Programmable voltage detect output this bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the PVDE bit is set. */
  static const int32_t PWR_CSR1_ACTVOSRDY_POS = 13;   /** @brief Voltage levels ready bit for currently used VOS and SDLEVEL this bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const int32_t PWR_CSR1_ACTVOS_POS    = 14;   /** @brief VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU. */
  static const int32_t PWR_CSR1_AVDO_POS      = 16;   /** @brief Analog voltage detector output on VDDA this bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: since the AVD is disabled in standby mode, this bit is equal to 0 after standby or reset until the AVDEN bit is set. */
  static const int32_t PWR_CPUCR_STOPF_POS    = 5;    /** @brief STOP flag this bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit. */
  static const int32_t PWR_CPUCR_SBF_POS      = 6;    /** @brief System standby flag this bit is set by hardware and cleared only by a POR (power-on reset) or by setting the CPU1 CSSF bit */
  static const int32_t PWR_CPUCR_CSSF_POS     = 9;    /** @brief Clear D1 domain CPU1 standby, stop and HOLD flags (always read as 0) this bit is cleared to 0 by hardware. */
  static const int32_t PWR_CPUCR_RUN_D3_POS   = 11;   /** @brief Keep system D3 domain in run mode regardless of the CPU sub-systems modes */
  static const int32_t PWR_D3CR_VOSRDY_POS    = 13;   /** @brief VOS ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when bypass mode is selected in PWR control register 3 (PWR_CR3). */
  static const int32_t PWR_D3CR_VOS_POS       = 14;   /** @brief Voltage scaling selection according to performance these bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: when increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling. */
  static const int32_t PWR_WKUPCR_WKUPC_POS   = 0;    /** @brief Clear wakeup pin flag for WKUP. These bits are always read as 0. */

  /**** @subsection Enumerated PWR Register Field Positions ****/

  static const int32_t PWR_CPUCR_PDDS_Dx_POS[4] = {
    [1] = 0,   /** @brief D1 domain power down deepsleep selection. This bit allows CPU1 to define the deepsleep mode for D1 domain. */
    [2] = 1,   /** @brief D2 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for D2 domain. */
    [3] = 2,   /** @brief System D3 domain power down deepsleep. This bit allows CPU1 to define the deepsleep mode for system D3 domain. */
  };

  static const int32_t PWR_CPUCR_SBF_Dx_POS[3] = {
    [1] = 7,   /** @brief D1 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in dstandby mode. */
    [2] = 8,   /** @brief D2 domain dstandby flag this bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in dstandby mode. */
  };

  static const int32_t PWR_WKUPFR_WKUPFx_POS[7] = {
    [1] = 0,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [2] = 1,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [3] = 2,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [4] = 3,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [5] = 4,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
    [6] = 5,   /** @brief Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a reset pin or by setting the wkupcn+1 bit in the PWR wakeup clear register (PWR_WKUPCR). */
  };

  static const int32_t PWR_WKUPEPR_WKUPENx_POS[7] = {
    [1] = 0,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [2] = 1,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [3] = 2,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [4] = 3,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [5] = 4,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
    [6] = 5,   /** @brief Enable wakeup pin wkupn+1 each bit is set and cleared by software. Note: an additional wakeup event is detected if wkupn+1 pin is enabled (by setting the wkupenn+1 bit) when wkupn+1 pin level is already high when wkuppn+1 selects rising edge, or low when wkuppn+1 selects falling edge. */
  };

  static const int32_t PWR_WKUPEPR_WKUPPx_POS[7] = {
    [1] = 8,    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [2] = 9,    /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [3] = 10,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [4] = 11,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [5] = 12,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
    [6] = 13,   /** @brief Wakeup pin polarity bit for wkupn-7 these bits define the polarity used for event detection on wkupn-7 external wakeup pin. */
  };

  static const int32_t PWR_WKUPEPR_WKUPPUPDx_POS[7] = {
    [1] = 16,   /** @brief Wakeup pin pull configuration */
    [2] = 18,   /** @brief Wakeup pin pull configuration */
    [3] = 20,   /** @brief Wakeup pin pull configuration */
    [4] = 22,   /** @brief Wakeup pin pull configuration */
    [5] = 24,   /** @brief Wakeup pin pull configuration */
    [6] = 26,   /** @brief Wakeup pin pull configuration for wkup(truncate(n/2)-7) these bits define the I/O pad pull configuration used when wkupen(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The wakeup pin pull configuration is kept in standby mode. */
  };

  /**********************************************************************************************
   * @section SPIx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated SPIx Register Pointers ****/

  static RW_ uint32_t* const SPIx_CRx_PTR[7][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40013000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40013004U,   /** @brief Control register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40003800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40003804U,   /** @brief Control register 2 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40003C00U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40003C04U,   /** @brief Control register 2 */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x40015000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40015004U,   /** @brief Control register 2 */
    },
    [4] = {
      [1] = (RW_ uint32_t* const)0x58001400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x58001404U,   /** @brief Control register 2 */
    },
  };

  static RW_ uint32_t* const SPIx_CFGx_PTR[7][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40013008U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x4001300CU,   /** @brief Configuration register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40003808U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x4000380CU,   /** @brief Configuration register 2 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40003C08U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x40003C0CU,   /** @brief Configuration register 2 */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x40015008U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x4001500CU,   /** @brief Configuration register 2 */
    },
    [4] = {
      [1] = (RW_ uint32_t* const)0x58001408U,   /** @brief Configuration register 1 */
      [2] = (RW_ uint32_t* const)0x5800140CU,   /** @brief Configuration register 2 */
    },
  };

  static RW_ uint32_t* const SPIx_IER_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40013010U,   /** @brief Interrupt enable register */
    [2] = (RW_ uint32_t* const)0x40003810U,   /** @brief Interrupt enable register */
    [3] = (RW_ uint32_t* const)0x40003C10U,   /** @brief Interrupt enable register */
    [5] = (RW_ uint32_t* const)0x40015010U,   /** @brief Interrupt enable register */
    [6] = (RW_ uint32_t* const)0x58001410U,   /** @brief Interrupt enable register */
  };

  static RO_ uint32_t* const SPIx_SR_PTR[7] = {
    [1] = (RO_ uint32_t* const)0x40013014U,   /** @brief Status register */
    [2] = (RO_ uint32_t* const)0x40003814U,   /** @brief Status register */
    [3] = (RO_ uint32_t* const)0x40003C14U,   /** @brief Status register */
    [5] = (RO_ uint32_t* const)0x40015014U,   /** @brief Status register */
    [6] = (RO_ uint32_t* const)0x58001414U,   /** @brief Status register */
  };

  static WO_ uint32_t* const SPIx_IFCR_PTR[7] = {
    [1] = (WO_ uint32_t* const)0x40013018U,   /** @brief Interrupt/Status flags clear register */
    [2] = (WO_ uint32_t* const)0x40003818U,   /** @brief Interrupt/Status flags clear register */
    [3] = (WO_ uint32_t* const)0x40003C18U,   /** @brief Interrupt/Status flags clear register */
    [5] = (WO_ uint32_t* const)0x40015018U,   /** @brief Interrupt/Status flags clear register */
    [6] = (WO_ uint32_t* const)0x58001418U,   /** @brief Interrupt/Status flags clear register */
  };

  static WO_ uint32_t* const SPIx_TXDR_PTR[7] = {
    [1] = (WO_ uint32_t* const)0x40013020U,   /** @brief Transmit data register */
    [2] = (WO_ uint32_t* const)0x40003820U,   /** @brief Transmit data register */
    [3] = (WO_ uint32_t* const)0x40003C20U,   /** @brief Transmit data register */
    [5] = (WO_ uint32_t* const)0x40015020U,   /** @brief Transmit data register */
    [6] = (WO_ uint32_t* const)0x58001420U,   /** @brief Transmit data register */
  };

  static RO_ uint32_t* const SPIx_RXDR_PTR[7] = {
    [1] = (RO_ uint32_t* const)0x40013030U,   /** @brief Receive data register */
    [2] = (RO_ uint32_t* const)0x40003830U,   /** @brief Receive data register */
    [3] = (RO_ uint32_t* const)0x40003C30U,   /** @brief Receive data register */
    [5] = (RO_ uint32_t* const)0x40015030U,   /** @brief Receive data register */
    [6] = (RO_ uint32_t* const)0x58001430U,   /** @brief Receive data register */
  };

  static RW_ uint32_t* const SPIx_CRCPOLY_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40013040U,   /** @brief Polynomial register */
    [2] = (RW_ uint32_t* const)0x40003840U,   /** @brief Polynomial register */
    [3] = (RW_ uint32_t* const)0x40003C40U,   /** @brief Polynomial register */
    [5] = (RW_ uint32_t* const)0x40015040U,   /** @brief Polynomial register */
    [6] = (RW_ uint32_t* const)0x58001440U,   /** @brief Polynomial register */
  };

  static RW_ uint32_t* const SPIx_TXCRC_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40013044U,   /** @brief Transmitter CRC register */
    [2] = (RW_ uint32_t* const)0x40003844U,   /** @brief Transmitter CRC register */
    [3] = (RW_ uint32_t* const)0x40003C44U,   /** @brief Transmitter CRC register */
    [5] = (RW_ uint32_t* const)0x40015044U,   /** @brief Transmitter CRC register */
    [6] = (RW_ uint32_t* const)0x58001444U,   /** @brief Transmitter CRC register */
  };

  static RW_ uint32_t* const SPIx_RXCRC_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40013048U,   /** @brief Receiver CRC register */
    [2] = (RW_ uint32_t* const)0x40003848U,   /** @brief Receiver CRC register */
    [3] = (RW_ uint32_t* const)0x40003C48U,   /** @brief Receiver CRC register */
    [5] = (RW_ uint32_t* const)0x40015048U,   /** @brief Receiver CRC register */
    [6] = (RW_ uint32_t* const)0x58001448U,   /** @brief Receiver CRC register */
  };

  static RW_ uint32_t* const SPIx_UDRDR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x4001304CU,   /** @brief Underrun data register */
    [2] = (RW_ uint32_t* const)0x4000384CU,   /** @brief Underrun data register */
    [3] = (RW_ uint32_t* const)0x40003C4CU,   /** @brief Underrun data register */
    [5] = (RW_ uint32_t* const)0x4001504CU,   /** @brief Underrun data register */
    [6] = (RW_ uint32_t* const)0x5800144CU,   /** @brief Underrun data register */
  };

  static RW_ uint32_t* const SPIx_CGFR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40013050U,   /** @brief Configuration register */
    [2] = (RW_ uint32_t* const)0x40003850U,   /** @brief Configuration register */
    [3] = (RW_ uint32_t* const)0x40003C50U,   /** @brief Configuration register */
    [5] = (RW_ uint32_t* const)0x40015050U,   /** @brief Configuration register */
    [6] = (RW_ uint32_t* const)0x58001450U,   /** @brief Configuration register */
  };

  /**** @subsection SPIx Register Field Masks ****/

  static const uint32_t SPIx_CRx_IOLOCK_MSK   = 0x00010000U;   /** @brief Locking the AF configuration of associated ios */
  static const uint32_t SPIx_CRx_TCRCI_MSK    = 0x00008000U;   /** @brief CRC calculation initialization pattern control for transmitter */
  static const uint32_t SPIx_CRx_RCRCI_MSK    = 0x00004000U;   /** @brief CRC calculation initialization pattern control for receiver */
  static const uint32_t SPIx_CRx_CRC33_17_MSK = 0x00002000U;   /** @brief 32-bit CRC polynomial configuration */
  static const uint32_t SPIx_CRx_SSI_MSK      = 0x00001000U;   /** @brief Internal SS signal input level */
  static const uint32_t SPIx_CRx_HDDIR_MSK    = 0x00000800U;   /** @brief Rx/Tx direction at half-duplex mode */
  static const uint32_t SPIx_CRx_CSUSP_MSK    = 0x00000400U;   /** @brief Master suspend request */
  static const uint32_t SPIx_CRx_CSTART_MSK   = 0x00000200U;   /** @brief Master transfer start */
  static const uint32_t SPIx_CRx_MASRX_MSK    = 0x00000100U;   /** @brief Master automatic SUSP in receive mode */
  static const uint32_t SPIx_CRx_SPE_MSK      = 0x00000001U;   /** @brief Serial peripheral enable */
  static const uint32_t SPIx_CFGx_MBR_MSK     = 0x70000000U;   /** @brief Master baud rate */
  static const uint32_t SPIx_CFGx_CRCEN_MSK   = 0x00400000U;   /** @brief Hardware CRC computation enable */
  static const uint32_t SPIx_CFGx_CRCSIZE_MSK = 0x001F0000U;   /** @brief Length of CRC frame to be transacted and compared */
  static const uint32_t SPIx_CFGx_TXDMAEN_MSK = 0x00008000U;   /** @brief Tx DMA stream enable */
  static const uint32_t SPIx_CFGx_RXDMAEN_MSK = 0x00004000U;   /** @brief Rx DMA stream enable */
  static const uint32_t SPIx_CFGx_UDRDET_MSK  = 0x00001800U;   /** @brief Detection of underrun condition at slave transmitter */
  static const uint32_t SPIx_CFGx_UDRCFG_MSK  = 0x00000600U;   /** @brief Behavior of slave transmitter at underrun condition */
  static const uint32_t SPIx_CFGx_FTHVL_MSK   = 0x000001E0U;   /** @brief Threshold level */
  static const uint32_t SPIx_CFGx_DSIZE_MSK   = 0x0000001FU;   /** @brief Number of bits in at single SPI data frame */
  static const uint32_t SPIx_IER_TSERFIE_MSK  = 0x00000400U;   /** @brief Additional number of transactions reload interrupt enable */
  static const uint32_t SPIx_IER_MODFIE_MSK   = 0x00000200U;   /** @brief Mode fault interrupt enable */
  static const uint32_t SPIx_IER_TIFREIE_MSK  = 0x00000100U;   /** @brief TIFRE interrupt enable */
  static const uint32_t SPIx_IER_CRCEIE_MSK   = 0x00000080U;   /** @brief CRC interrupt enable */
  static const uint32_t SPIx_IER_OVRIE_MSK    = 0x00000040U;   /** @brief OVR interrupt enable */
  static const uint32_t SPIx_IER_UDRIE_MSK    = 0x00000020U;   /** @brief UDR interrupt enable */
  static const uint32_t SPIx_IER_TXTFIE_MSK   = 0x00000010U;   /** @brief TXTFIE interrupt enable */
  static const uint32_t SPIx_IER_EOTIE_MSK    = 0x00000008U;   /** @brief EOT, SUSP and TXC interrupt enable */
  static const uint32_t SPIx_IER_DPXPIE_MSK   = 0x00000004U;   /** @brief DXP interrupt enabled */
  static const uint32_t SPIx_IER_TXPIE_MSK    = 0x00000002U;   /** @brief TXP interrupt enable */
  static const uint32_t SPIx_IER_RXPIE_MSK    = 0x00000001U;   /** @brief RXP interrupt enable */
  static const uint32_t SPIx_SR_CTSIZE_MSK    = 0xFFFF0000U;   /** @brief Number of data frames remaining in current TSIZE session */
  static const uint32_t SPIx_SR_RXWNE_MSK     = 0x00008000U;   /** @brief RxFIFO word not empty */
  static const uint32_t SPIx_SR_RXPLVL_MSK    = 0x00006000U;   /** @brief RxFIFO packing level */
  static const uint32_t SPIx_SR_TXC_MSK       = 0x00001000U;   /** @brief TxFIFO transmission complete */
  static const uint32_t SPIx_SR_SUSP_MSK      = 0x00000800U;   /** @brief SUSPend */
  static const uint32_t SPIx_SR_TSERF_MSK     = 0x00000400U;   /** @brief Additional number of SPI data to be transacted was reload */
  static const uint32_t SPIx_SR_MODF_MSK      = 0x00000200U;   /** @brief Mode fault */
  static const uint32_t SPIx_SR_TIFRE_MSK     = 0x00000100U;   /** @brief TI frame format error */
  static const uint32_t SPIx_SR_CRCE_MSK      = 0x00000080U;   /** @brief CRC error */
  static const uint32_t SPIx_SR_OVR_MSK       = 0x00000040U;   /** @brief Overrun */
  static const uint32_t SPIx_SR_UDR_MSK       = 0x00000020U;   /** @brief Underrun at slave transmission mode */
  static const uint32_t SPIx_SR_TXTF_MSK      = 0x00000010U;   /** @brief Transmission transfer filled */
  static const uint32_t SPIx_SR_EOT_MSK       = 0x00000008U;   /** @brief End of transfer */
  static const uint32_t SPIx_SR_DXP_MSK       = 0x00000004U;   /** @brief Duplex packet */
  static const uint32_t SPIx_SR_TXP_MSK       = 0x00000002U;   /** @brief Tx-Packet space available */
  static const uint32_t SPIx_SR_RXP_MSK       = 0x00000001U;   /** @brief Rx-Packet available */
  static const uint32_t SPIx_IFCR_SUSPC_MSK   = 0x00000800U;   /** @brief SUSPend flag clear */
  static const uint32_t SPIx_IFCR_TSERFC_MSK  = 0x00000400U;   /** @brief TSERFC flag clear */
  static const uint32_t SPIx_IFCR_MODFC_MSK   = 0x00000200U;   /** @brief Mode fault flag clear */
  static const uint32_t SPIx_IFCR_TIFREC_MSK  = 0x00000100U;   /** @brief TI frame format error flag clear */
  static const uint32_t SPIx_IFCR_CRCEC_MSK   = 0x00000080U;   /** @brief CRC error flag clear */
  static const uint32_t SPIx_IFCR_OVRC_MSK    = 0x00000040U;   /** @brief Overrun flag clear */
  static const uint32_t SPIx_IFCR_UDRC_MSK    = 0x00000020U;   /** @brief Underrun flag clear */
  static const uint32_t SPIx_IFCR_TXTFC_MSK   = 0x00000010U;   /** @brief Transmission transfer filled flag clear */
  static const uint32_t SPIx_IFCR_EOTC_MSK    = 0x00000008U;   /** @brief End of transfer flag clear */
  static const uint32_t SPIx_CGFR_MCKOE_MSK   = 0x02000000U;   /** @brief Master clock output enable */
  static const uint32_t SPIx_CGFR_ODD_MSK     = 0x01000000U;   /** @brief Odd factor for the prescaler */
  static const uint32_t SPIx_CGFR_I2SDIV_MSK  = 0x00FF0000U;   /** @brief I2S linear prescaler */
  static const uint32_t SPIx_CGFR_DATFMT_MSK  = 0x00004000U;   /** @brief Data format */
  static const uint32_t SPIx_CGFR_WSINV_MSK   = 0x00002000U;   /** @brief Fixed channel length in SLAVE */
  static const uint32_t SPIx_CGFR_FIXCH_MSK   = 0x00001000U;   /** @brief Word select inversion */
  static const uint32_t SPIx_CGFR_CKPOL_MSK   = 0x00000800U;   /** @brief Serial audio clock polarity */
  static const uint32_t SPIx_CGFR_CHLEN_MSK   = 0x00000400U;   /** @brief Channel length (number of bits per audio channel) */
  static const uint32_t SPIx_CGFR_DATLEN_MSK  = 0x00000300U;   /** @brief Data length to be transferred */
  static const uint32_t SPIx_CGFR_PCMSYNC_MSK = 0x00000080U;   /** @brief PCM frame synchronization */
  static const uint32_t SPIx_CGFR_I2SSTD_MSK  = 0x00000030U;   /** @brief I2S standard selection */
  static const uint32_t SPIx_CGFR_I2SCFG_MSK  = 0x0000000EU;   /** @brief I2S configuration mode */
  static const uint32_t SPIx_CGFR_I2SMOD_MSK  = 0x00000001U;   /** @brief I2S mode selection */

  /**** @subsection SPIx Register Field Positions ****/

  static const int32_t SPIx_CRx_IOLOCK_POS   = 16;   /** @brief Locking the AF configuration of associated ios */
  static const int32_t SPIx_CRx_TCRCI_POS    = 15;   /** @brief CRC calculation initialization pattern control for transmitter */
  static const int32_t SPIx_CRx_RCRCI_POS    = 14;   /** @brief CRC calculation initialization pattern control for receiver */
  static const int32_t SPIx_CRx_CRC33_17_POS = 13;   /** @brief 32-bit CRC polynomial configuration */
  static const int32_t SPIx_CRx_SSI_POS      = 12;   /** @brief Internal SS signal input level */
  static const int32_t SPIx_CRx_HDDIR_POS    = 11;   /** @brief Rx/Tx direction at half-duplex mode */
  static const int32_t SPIx_CRx_CSUSP_POS    = 10;   /** @brief Master suspend request */
  static const int32_t SPIx_CRx_CSTART_POS   = 9;    /** @brief Master transfer start */
  static const int32_t SPIx_CRx_MASRX_POS    = 8;    /** @brief Master automatic SUSP in receive mode */
  static const int32_t SPIx_CRx_SPE_POS      = 0;    /** @brief Serial peripheral enable */
  static const int32_t SPIx_CFGx_MBR_POS     = 28;   /** @brief Master baud rate */
  static const int32_t SPIx_CFGx_CRCEN_POS   = 22;   /** @brief Hardware CRC computation enable */
  static const int32_t SPIx_CFGx_CRCSIZE_POS = 16;   /** @brief Length of CRC frame to be transacted and compared */
  static const int32_t SPIx_CFGx_TXDMAEN_POS = 15;   /** @brief Tx DMA stream enable */
  static const int32_t SPIx_CFGx_RXDMAEN_POS = 14;   /** @brief Rx DMA stream enable */
  static const int32_t SPIx_CFGx_UDRDET_POS  = 11;   /** @brief Detection of underrun condition at slave transmitter */
  static const int32_t SPIx_CFGx_UDRCFG_POS  = 9;    /** @brief Behavior of slave transmitter at underrun condition */
  static const int32_t SPIx_CFGx_FTHVL_POS   = 5;    /** @brief Threshold level */
  static const int32_t SPIx_CFGx_DSIZE_POS   = 0;    /** @brief Number of bits in at single SPI data frame */
  static const int32_t SPIx_IER_TSERFIE_POS  = 10;   /** @brief Additional number of transactions reload interrupt enable */
  static const int32_t SPIx_IER_MODFIE_POS   = 9;    /** @brief Mode fault interrupt enable */
  static const int32_t SPIx_IER_TIFREIE_POS  = 8;    /** @brief TIFRE interrupt enable */
  static const int32_t SPIx_IER_CRCEIE_POS   = 7;    /** @brief CRC interrupt enable */
  static const int32_t SPIx_IER_OVRIE_POS    = 6;    /** @brief OVR interrupt enable */
  static const int32_t SPIx_IER_UDRIE_POS    = 5;    /** @brief UDR interrupt enable */
  static const int32_t SPIx_IER_TXTFIE_POS   = 4;    /** @brief TXTFIE interrupt enable */
  static const int32_t SPIx_IER_EOTIE_POS    = 3;    /** @brief EOT, SUSP and TXC interrupt enable */
  static const int32_t SPIx_IER_DPXPIE_POS   = 2;    /** @brief DXP interrupt enabled */
  static const int32_t SPIx_IER_TXPIE_POS    = 1;    /** @brief TXP interrupt enable */
  static const int32_t SPIx_IER_RXPIE_POS    = 0;    /** @brief RXP interrupt enable */
  static const int32_t SPIx_SR_CTSIZE_POS    = 16;   /** @brief Number of data frames remaining in current TSIZE session */
  static const int32_t SPIx_SR_RXWNE_POS     = 15;   /** @brief RxFIFO word not empty */
  static const int32_t SPIx_SR_RXPLVL_POS    = 13;   /** @brief RxFIFO packing level */
  static const int32_t SPIx_SR_TXC_POS       = 12;   /** @brief TxFIFO transmission complete */
  static const int32_t SPIx_SR_SUSP_POS      = 11;   /** @brief SUSPend */
  static const int32_t SPIx_SR_TSERF_POS     = 10;   /** @brief Additional number of SPI data to be transacted was reload */
  static const int32_t SPIx_SR_MODF_POS      = 9;    /** @brief Mode fault */
  static const int32_t SPIx_SR_TIFRE_POS     = 8;    /** @brief TI frame format error */
  static const int32_t SPIx_SR_CRCE_POS      = 7;    /** @brief CRC error */
  static const int32_t SPIx_SR_OVR_POS       = 6;    /** @brief Overrun */
  static const int32_t SPIx_SR_UDR_POS       = 5;    /** @brief Underrun at slave transmission mode */
  static const int32_t SPIx_SR_TXTF_POS      = 4;    /** @brief Transmission transfer filled */
  static const int32_t SPIx_SR_EOT_POS       = 3;    /** @brief End of transfer */
  static const int32_t SPIx_SR_DXP_POS       = 2;    /** @brief Duplex packet */
  static const int32_t SPIx_SR_TXP_POS       = 1;    /** @brief Tx-Packet space available */
  static const int32_t SPIx_SR_RXP_POS       = 0;    /** @brief Rx-Packet available */
  static const int32_t SPIx_IFCR_SUSPC_POS   = 11;   /** @brief SUSPend flag clear */
  static const int32_t SPIx_IFCR_TSERFC_POS  = 10;   /** @brief TSERFC flag clear */
  static const int32_t SPIx_IFCR_MODFC_POS   = 9;    /** @brief Mode fault flag clear */
  static const int32_t SPIx_IFCR_TIFREC_POS  = 8;    /** @brief TI frame format error flag clear */
  static const int32_t SPIx_IFCR_CRCEC_POS   = 7;    /** @brief CRC error flag clear */
  static const int32_t SPIx_IFCR_OVRC_POS    = 6;    /** @brief Overrun flag clear */
  static const int32_t SPIx_IFCR_UDRC_POS    = 5;    /** @brief Underrun flag clear */
  static const int32_t SPIx_IFCR_TXTFC_POS   = 4;    /** @brief Transmission transfer filled flag clear */
  static const int32_t SPIx_IFCR_EOTC_POS    = 3;    /** @brief End of transfer flag clear */
  static const int32_t SPIx_CGFR_MCKOE_POS   = 25;   /** @brief Master clock output enable */
  static const int32_t SPIx_CGFR_ODD_POS     = 24;   /** @brief Odd factor for the prescaler */
  static const int32_t SPIx_CGFR_I2SDIV_POS  = 16;   /** @brief I2S linear prescaler */
  static const int32_t SPIx_CGFR_DATFMT_POS  = 14;   /** @brief Data format */
  static const int32_t SPIx_CGFR_WSINV_POS   = 13;   /** @brief Fixed channel length in SLAVE */
  static const int32_t SPIx_CGFR_FIXCH_POS   = 12;   /** @brief Word select inversion */
  static const int32_t SPIx_CGFR_CKPOL_POS   = 11;   /** @brief Serial audio clock polarity */
  static const int32_t SPIx_CGFR_CHLEN_POS   = 10;   /** @brief Channel length (number of bits per audio channel) */
  static const int32_t SPIx_CGFR_DATLEN_POS  = 8;    /** @brief Data length to be transferred */
  static const int32_t SPIx_CGFR_PCMSYNC_POS = 7;    /** @brief PCM frame synchronization */
  static const int32_t SPIx_CGFR_I2SSTD_POS  = 4;    /** @brief I2S standard selection */
  static const int32_t SPIx_CGFR_I2SCFG_POS  = 1;    /** @brief I2S configuration mode */
  static const int32_t SPIx_CGFR_I2SMOD_POS  = 0;    /** @brief I2S mode selection */

  /**********************************************************************************************
   * @section LTDC Register Information
   **********************************************************************************************/

  /**** @subsection LTDC Register Pointers ****/

  static RW_ uint32_t* const LTDC_SSCR_PTR  = (RW_ uint32_t* const)0x50001008U;   /** @brief Synchronization size configuration register */
  static RW_ uint32_t* const LTDC_BPCR_PTR  = (RW_ uint32_t* const)0x5000100CU;   /** @brief Back porch configuration register */
  static RW_ uint32_t* const LTDC_AWCR_PTR  = (RW_ uint32_t* const)0x50001010U;   /** @brief Active width configuration register */
  static RW_ uint32_t* const LTDC_TWCR_PTR  = (RW_ uint32_t* const)0x50001014U;   /** @brief Total width configuration register */
  static RW_ uint32_t* const LTDC_GCR_PTR   = (RW_ uint32_t* const)0x50001018U;   /** @brief Global control register */
  static RW_ uint32_t* const LTDC_SRCR_PTR  = (RW_ uint32_t* const)0x50001024U;   /** @brief Shadow reload configuration register */
  static RW_ uint32_t* const LTDC_BCCR_PTR  = (RW_ uint32_t* const)0x5000102CU;   /** @brief Background color configuration register */
  static RW_ uint32_t* const LTDC_IER_PTR   = (RW_ uint32_t* const)0x50001034U;   /** @brief Interrupt enable register */
  static RO_ uint32_t* const LTDC_ISR_PTR   = (RO_ uint32_t* const)0x50001038U;   /** @brief Interrupt status register */
  static WO_ uint32_t* const LTDC_ICR_PTR   = (WO_ uint32_t* const)0x5000103CU;   /** @brief Interrupt clear register */
  static RW_ uint32_t* const LTDC_LIPCR_PTR = (RW_ uint32_t* const)0x50001040U;   /** @brief Line interrupt position configuration register */
  static RO_ uint32_t* const LTDC_CPSR_PTR  = (RO_ uint32_t* const)0x50001044U;   /** @brief Current position status register */
  static RO_ uint32_t* const LTDC_CDSR_PTR  = (RO_ uint32_t* const)0x50001048U;   /** @brief Current display status register */

  /**** @subsection Enumerated LTDC Register Pointers ****/

  static RW_ uint32_t* const LTDC_LxCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x50001084U,   /** @brief Layerx control register */
    [2] = (RW_ uint32_t* const)0x50001104U,   /** @brief Layerx control register */
  };

  static RW_ uint32_t* const LTDC_LxWHPCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x50001088U,   /** @brief Layerx window horizontal position configuration register */
    [2] = (RW_ uint32_t* const)0x50001108U,   /** @brief Layerx window horizontal position configuration register */
  };

  static RW_ uint32_t* const LTDC_LxWVPCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5000108CU,   /** @brief Layerx window vertical position configuration register */
    [2] = (RW_ uint32_t* const)0x5000110CU,   /** @brief Layerx window vertical position configuration register */
  };

  static RW_ uint32_t* const LTDC_LxCKCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x50001090U,   /** @brief Layerx color keying configuration register */
    [2] = (RW_ uint32_t* const)0x50001110U,   /** @brief Layerx color keying configuration register */
  };

  static RW_ uint32_t* const LTDC_LxPFCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x50001094U,   /** @brief Layerx pixel format configuration register */
    [2] = (RW_ uint32_t* const)0x50001114U,   /** @brief Layerx pixel format configuration register */
  };

  static RW_ uint32_t* const LTDC_LxCACR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x50001098U,   /** @brief Layerx constant alpha configuration register */
    [2] = (RW_ uint32_t* const)0x50001118U,   /** @brief Layerx constant alpha configuration register */
  };

  static RW_ uint32_t* const LTDC_LxDCCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5000109CU,   /** @brief Layerx default color configuration register */
    [2] = (RW_ uint32_t* const)0x5000111CU,   /** @brief Layerx default color configuration register */
  };

  static RW_ uint32_t* const LTDC_LxBFCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x500010A0U,   /** @brief Layerx blending factors configuration register */
    [2] = (RW_ uint32_t* const)0x50001120U,   /** @brief Layerx blending factors configuration register */
  };

  static RW_ uint32_t* const LTDC_LxCFBAR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x500010ACU,   /** @brief Layerx color frame buffer address register */
    [2] = (RW_ uint32_t* const)0x5000112CU,   /** @brief Layerx color frame buffer address register */
  };

  static RW_ uint32_t* const LTDC_LxCFBLR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x500010B0U,   /** @brief Layerx color frame buffer length register */
    [2] = (RW_ uint32_t* const)0x50001130U,   /** @brief Layerx color frame buffer length register */
  };

  static RW_ uint32_t* const LTDC_LxCFBLNR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x500010B4U,   /** @brief Layerx colorframe buffer line number register */
    [2] = (RW_ uint32_t* const)0x50001134U,   /** @brief Layerx colorframe buffer line number register */
  };

  static WO_ uint32_t* const LTDC_LxCLUTWR_PTR[3] = {
    [1] = (WO_ uint32_t* const)0x500010C4U,   /** @brief Layerx CLUT write register */
    [2] = (WO_ uint32_t* const)0x50001144U,   /** @brief Layerx CLUT write register */
  };

  /**** @subsection LTDC Register Field Masks ****/

  static const uint32_t LTDC_SSCR_HSW_MSK         = 0x03FF0000U;   /** @brief Horizontal synchronization width (in units of pixel clock period) */
  static const uint32_t LTDC_SSCR_VSH_MSK         = 0x000007FFU;   /** @brief Vertical synchronization height (in units of horizontal scan line) */
  static const uint32_t LTDC_BPCR_AHBP_MSK        = 0x0FFF0000U;   /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
  static const uint32_t LTDC_BPCR_AVBP_MSK        = 0x000007FFU;   /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
  static const uint32_t LTDC_AWCR_AAV_MSK         = 0x0FFF0000U;   /** @brief AAV */
  static const uint32_t LTDC_AWCR_AAH_MSK         = 0x000007FFU;   /** @brief Accumulated active height (in units of horizontal scan line) */
  static const uint32_t LTDC_TWCR_TOTALW_MSK      = 0x0FFF0000U;   /** @brief Total width (in units of pixel clock period) */
  static const uint32_t LTDC_TWCR_TOTALH_MSK      = 0x000007FFU;   /** @brief Total height (in units of horizontal scan line) */
  static const uint32_t LTDC_GCR_HSPOL_MSK        = 0x80000000U;   /** @brief Horizontal synchronization polarity */
  static const uint32_t LTDC_GCR_VSPOL_MSK        = 0x40000000U;   /** @brief Vertical synchronization polarity */
  static const uint32_t LTDC_GCR_DEPOL_MSK        = 0x20000000U;   /** @brief Data enable polarity */
  static const uint32_t LTDC_GCR_PCPOL_MSK        = 0x10000000U;   /** @brief Pixel clock polarity */
  static const uint32_t LTDC_GCR_DEN_MSK          = 0x00010000U;   /** @brief Dither enable */
  static const uint32_t LTDC_GCR_DRW_MSK          = 0x00007000U;   /** @brief Dither red width */
  static const uint32_t LTDC_GCR_DGW_MSK          = 0x00000700U;   /** @brief Dither green width */
  static const uint32_t LTDC_GCR_DBW_MSK          = 0x00000070U;   /** @brief Dither blue width */
  static const uint32_t LTDC_GCR_LTDCEN_MSK       = 0x00000001U;   /** @brief LCD-TFT controller enable bit */
  static const uint32_t LTDC_SRCR_VBR_MSK         = 0x00000002U;   /** @brief Vertical blanking reload */
  static const uint32_t LTDC_SRCR_IMR_MSK         = 0x00000001U;   /** @brief Immediate reload */
  static const uint32_t LTDC_BCCR_BCBLUE_MSK      = 0x000000FFU;   /** @brief Background color blue value */
  static const uint32_t LTDC_BCCR_BCGREEN_MSK     = 0x0000FF00U;   /** @brief Background color green value */
  static const uint32_t LTDC_BCCR_BCRED_MSK       = 0x00FF0000U;   /** @brief Background color red value */
  static const uint32_t LTDC_IER_RRIE_MSK         = 0x00000008U;   /** @brief Register reload interrupt enable */
  static const uint32_t LTDC_IER_TERRIE_MSK       = 0x00000004U;   /** @brief Transfer error interrupt enable */
  static const uint32_t LTDC_IER_FUIE_MSK         = 0x00000002U;   /** @brief FIFO underrun interrupt enable */
  static const uint32_t LTDC_IER_LIE_MSK          = 0x00000001U;   /** @brief Line interrupt enable */
  static const uint32_t LTDC_ISR_RRIF_MSK         = 0x00000008U;   /** @brief Register reload interrupt flag */
  static const uint32_t LTDC_ISR_TERRIF_MSK       = 0x00000004U;   /** @brief Transfer error interrupt flag */
  static const uint32_t LTDC_ISR_FUIF_MSK         = 0x00000002U;   /** @brief FIFO underrun interrupt flag */
  static const uint32_t LTDC_ISR_LIF_MSK          = 0x00000001U;   /** @brief Line interrupt flag */
  static const uint32_t LTDC_ICR_CRRIF_MSK        = 0x00000008U;   /** @brief Clears register reload interrupt flag */
  static const uint32_t LTDC_ICR_CTERRIF_MSK      = 0x00000004U;   /** @brief Clears the transfer error interrupt flag */
  static const uint32_t LTDC_ICR_CFUIF_MSK        = 0x00000002U;   /** @brief Clears the FIFO underrun interrupt flag */
  static const uint32_t LTDC_ICR_CLIF_MSK         = 0x00000001U;   /** @brief Clears the line interrupt flag */
  static const uint32_t LTDC_LIPCR_LIPOS_MSK      = 0x000007FFU;   /** @brief Line interrupt position */
  static const uint32_t LTDC_CPSR_CXPOS_MSK       = 0xFFFF0000U;   /** @brief Current X position */
  static const uint32_t LTDC_CPSR_CYPOS_MSK       = 0x0000FFFFU;   /** @brief Current Y position */
  static const uint32_t LTDC_CDSR_HSYNCS_MSK      = 0x00000008U;   /** @brief Horizontal synchronization display status */
  static const uint32_t LTDC_CDSR_VSYNCS_MSK      = 0x00000004U;   /** @brief Vertical synchronization display status */
  static const uint32_t LTDC_CDSR_HDES_MSK        = 0x00000002U;   /** @brief Horizontal data enable display status */
  static const uint32_t LTDC_CDSR_VDES_MSK        = 0x00000001U;   /** @brief Vertical data enable display status */
  static const uint32_t LTDC_LxCR_CLUTEN_MSK      = 0x00000010U;   /** @brief Color look-up table enable */
  static const uint32_t LTDC_LxCR_COLKEN_MSK      = 0x00000002U;   /** @brief Color keying enable */
  static const uint32_t LTDC_LxCR_LEN_MSK         = 0x00000001U;   /** @brief Layer enable */
  static const uint32_t LTDC_LxWHPCR_WHSPPOS_MSK  = 0x0FFF0000U;   /** @brief Window horizontal stop position */
  static const uint32_t LTDC_LxWHPCR_WHSTPOS_MSK  = 0x00000FFFU;   /** @brief Window horizontal start position */
  static const uint32_t LTDC_LxWVPCR_WVSPPOS_MSK  = 0x07FF0000U;   /** @brief Window vertical stop position */
  static const uint32_t LTDC_LxWVPCR_WVSTPOS_MSK  = 0x000007FFU;   /** @brief Window vertical start position */
  static const uint32_t LTDC_LxCKCR_CKRED_MSK     = 0x00FF0000U;   /** @brief Color key red value */
  static const uint32_t LTDC_LxCKCR_CKGREEN_MSK   = 0x0000FF00U;   /** @brief Color key green value */
  static const uint32_t LTDC_LxCKCR_CKBLUE_MSK    = 0x000000FFU;   /** @brief Color key blue value */
  static const uint32_t LTDC_LxPFCR_PF_MSK        = 0x00000007U;   /** @brief Pixel format */
  static const uint32_t LTDC_LxCACR_CONSTA_MSK    = 0x000000FFU;   /** @brief Constant alpha */
  static const uint32_t LTDC_LxDCCR_DCALPHA_MSK   = 0xFF000000U;   /** @brief Default color alpha */
  static const uint32_t LTDC_LxDCCR_DCRED_MSK     = 0x00FF0000U;   /** @brief Default color red */
  static const uint32_t LTDC_LxDCCR_DCGREEN_MSK   = 0x0000FF00U;   /** @brief Default color green */
  static const uint32_t LTDC_LxDCCR_DCBLUE_MSK    = 0x000000FFU;   /** @brief Default color blue */
  static const uint32_t LTDC_LxCFBLR_CFBP_MSK     = 0x1FFF0000U;   /** @brief Color frame buffer pitch in bytes */
  static const uint32_t LTDC_LxCFBLR_CFBLL_MSK    = 0x00001FFFU;   /** @brief Color frame buffer line length */
  static const uint32_t LTDC_LxCFBLNR_CFBLNBR_MSK = 0x000007FFU;   /** @brief Frame buffer line number */
  static const uint32_t LTDC_LxCLUTWR_CLUTADD_MSK = 0xFF000000U;   /** @brief CLUT address */
  static const uint32_t LTDC_LxCLUTWR_RED_MSK     = 0x00FF0000U;   /** @brief Red value */
  static const uint32_t LTDC_LxCLUTWR_GREEN_MSK   = 0x0000FF00U;   /** @brief Green value */
  static const uint32_t LTDC_LxCLUTWR_BLUE_MSK    = 0x000000FFU;   /** @brief Blue value */

  /**** @subsection Enumerated LTDC Register Field Masks ****/

  static const uint32_t LTDC_LxBFCR_BFx_MSK[3] = {
    [1] = 0x00000700U,   /** @brief Blending factor 1 */
    [2] = 0x00000007U,   /** @brief Blending factor 2 */
  };

  /**** @subsection LTDC Register Field Positions ****/

  static const int32_t LTDC_SSCR_HSW_POS         = 16;   /** @brief Horizontal synchronization width (in units of pixel clock period) */
  static const int32_t LTDC_SSCR_VSH_POS         = 0;    /** @brief Vertical synchronization height (in units of horizontal scan line) */
  static const int32_t LTDC_BPCR_AHBP_POS        = 16;   /** @brief Accumulated horizontal back porch (in units of pixel clock period) */
  static const int32_t LTDC_BPCR_AVBP_POS        = 0;    /** @brief Accumulated vertical back porch (in units of horizontal scan line) */
  static const int32_t LTDC_AWCR_AAV_POS         = 16;   /** @brief AAV */
  static const int32_t LTDC_AWCR_AAH_POS         = 0;    /** @brief Accumulated active height (in units of horizontal scan line) */
  static const int32_t LTDC_TWCR_TOTALW_POS      = 16;   /** @brief Total width (in units of pixel clock period) */
  static const int32_t LTDC_TWCR_TOTALH_POS      = 0;    /** @brief Total height (in units of horizontal scan line) */
  static const int32_t LTDC_GCR_HSPOL_POS        = 31;   /** @brief Horizontal synchronization polarity */
  static const int32_t LTDC_GCR_VSPOL_POS        = 30;   /** @brief Vertical synchronization polarity */
  static const int32_t LTDC_GCR_DEPOL_POS        = 29;   /** @brief Data enable polarity */
  static const int32_t LTDC_GCR_PCPOL_POS        = 28;   /** @brief Pixel clock polarity */
  static const int32_t LTDC_GCR_DEN_POS          = 16;   /** @brief Dither enable */
  static const int32_t LTDC_GCR_DRW_POS          = 12;   /** @brief Dither red width */
  static const int32_t LTDC_GCR_DGW_POS          = 8;    /** @brief Dither green width */
  static const int32_t LTDC_GCR_DBW_POS          = 4;    /** @brief Dither blue width */
  static const int32_t LTDC_GCR_LTDCEN_POS       = 0;    /** @brief LCD-TFT controller enable bit */
  static const int32_t LTDC_SRCR_VBR_POS         = 1;    /** @brief Vertical blanking reload */
  static const int32_t LTDC_SRCR_IMR_POS         = 0;    /** @brief Immediate reload */
  static const int32_t LTDC_BCCR_BCBLUE_POS      = 0;    /** @brief Background color blue value */
  static const int32_t LTDC_BCCR_BCGREEN_POS     = 8;    /** @brief Background color green value */
  static const int32_t LTDC_BCCR_BCRED_POS       = 16;   /** @brief Background color red value */
  static const int32_t LTDC_IER_RRIE_POS         = 3;    /** @brief Register reload interrupt enable */
  static const int32_t LTDC_IER_TERRIE_POS       = 2;    /** @brief Transfer error interrupt enable */
  static const int32_t LTDC_IER_FUIE_POS         = 1;    /** @brief FIFO underrun interrupt enable */
  static const int32_t LTDC_IER_LIE_POS          = 0;    /** @brief Line interrupt enable */
  static const int32_t LTDC_ISR_RRIF_POS         = 3;    /** @brief Register reload interrupt flag */
  static const int32_t LTDC_ISR_TERRIF_POS       = 2;    /** @brief Transfer error interrupt flag */
  static const int32_t LTDC_ISR_FUIF_POS         = 1;    /** @brief FIFO underrun interrupt flag */
  static const int32_t LTDC_ISR_LIF_POS          = 0;    /** @brief Line interrupt flag */
  static const int32_t LTDC_ICR_CRRIF_POS        = 3;    /** @brief Clears register reload interrupt flag */
  static const int32_t LTDC_ICR_CTERRIF_POS      = 2;    /** @brief Clears the transfer error interrupt flag */
  static const int32_t LTDC_ICR_CFUIF_POS        = 1;    /** @brief Clears the FIFO underrun interrupt flag */
  static const int32_t LTDC_ICR_CLIF_POS         = 0;    /** @brief Clears the line interrupt flag */
  static const int32_t LTDC_LIPCR_LIPOS_POS      = 0;    /** @brief Line interrupt position */
  static const int32_t LTDC_CPSR_CXPOS_POS       = 16;   /** @brief Current X position */
  static const int32_t LTDC_CPSR_CYPOS_POS       = 0;    /** @brief Current Y position */
  static const int32_t LTDC_CDSR_HSYNCS_POS      = 3;    /** @brief Horizontal synchronization display status */
  static const int32_t LTDC_CDSR_VSYNCS_POS      = 2;    /** @brief Vertical synchronization display status */
  static const int32_t LTDC_CDSR_HDES_POS        = 1;    /** @brief Horizontal data enable display status */
  static const int32_t LTDC_CDSR_VDES_POS        = 0;    /** @brief Vertical data enable display status */
  static const int32_t LTDC_LxCR_CLUTEN_POS      = 4;    /** @brief Color look-up table enable */
  static const int32_t LTDC_LxCR_COLKEN_POS      = 1;    /** @brief Color keying enable */
  static const int32_t LTDC_LxCR_LEN_POS         = 0;    /** @brief Layer enable */
  static const int32_t LTDC_LxWHPCR_WHSPPOS_POS  = 16;   /** @brief Window horizontal stop position */
  static const int32_t LTDC_LxWHPCR_WHSTPOS_POS  = 0;    /** @brief Window horizontal start position */
  static const int32_t LTDC_LxWVPCR_WVSPPOS_POS  = 16;   /** @brief Window vertical stop position */
  static const int32_t LTDC_LxWVPCR_WVSTPOS_POS  = 0;    /** @brief Window vertical start position */
  static const int32_t LTDC_LxCKCR_CKRED_POS     = 16;   /** @brief Color key red value */
  static const int32_t LTDC_LxCKCR_CKGREEN_POS   = 8;    /** @brief Color key green value */
  static const int32_t LTDC_LxCKCR_CKBLUE_POS    = 0;    /** @brief Color key blue value */
  static const int32_t LTDC_LxPFCR_PF_POS        = 0;    /** @brief Pixel format */
  static const int32_t LTDC_LxCACR_CONSTA_POS    = 0;    /** @brief Constant alpha */
  static const int32_t LTDC_LxDCCR_DCALPHA_POS   = 24;   /** @brief Default color alpha */
  static const int32_t LTDC_LxDCCR_DCRED_POS     = 16;   /** @brief Default color red */
  static const int32_t LTDC_LxDCCR_DCGREEN_POS   = 8;    /** @brief Default color green */
  static const int32_t LTDC_LxDCCR_DCBLUE_POS    = 0;    /** @brief Default color blue */
  static const int32_t LTDC_LxCFBLR_CFBP_POS     = 16;   /** @brief Color frame buffer pitch in bytes */
  static const int32_t LTDC_LxCFBLR_CFBLL_POS    = 0;    /** @brief Color frame buffer line length */
  static const int32_t LTDC_LxCFBLNR_CFBLNBR_POS = 0;    /** @brief Frame buffer line number */
  static const int32_t LTDC_LxCLUTWR_CLUTADD_POS = 24;   /** @brief CLUT address */
  static const int32_t LTDC_LxCLUTWR_RED_POS     = 16;   /** @brief Red value */
  static const int32_t LTDC_LxCLUTWR_GREEN_POS   = 8;    /** @brief Green value */
  static const int32_t LTDC_LxCLUTWR_BLUE_POS    = 0;    /** @brief Blue value */

  /**** @subsection Enumerated LTDC Register Field Positions ****/

  static const int32_t LTDC_LxBFCR_BFx_POS[3] = {
    [1] = 8,   /** @brief Blending factor 1 */
    [2] = 0,   /** @brief Blending factor 2 */
  };

  /**********************************************************************************************
   * @section SPDIFRX Register Information
   **********************************************************************************************/

  /**** @subsection SPDIFRX Register Pointers ****/

  static RW_ uint32_t* const SPDIFRX_CR_PTR   = (RW_ uint32_t* const)0x40004000U;   /** @brief Control register */
  static RW_ uint32_t* const SPDIFRX_IMR_PTR  = (RW_ uint32_t* const)0x40004004U;   /** @brief Interrupt mask register */
  static RO_ uint32_t* const SPDIFRX_SR_PTR   = (RO_ uint32_t* const)0x40004008U;   /** @brief Status register */
  static WO_ uint32_t* const SPDIFRX_IFCR_PTR = (WO_ uint32_t* const)0x4000400CU;   /** @brief Interrupt flag clear register */
  static RO_ uint32_t* const SPDIFRX_CSR_PTR  = (RO_ uint32_t* const)0x40004014U;   /** @brief Channel status register */
  static RO_ uint32_t* const SPDIFRX_DIR_PTR  = (RO_ uint32_t* const)0x40004018U;   /** @brief Debug information register */
  static RO_ uint32_t* const SPDIFRX_VERR_PTR = (RO_ uint32_t* const)0x400043F4U;   /** @brief SPDIFRX version register */
  static RO_ uint32_t* const SPDIFRX_IDR_PTR  = (RO_ uint32_t* const)0x400043F8U;   /** @brief SPDIFRX identification register */
  static RO_ uint32_t* const SPDIFRX_SIDR_PTR = (RO_ uint32_t* const)0x400043FCU;   /** @brief SPDIFRX size identification register */

  /**** @subsection Enumerated SPDIFRX Register Pointers ****/

  static RO_ uint32_t* const SPDIFRX_DR_x_PTR[11] = {
    [0]  = (RO_ uint32_t* const)0x40004010U,   /** @brief Data input register */
    [10] = (RO_ uint32_t* const)0x40004010U,   /** @brief Data input register */
  };

  static RO_ uint32_t* const SPDIFRX_DR_0x_PTR[2] = {
    [1] = (RO_ uint32_t* const)0x40004010U,   /** @brief Data input register */
  };

  /**** @subsection SPDIFRX Register Field Masks ****/

  static const uint32_t SPDIFRX_CR_SPDIFRXEN_MSK = 0x00000003U;   /** @brief Peripheral block enable */
  static const uint32_t SPDIFRX_CR_RXDMAEN_MSK   = 0x00000004U;   /** @brief Receiver DMA enable for data flow */
  static const uint32_t SPDIFRX_CR_RXSTEO_MSK    = 0x00000008U;   /** @brief STerEO mode */
  static const uint32_t SPDIFRX_CR_DRFMT_MSK     = 0x00000030U;   /** @brief RX data format */
  static const uint32_t SPDIFRX_CR_PMSK_MSK      = 0x00000040U;   /** @brief Mask parity error bit */
  static const uint32_t SPDIFRX_CR_VMSK_MSK      = 0x00000080U;   /** @brief Mask of validity bit */
  static const uint32_t SPDIFRX_CR_CUMSK_MSK     = 0x00000100U;   /** @brief Mask of channel status and user bits */
  static const uint32_t SPDIFRX_CR_PTMSK_MSK     = 0x00000200U;   /** @brief Mask of preamble type bits */
  static const uint32_t SPDIFRX_CR_CBDMAEN_MSK   = 0x00000400U;   /** @brief Control buffer DMA enable for control flow */
  static const uint32_t SPDIFRX_CR_CHSEL_MSK     = 0x00000800U;   /** @brief Channel selection */
  static const uint32_t SPDIFRX_CR_NBTR_MSK      = 0x00003000U;   /** @brief Maximum allowed re-tries during synchronization phase */
  static const uint32_t SPDIFRX_CR_WFA_MSK       = 0x00004000U;   /** @brief Wait for activity */
  static const uint32_t SPDIFRX_CR_INSEL_MSK     = 0x00070000U;   /** @brief Input selection */
  static const uint32_t SPDIFRX_CR_CKSEN_MSK     = 0x00100000U;   /** @brief Symbol clock enable */
  static const uint32_t SPDIFRX_CR_CKSBKPEN_MSK  = 0x00200000U;   /** @brief Backup symbol clock enable */
  static const uint32_t SPDIFRX_IMR_RXNEIE_MSK   = 0x00000001U;   /** @brief RXNE interrupt enable */
  static const uint32_t SPDIFRX_IMR_CSRNEIE_MSK  = 0x00000002U;   /** @brief Control buffer ready interrupt enable */
  static const uint32_t SPDIFRX_IMR_PERRIE_MSK   = 0x00000004U;   /** @brief Parity error interrupt enable */
  static const uint32_t SPDIFRX_IMR_OVRIE_MSK    = 0x00000008U;   /** @brief Overrun error interrupt enable */
  static const uint32_t SPDIFRX_IMR_SBLKIE_MSK   = 0x00000010U;   /** @brief Synchronization block detected interrupt enable */
  static const uint32_t SPDIFRX_IMR_SYNCDIE_MSK  = 0x00000020U;   /** @brief Synchronization done */
  static const uint32_t SPDIFRX_IMR_IFEIE_MSK    = 0x00000040U;   /** @brief Serial interface error interrupt enable */
  static const uint32_t SPDIFRX_SR_RXNE_MSK      = 0x00000001U;   /** @brief Read data register not empty */
  static const uint32_t SPDIFRX_SR_CSRNE_MSK     = 0x00000002U;   /** @brief Control buffer register is not empty */
  static const uint32_t SPDIFRX_SR_PERR_MSK      = 0x00000004U;   /** @brief Parity error */
  static const uint32_t SPDIFRX_SR_OVR_MSK       = 0x00000008U;   /** @brief Overrun error */
  static const uint32_t SPDIFRX_SR_SBD_MSK       = 0x00000010U;   /** @brief Synchronization block detected */
  static const uint32_t SPDIFRX_SR_SYNCD_MSK     = 0x00000020U;   /** @brief Synchronization done */
  static const uint32_t SPDIFRX_SR_FERR_MSK      = 0x00000040U;   /** @brief Framing error */
  static const uint32_t SPDIFRX_SR_SERR_MSK      = 0x00000080U;   /** @brief Synchronization error */
  static const uint32_t SPDIFRX_SR_TERR_MSK      = 0x00000100U;   /** @brief Time-out error */
  static const uint32_t SPDIFRX_SR_WIDTH5_MSK    = 0x7FFF0000U;   /** @brief Duration of 5 symbols counted with SPDIF_CLK */
  static const uint32_t SPDIFRX_IFCR_PERRCF_MSK  = 0x00000004U;   /** @brief Clears the parity error flag */
  static const uint32_t SPDIFRX_IFCR_OVRCF_MSK   = 0x00000008U;   /** @brief Clears the overrun error flag */
  static const uint32_t SPDIFRX_IFCR_SBDCF_MSK   = 0x00000010U;   /** @brief Clears the synchronization block detected flag */
  static const uint32_t SPDIFRX_IFCR_SYNCDCF_MSK = 0x00000020U;   /** @brief Clears the synchronization done flag */
  static const uint32_t SPDIFRX_DR_x_DR_MSK      = 0x00FFFFFFU;   /** @brief Parity error bit */
  static const uint32_t SPDIFRX_DR_x_PE_MSK      = 0x01000000U;   /** @brief Parity error bit */
  static const uint32_t SPDIFRX_DR_x_V_MSK       = 0x02000000U;   /** @brief Validity bit */
  static const uint32_t SPDIFRX_DR_x_U_MSK       = 0x04000000U;   /** @brief User bit */
  static const uint32_t SPDIFRX_DR_x_C_MSK       = 0x08000000U;   /** @brief Channel status bit */
  static const uint32_t SPDIFRX_DR_x_PT_MSK      = 0x30000000U;   /** @brief Preamble type */
  static const uint32_t SPDIFRX_CSR_USR_MSK      = 0x0000FFFFU;   /** @brief User data information */
  static const uint32_t SPDIFRX_CSR_CS_MSK       = 0x00FF0000U;   /** @brief Channel A status information */
  static const uint32_t SPDIFRX_CSR_SOB_MSK      = 0x01000000U;   /** @brief Start of block */
  static const uint32_t SPDIFRX_DIR_THI_MSK      = 0x00001FFFU;   /** @brief Threshold HIGH */
  static const uint32_t SPDIFRX_DIR_TLO_MSK      = 0x1FFF0000U;   /** @brief Threshold LOW */
  static const uint32_t SPDIFRX_VERR_MINREV_MSK  = 0x0000000FU;   /** @brief Minor revision */
  static const uint32_t SPDIFRX_VERR_MAJREV_MSK  = 0x000000F0U;   /** @brief Major revision */
  static const uint32_t SPDIFRX_DR_0x_PE_MSK     = 0x00000001U;   /** @brief Parity error bit */
  static const uint32_t SPDIFRX_DR_0x_V_MSK      = 0x00000002U;   /** @brief Validity bit */
  static const uint32_t SPDIFRX_DR_0x_U_MSK      = 0x00000004U;   /** @brief User bit */
  static const uint32_t SPDIFRX_DR_0x_C_MSK      = 0x00000008U;   /** @brief Channel status bit */
  static const uint32_t SPDIFRX_DR_0x_PT_MSK     = 0x00000030U;   /** @brief Preamble type */
  static const uint32_t SPDIFRX_DR_0x_DR_MSK     = 0xFFFFFF00U;   /** @brief Data value */

  /**** @subsection SPDIFRX Register Field Positions ****/

  static const int32_t SPDIFRX_CR_SPDIFRXEN_POS = 0;    /** @brief Peripheral block enable */
  static const int32_t SPDIFRX_CR_RXDMAEN_POS   = 2;    /** @brief Receiver DMA enable for data flow */
  static const int32_t SPDIFRX_CR_RXSTEO_POS    = 3;    /** @brief STerEO mode */
  static const int32_t SPDIFRX_CR_DRFMT_POS     = 4;    /** @brief RX data format */
  static const int32_t SPDIFRX_CR_PMSK_POS      = 6;    /** @brief Mask parity error bit */
  static const int32_t SPDIFRX_CR_VMSK_POS      = 7;    /** @brief Mask of validity bit */
  static const int32_t SPDIFRX_CR_CUMSK_POS     = 8;    /** @brief Mask of channel status and user bits */
  static const int32_t SPDIFRX_CR_PTMSK_POS     = 9;    /** @brief Mask of preamble type bits */
  static const int32_t SPDIFRX_CR_CBDMAEN_POS   = 10;   /** @brief Control buffer DMA enable for control flow */
  static const int32_t SPDIFRX_CR_CHSEL_POS     = 11;   /** @brief Channel selection */
  static const int32_t SPDIFRX_CR_NBTR_POS      = 12;   /** @brief Maximum allowed re-tries during synchronization phase */
  static const int32_t SPDIFRX_CR_WFA_POS       = 14;   /** @brief Wait for activity */
  static const int32_t SPDIFRX_CR_INSEL_POS     = 16;   /** @brief Input selection */
  static const int32_t SPDIFRX_CR_CKSEN_POS     = 20;   /** @brief Symbol clock enable */
  static const int32_t SPDIFRX_CR_CKSBKPEN_POS  = 21;   /** @brief Backup symbol clock enable */
  static const int32_t SPDIFRX_IMR_RXNEIE_POS   = 0;    /** @brief RXNE interrupt enable */
  static const int32_t SPDIFRX_IMR_CSRNEIE_POS  = 1;    /** @brief Control buffer ready interrupt enable */
  static const int32_t SPDIFRX_IMR_PERRIE_POS   = 2;    /** @brief Parity error interrupt enable */
  static const int32_t SPDIFRX_IMR_OVRIE_POS    = 3;    /** @brief Overrun error interrupt enable */
  static const int32_t SPDIFRX_IMR_SBLKIE_POS   = 4;    /** @brief Synchronization block detected interrupt enable */
  static const int32_t SPDIFRX_IMR_SYNCDIE_POS  = 5;    /** @brief Synchronization done */
  static const int32_t SPDIFRX_IMR_IFEIE_POS    = 6;    /** @brief Serial interface error interrupt enable */
  static const int32_t SPDIFRX_SR_RXNE_POS      = 0;    /** @brief Read data register not empty */
  static const int32_t SPDIFRX_SR_CSRNE_POS     = 1;    /** @brief Control buffer register is not empty */
  static const int32_t SPDIFRX_SR_PERR_POS      = 2;    /** @brief Parity error */
  static const int32_t SPDIFRX_SR_OVR_POS       = 3;    /** @brief Overrun error */
  static const int32_t SPDIFRX_SR_SBD_POS       = 4;    /** @brief Synchronization block detected */
  static const int32_t SPDIFRX_SR_SYNCD_POS     = 5;    /** @brief Synchronization done */
  static const int32_t SPDIFRX_SR_FERR_POS      = 6;    /** @brief Framing error */
  static const int32_t SPDIFRX_SR_SERR_POS      = 7;    /** @brief Synchronization error */
  static const int32_t SPDIFRX_SR_TERR_POS      = 8;    /** @brief Time-out error */
  static const int32_t SPDIFRX_SR_WIDTH5_POS    = 16;   /** @brief Duration of 5 symbols counted with SPDIF_CLK */
  static const int32_t SPDIFRX_IFCR_PERRCF_POS  = 2;    /** @brief Clears the parity error flag */
  static const int32_t SPDIFRX_IFCR_OVRCF_POS   = 3;    /** @brief Clears the overrun error flag */
  static const int32_t SPDIFRX_IFCR_SBDCF_POS   = 4;    /** @brief Clears the synchronization block detected flag */
  static const int32_t SPDIFRX_IFCR_SYNCDCF_POS = 5;    /** @brief Clears the synchronization done flag */
  static const int32_t SPDIFRX_DR_x_DR_POS      = 0;    /** @brief Parity error bit */
  static const int32_t SPDIFRX_DR_x_PE_POS      = 24;   /** @brief Parity error bit */
  static const int32_t SPDIFRX_DR_x_V_POS       = 25;   /** @brief Validity bit */
  static const int32_t SPDIFRX_DR_x_U_POS       = 26;   /** @brief User bit */
  static const int32_t SPDIFRX_DR_x_C_POS       = 27;   /** @brief Channel status bit */
  static const int32_t SPDIFRX_DR_x_PT_POS      = 28;   /** @brief Preamble type */
  static const int32_t SPDIFRX_CSR_USR_POS      = 0;    /** @brief User data information */
  static const int32_t SPDIFRX_CSR_CS_POS       = 16;   /** @brief Channel A status information */
  static const int32_t SPDIFRX_CSR_SOB_POS      = 24;   /** @brief Start of block */
  static const int32_t SPDIFRX_DIR_THI_POS      = 0;    /** @brief Threshold HIGH */
  static const int32_t SPDIFRX_DIR_TLO_POS      = 16;   /** @brief Threshold LOW */
  static const int32_t SPDIFRX_VERR_MINREV_POS  = 0;    /** @brief Minor revision */
  static const int32_t SPDIFRX_VERR_MAJREV_POS  = 4;    /** @brief Major revision */
  static const int32_t SPDIFRX_DR_0x_PE_POS     = 0;    /** @brief Parity error bit */
  static const int32_t SPDIFRX_DR_0x_V_POS      = 1;    /** @brief Validity bit */
  static const int32_t SPDIFRX_DR_0x_U_POS      = 2;    /** @brief User bit */
  static const int32_t SPDIFRX_DR_0x_C_POS      = 3;    /** @brief Channel status bit */
  static const int32_t SPDIFRX_DR_0x_PT_POS     = 4;    /** @brief Preamble type */
  static const int32_t SPDIFRX_DR_0x_DR_POS     = 8;    /** @brief Data value */

  /**********************************************************************************************
   * @section ADCx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated ADCx Register Pointers ****/

  static RW_ uint32_t* const ADCx_ISR_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x40022000U,   /** @brief ADC interrupt and status register */
    [2] = (RW_ uint32_t* const)0x40022100U,   /** @brief ADC interrupt and status register */
    [3] = (RW_ uint32_t* const)0x58026000U,   /** @brief ADC interrupt and status register */
  };

  static RW_ uint32_t* const ADCx_IER_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x40022004U,   /** @brief ADC interrupt enable register */
    [2] = (RW_ uint32_t* const)0x40022104U,   /** @brief ADC interrupt enable register */
    [3] = (RW_ uint32_t* const)0x58026004U,   /** @brief ADC interrupt enable register */
  };

  static RW_ uint32_t* const ADCx_CR_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x40022008U,   /** @brief ADC control register */
    [2] = (RW_ uint32_t* const)0x40022108U,   /** @brief ADC control register */
    [3] = (RW_ uint32_t* const)0x58026008U,   /** @brief ADC control register */
  };

  static RW_ uint32_t* const ADCx_CFGR_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x4002200CU,   /** @brief ADC configuration register 1 */
    [2] = (RW_ uint32_t* const)0x4002210CU,   /** @brief ADC configuration register 1 */
    [3] = (RW_ uint32_t* const)0x5802600CU,   /** @brief ADC configuration register 1 */
  };

  static RW_ uint32_t* const ADCx_CFGR2_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x40022010U,   /** @brief ADC configuration register 2 */
    [2] = (RW_ uint32_t* const)0x40022110U,   /** @brief ADC configuration register 2 */
    [3] = (RW_ uint32_t* const)0x58026010U,   /** @brief ADC configuration register 2 */
  };

  static RW_ uint32_t* const ADCx_SMPRx_PTR[4][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40022014U,   /** @brief ADC sampling time register 1 */
      [2] = (RW_ uint32_t* const)0x40022018U,   /** @brief ADC sampling time register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40022114U,   /** @brief ADC sampling time register 1 */
      [2] = (RW_ uint32_t* const)0x40022118U,   /** @brief ADC sampling time register 2 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58026014U,   /** @brief ADC sampling time register 1 */
      [2] = (RW_ uint32_t* const)0x58026018U,   /** @brief ADC sampling time register 2 */
    },
  };

  static RW_ uint32_t* const ADCx_LTRx_PTR[4][4] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40022020U,   /** @brief ADC analog watchdog 1 threshold register */
      [2] = (RW_ uint32_t* const)0x400220B0U,   /** @brief ADC watchdog lower threshold register 2 */
      [3] = (RW_ uint32_t* const)0x400220B8U,   /** @brief ADC watchdog lower threshold register 3 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40022120U,   /** @brief ADC analog watchdog 1 threshold register */
      [2] = (RW_ uint32_t* const)0x400221B0U,   /** @brief ADC watchdog lower threshold register 2 */
      [3] = (RW_ uint32_t* const)0x400221B8U,   /** @brief ADC watchdog lower threshold register 3 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58026020U,   /** @brief ADC analog watchdog 1 threshold register */
      [2] = (RW_ uint32_t* const)0x580260B0U,   /** @brief ADC watchdog lower threshold register 2 */
      [3] = (RW_ uint32_t* const)0x580260B8U,   /** @brief ADC watchdog lower threshold register 3 */
    },
  };

  static RW_ uint32_t* const ADCx_LHTR1_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x40022024U,   /** @brief ADC analog watchdog 2 threshold register */
    [2] = (RW_ uint32_t* const)0x40022124U,   /** @brief ADC analog watchdog 2 threshold register */
    [3] = (RW_ uint32_t* const)0x58026024U,   /** @brief ADC analog watchdog 2 threshold register */
  };

  static RW_ uint32_t* const ADCx_SQRx_PTR[4][5] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40022030U,   /** @brief ADC group regular sequencer ranks register 1 */
      [2] = (RW_ uint32_t* const)0x40022034U,   /** @brief ADC group regular sequencer ranks register 2 */
      [3] = (RW_ uint32_t* const)0x40022038U,   /** @brief ADC group regular sequencer ranks register 3 */
      [4] = (RW_ uint32_t* const)0x4002203CU,   /** @brief ADC group regular sequencer ranks register 4 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40022130U,   /** @brief ADC group regular sequencer ranks register 1 */
      [2] = (RW_ uint32_t* const)0x40022134U,   /** @brief ADC group regular sequencer ranks register 2 */
      [3] = (RW_ uint32_t* const)0x40022138U,   /** @brief ADC group regular sequencer ranks register 3 */
      [4] = (RW_ uint32_t* const)0x4002213CU,   /** @brief ADC group regular sequencer ranks register 4 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58026030U,   /** @brief ADC group regular sequencer ranks register 1 */
      [2] = (RW_ uint32_t* const)0x58026034U,   /** @brief ADC group regular sequencer ranks register 2 */
      [3] = (RW_ uint32_t* const)0x58026038U,   /** @brief ADC group regular sequencer ranks register 3 */
      [4] = (RW_ uint32_t* const)0x5802603CU,   /** @brief ADC group regular sequencer ranks register 4 */
    },
  };

  static RO_ uint32_t* const ADCx_DR_PTR[4] = {
    [1] = (RO_ uint32_t* const)0x40022040U,   /** @brief ADC group regular conversion data register */
    [2] = (RO_ uint32_t* const)0x40022140U,   /** @brief ADC group regular conversion data register */
    [3] = (RO_ uint32_t* const)0x58026040U,   /** @brief ADC group regular conversion data register */
  };

  static RW_ uint32_t* const ADCx_JSQR_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x4002204CU,   /** @brief ADC group injected sequencer register */
    [2] = (RW_ uint32_t* const)0x4002214CU,   /** @brief ADC group injected sequencer register */
    [3] = (RW_ uint32_t* const)0x5802604CU,   /** @brief ADC group injected sequencer register */
  };

  static RW_ uint32_t* const ADCx_OFRx_PTR[4][5] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40022060U,   /** @brief ADC offset number 1 register */
      [2] = (RW_ uint32_t* const)0x40022064U,   /** @brief ADC offset number 2 register */
      [3] = (RW_ uint32_t* const)0x40022068U,   /** @brief ADC offset number 3 register */
      [4] = (RW_ uint32_t* const)0x4002206CU,   /** @brief ADC offset number 4 register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40022160U,   /** @brief ADC offset number 1 register */
      [2] = (RW_ uint32_t* const)0x40022164U,   /** @brief ADC offset number 2 register */
      [3] = (RW_ uint32_t* const)0x40022168U,   /** @brief ADC offset number 3 register */
      [4] = (RW_ uint32_t* const)0x4002216CU,   /** @brief ADC offset number 4 register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58026060U,   /** @brief ADC offset number 1 register */
      [2] = (RW_ uint32_t* const)0x58026064U,   /** @brief ADC offset number 2 register */
      [3] = (RW_ uint32_t* const)0x58026068U,   /** @brief ADC offset number 3 register */
      [4] = (RW_ uint32_t* const)0x5802606CU,   /** @brief ADC offset number 4 register */
    },
  };

  static RO_ uint32_t* const ADCx_JDRx_PTR[4][5] = {
    [0] = {
      [1] = (RO_ uint32_t* const)0x40022080U,   /** @brief ADC group injected sequencer rank 1 register */
      [2] = (RO_ uint32_t* const)0x40022084U,   /** @brief ADC group injected sequencer rank 2 register */
      [3] = (RO_ uint32_t* const)0x40022088U,   /** @brief ADC group injected sequencer rank 3 register */
      [4] = (RO_ uint32_t* const)0x4002208CU,   /** @brief ADC group injected sequencer rank 4 register */
    },
    [1] = {
      [1] = (RO_ uint32_t* const)0x40022180U,   /** @brief ADC group injected sequencer rank 1 register */
      [2] = (RO_ uint32_t* const)0x40022184U,   /** @brief ADC group injected sequencer rank 2 register */
      [3] = (RO_ uint32_t* const)0x40022188U,   /** @brief ADC group injected sequencer rank 3 register */
      [4] = (RO_ uint32_t* const)0x4002218CU,   /** @brief ADC group injected sequencer rank 4 register */
    },
    [2] = {
      [1] = (RO_ uint32_t* const)0x58026080U,   /** @brief ADC group injected sequencer rank 1 register */
      [2] = (RO_ uint32_t* const)0x58026084U,   /** @brief ADC group injected sequencer rank 2 register */
      [3] = (RO_ uint32_t* const)0x58026088U,   /** @brief ADC group injected sequencer rank 3 register */
      [4] = (RO_ uint32_t* const)0x5802608CU,   /** @brief ADC group injected sequencer rank 4 register */
    },
  };

  static RW_ uint32_t* const ADCx_AWDxCR_PTR[4][4] = {
    [0] = {
      [2] = (RW_ uint32_t* const)0x400220A0U,   /** @brief ADC analog watchdog 2 configuration register */
      [3] = (RW_ uint32_t* const)0x400220A4U,   /** @brief ADC analog watchdog 3 configuration register */
    },
    [1] = {
      [2] = (RW_ uint32_t* const)0x400221A0U,   /** @brief ADC analog watchdog 2 configuration register */
      [3] = (RW_ uint32_t* const)0x400221A4U,   /** @brief ADC analog watchdog 3 configuration register */
    },
    [2] = {
      [2] = (RW_ uint32_t* const)0x580260A0U,   /** @brief ADC analog watchdog 2 configuration register */
      [3] = (RW_ uint32_t* const)0x580260A4U,   /** @brief ADC analog watchdog 3 configuration register */
    },
  };

  static RW_ uint32_t* const ADCx_DIFSEL_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400220C0U,   /** @brief ADC channel differential or single-ended mode selection register */
    [2] = (RW_ uint32_t* const)0x400221C0U,   /** @brief ADC channel differential or single-ended mode selection register */
    [3] = (RW_ uint32_t* const)0x580260C0U,   /** @brief ADC channel differential or single-ended mode selection register */
  };

  static RW_ uint32_t* const ADCx_CALFACT_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400220C4U,   /** @brief ADC calibration factors register */
    [2] = (RW_ uint32_t* const)0x400221C4U,   /** @brief ADC calibration factors register */
    [3] = (RW_ uint32_t* const)0x580260C4U,   /** @brief ADC calibration factors register */
  };

  static RW_ uint32_t* const ADCx_PCSEL_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x4002201CU,   /** @brief ADC pre channel selection register */
    [2] = (RW_ uint32_t* const)0x4002211CU,   /** @brief ADC pre channel selection register */
    [3] = (RW_ uint32_t* const)0x5802601CU,   /** @brief ADC pre channel selection register */
  };

  static RW_ uint32_t* const ADCx_HTRx_PTR[4][4] = {
    [0] = {
      [2] = (RW_ uint32_t* const)0x400220B4U,   /** @brief ADC watchdog higher threshold register 2 */
      [3] = (RW_ uint32_t* const)0x400220BCU,   /** @brief ADC watchdog higher threshold register 3 */
    },
    [1] = {
      [2] = (RW_ uint32_t* const)0x400221B4U,   /** @brief ADC watchdog higher threshold register 2 */
      [3] = (RW_ uint32_t* const)0x400221BCU,   /** @brief ADC watchdog higher threshold register 3 */
    },
    [2] = {
      [2] = (RW_ uint32_t* const)0x580260B4U,   /** @brief ADC watchdog higher threshold register 2 */
      [3] = (RW_ uint32_t* const)0x580260BCU,   /** @brief ADC watchdog higher threshold register 3 */
    },
  };

  static RW_ uint32_t* const ADCx_CALFACT2_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400220C8U,   /** @brief ADC calibration factor register 2 */
    [2] = (RW_ uint32_t* const)0x400221C8U,   /** @brief ADC calibration factor register 2 */
    [3] = (RW_ uint32_t* const)0x580260C8U,   /** @brief ADC calibration factor register 2 */
  };

  /**** @subsection ADCx Register Field Masks ****/

  static const uint32_t ADCx_ISR_JQOVF_MSK           = 0x00000400U;   /** @brief ADC group injected contexts queue overflow flag */
  static const uint32_t ADCx_ISR_JEOS_MSK            = 0x00000040U;   /** @brief ADC group injected end of sequence conversions flag */
  static const uint32_t ADCx_ISR_JEOC_MSK            = 0x00000020U;   /** @brief ADC group injected end of unitary conversion flag */
  static const uint32_t ADCx_ISR_OVR_MSK             = 0x00000010U;   /** @brief ADC group regular overrun flag */
  static const uint32_t ADCx_ISR_EOS_MSK             = 0x00000008U;   /** @brief ADC group regular end of sequence conversions flag */
  static const uint32_t ADCx_ISR_EOC_MSK             = 0x00000004U;   /** @brief ADC group regular end of unitary conversion flag */
  static const uint32_t ADCx_ISR_EOSMP_MSK           = 0x00000002U;   /** @brief ADC group regular end of sampling flag */
  static const uint32_t ADCx_ISR_ADRDY_MSK           = 0x00000001U;   /** @brief ADC ready flag */
  static const uint32_t ADCx_IER_JQOVFIE_MSK         = 0x00000400U;   /** @brief ADC group injected contexts queue overflow interrupt */
  static const uint32_t ADCx_IER_JEOSIE_MSK          = 0x00000040U;   /** @brief ADC group injected end of sequence conversions interrupt */
  static const uint32_t ADCx_IER_JEOCIE_MSK          = 0x00000020U;   /** @brief ADC group injected end of unitary conversion interrupt */
  static const uint32_t ADCx_IER_OVRIE_MSK           = 0x00000010U;   /** @brief ADC group regular overrun interrupt */
  static const uint32_t ADCx_IER_EOSIE_MSK           = 0x00000008U;   /** @brief ADC group regular end of sequence conversions interrupt */
  static const uint32_t ADCx_IER_EOCIE_MSK           = 0x00000004U;   /** @brief ADC group regular end of unitary conversion interrupt */
  static const uint32_t ADCx_IER_EOSMPIE_MSK         = 0x00000002U;   /** @brief ADC group regular end of sampling interrupt */
  static const uint32_t ADCx_IER_ADRDYIE_MSK         = 0x00000001U;   /** @brief ADC ready interrupt */
  static const uint32_t ADCx_CR_ADCAL_MSK            = 0x80000000U;   /** @brief ADC calibration */
  static const uint32_t ADCx_CR_ADCALDIF_MSK         = 0x40000000U;   /** @brief ADC differential mode for calibration */
  static const uint32_t ADCx_CR_DEEPPWD_MSK          = 0x20000000U;   /** @brief ADC deep power down enable */
  static const uint32_t ADCx_CR_ADVREGEN_MSK         = 0x10000000U;   /** @brief ADC voltage regulator enable */
  static const uint32_t ADCx_CR_ADCALLIN_MSK         = 0x00010000U;   /** @brief Linearity calibration */
  static const uint32_t ADCx_CR_BOOST_MSK            = 0x00000300U;   /** @brief Boost mode control */
  static const uint32_t ADCx_CR_JADSTP_MSK           = 0x00000020U;   /** @brief ADC group injected conversion stop */
  static const uint32_t ADCx_CR_ADSTP_MSK            = 0x00000010U;   /** @brief ADC group regular conversion stop */
  static const uint32_t ADCx_CR_JADSTART_MSK         = 0x00000008U;   /** @brief ADC group injected conversion start */
  static const uint32_t ADCx_CR_ADSTART_MSK          = 0x00000004U;   /** @brief ADC group regular conversion start */
  static const uint32_t ADCx_CR_ADDIS_MSK            = 0x00000002U;   /** @brief ADC disable */
  static const uint32_t ADCx_CR_ADEN_MSK             = 0x00000001U;   /** @brief ADC enable */
  static const uint32_t ADCx_CFGR_JQDIS_MSK          = 0x80000000U;   /** @brief ADC group injected contexts queue disable */
  static const uint32_t ADCx_CFGR_AWDCH1CH_MSK       = 0x7C000000U;   /** @brief ADC analog watchdog 1 monitored channel selection */
  static const uint32_t ADCx_CFGR_JAUTO_MSK          = 0x02000000U;   /** @brief ADC group injected automatic trigger mode */
  static const uint32_t ADCx_CFGR_JAWD1EN_MSK        = 0x01000000U;   /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
  static const uint32_t ADCx_CFGR_AWD1EN_MSK         = 0x00800000U;   /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
  static const uint32_t ADCx_CFGR_AWD1SGL_MSK        = 0x00400000U;   /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
  static const uint32_t ADCx_CFGR_JQM_MSK            = 0x00200000U;   /** @brief ADC group injected contexts queue mode */
  static const uint32_t ADCx_CFGR_JDISCEN_MSK        = 0x00100000U;   /** @brief ADC group injected sequencer discontinuous mode */
  static const uint32_t ADCx_CFGR_DISCNUM_MSK        = 0x000E0000U;   /** @brief ADC group regular sequencer discontinuous number of ranks */
  static const uint32_t ADCx_CFGR_DISCEN_MSK         = 0x00010000U;   /** @brief ADC group regular sequencer discontinuous mode */
  static const uint32_t ADCx_CFGR_AUTDLY_MSK         = 0x00004000U;   /** @brief ADC low power auto wait */
  static const uint32_t ADCx_CFGR_CONT_MSK           = 0x00002000U;   /** @brief ADC group regular continuous conversion mode */
  static const uint32_t ADCx_CFGR_OVRMOD_MSK         = 0x00001000U;   /** @brief ADC group regular overrun configuration */
  static const uint32_t ADCx_CFGR_EXTEN_MSK          = 0x00000C00U;   /** @brief ADC group regular external trigger polarity */
  static const uint32_t ADCx_CFGR_EXTSEL_MSK         = 0x000003E0U;   /** @brief ADC group regular external trigger source */
  static const uint32_t ADCx_CFGR_RES_MSK            = 0x0000001CU;   /** @brief ADC data resolution */
  static const uint32_t ADCx_CFGR_DMNGT_MSK          = 0x00000003U;   /** @brief ADC DMA transfer enable */
  static const uint32_t ADCx_CFGR2_ROVSE_MSK         = 0x00000001U;   /** @brief ADC oversampler enable on scope ADC group regular */
  static const uint32_t ADCx_CFGR2_JOVSE_MSK         = 0x00000002U;   /** @brief ADC oversampler enable on scope ADC group injected */
  static const uint32_t ADCx_CFGR2_OVSS_MSK          = 0x000001E0U;   /** @brief ADC oversampling shift */
  static const uint32_t ADCx_CFGR2_TROVS_MSK         = 0x00000200U;   /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
  static const uint32_t ADCx_CFGR2_ROVSM_MSK         = 0x00000400U;   /** @brief Regular oversampling mode */
  static const uint32_t ADCx_CFGR2_OSR_MSK           = 0x03FF0000U;   /** @brief Oversampling ratio */
  static const uint32_t ADCx_CFGR2_LSHIFT_MSK        = 0xF0000000U;   /** @brief Left shift factor */
  static const uint32_t ADCx_LTRx_LTR1_MSK           = 0x03FFFFFFU;   /** @brief ADC analog watchdog 1 threshold low */
  static const uint32_t ADCx_LHTR1_LHTR1_MSK         = 0x03FFFFFFU;   /** @brief ADC analog watchdog 2 threshold low */
  static const uint32_t ADCx_SQRx_L3_MSK             = 0x0000000FU;   /** @brief L3 */
  static const uint32_t ADCx_DR_RDATA_MSK            = 0x0000FFFFU;   /** @brief ADC group regular conversion data */
  static const uint32_t ADCx_JSQR_JEXTEN_MSK         = 0x00000180U;   /** @brief ADC group injected external trigger polarity */
  static const uint32_t ADCx_JSQR_JEXTSEL_MSK        = 0x0000007CU;   /** @brief ADC group injected external trigger source */
  static const uint32_t ADCx_JSQR_JL_MSK             = 0x00000003U;   /** @brief ADC group injected sequencer scan length */
  static const uint32_t ADCx_OFRx_SSATE_MSK          = 0x80000000U;   /** @brief ADC offset number 1 enable */
  static const uint32_t ADCx_OFRx_OFFSET1_CH_MSK     = 0x7C000000U;   /** @brief ADC offset number 1 channel selection */
  static const uint32_t ADCx_OFRx_OFFSET1_MSK        = 0x03FFFFFFU;   /** @brief ADC offset number 1 offset level */
  static const uint32_t ADCx_AWDxCR_AWD2CH_MSK       = 0x000FFFFFU;   /** @brief ADC analog watchdog 2 monitored channel selection */
  static const uint32_t ADCx_DIFSEL_DIFSEL_MSK       = 0x000FFFFFU;   /** @brief ADC channel differential or single-ended mode for channel */
  static const uint32_t ADCx_CALFACT_CALFACT_D_MSK   = 0x07FF0000U;   /** @brief ADC calibration factor in differential mode */
  static const uint32_t ADCx_CALFACT_CALFACT_S_MSK   = 0x000007FFU;   /** @brief ADC calibration factor in single-ended mode */
  static const uint32_t ADCx_PCSEL_PCSEL_MSK         = 0x000FFFFFU;   /** @brief Channel x (vinp[i]) pre selection */
  static const uint32_t ADCx_HTRx_HTR2_MSK           = 0x03FFFFFFU;   /** @brief Analog watchdog 2 higher threshold */
  static const uint32_t ADCx_CALFACT2_LINCALFACT_MSK = 0x3FFFFFFFU;   /** @brief Linearity calibration factor */

  /**** @subsection Enumerated ADCx Register Field Masks ****/

  static const uint32_t ADCx_ISR_AWDx_MSK[4] = {
    [1] = 0x00000080U,   /** @brief ADC analog watchdog 1 flag */
    [2] = 0x00000100U,   /** @brief ADC analog watchdog 2 flag */
    [3] = 0x00000200U,   /** @brief ADC analog watchdog 3 flag */
  };

  static const uint32_t ADCx_IER_AWDxIE_MSK[4] = {
    [1] = 0x00000080U,   /** @brief ADC analog watchdog 1 interrupt */
    [2] = 0x00000100U,   /** @brief ADC analog watchdog 2 interrupt */
    [3] = 0x00000200U,   /** @brief ADC analog watchdog 3 interrupt */
  };

  static const uint32_t ADCx_CR_LINCALRDYWx_MSK[7] = {
    [1] = 0x00400000U,   /** @brief Linearity calibration ready word 1 */
    [2] = 0x00800000U,   /** @brief Linearity calibration ready word 2 */
    [3] = 0x01000000U,   /** @brief Linearity calibration ready word 3 */
    [4] = 0x02000000U,   /** @brief Linearity calibration ready word 4 */
    [5] = 0x04000000U,   /** @brief Linearity calibration ready word 5 */
    [6] = 0x08000000U,   /** @brief Linearity calibration ready word 6 */
  };

  static const uint32_t ADCx_CFGR2_RSHIFTx_MSK[5] = {
    [1] = 0x00000800U,   /** @brief Right-shift data after offset 1 correction */
    [2] = 0x00001000U,   /** @brief Right-shift data after offset 2 correction */
    [3] = 0x00002000U,   /** @brief Right-shift data after offset 3 correction */
    [4] = 0x00004000U,   /** @brief Right-shift data after offset 4 correction */
  };

  static const uint32_t ADCx_SMPRx_SMPx_MSK[10] = {
    [1]  = 0x00000038U,   /** @brief ADC channel 1 sampling time selection */
    [2]  = 0x000001C0U,   /** @brief ADC channel 2 sampling time selection */
    [3]  = 0x00000E00U,   /** @brief ADC channel 3 sampling time selection */
    [4]  = 0x00007000U,   /** @brief ADC channel 4 sampling time selection */
    [5]  = 0x00038000U,   /** @brief ADC channel 5 sampling time selection */
    [6]  = 0x001C0000U,   /** @brief ADC channel 6 sampling time selection */
    [7]  = 0x00E00000U,   /** @brief ADC channel 7 sampling time selection */
    [8]  = 0x07000000U,   /** @brief ADC channel 8 sampling time selection */
    [9]  = 0x38000000U,   /** @brief ADC channel 9 sampling time selection */
  };

  static const uint32_t ADCx_SQRx_SQx_MSK[5] = {
    [1] = 0x000007C0U,   /** @brief ADC group regular sequencer rank 1 */
    [2] = 0x0001F000U,   /** @brief ADC group regular sequencer rank 2 */
    [3] = 0x007C0000U,   /** @brief ADC group regular sequencer rank 3 */
    [4] = 0x1F000000U,   /** @brief ADC group regular sequencer rank 4 */
  };

  static const uint32_t ADCx_JSQR_JSQx_MSK[5] = {
    [1] = 0x00003E00U,   /** @brief ADC group injected sequencer rank 1 */
    [2] = 0x000F8000U,   /** @brief ADC group injected sequencer rank 2 */
    [3] = 0x03E00000U,   /** @brief ADC group injected sequencer rank 3 */
    [4] = 0xF8000000U,   /** @brief ADC group injected sequencer rank 4 */
  };

  /**** @subsection ADCx Register Field Positions ****/

  static const int32_t ADCx_ISR_JQOVF_POS           = 10;   /** @brief ADC group injected contexts queue overflow flag */
  static const int32_t ADCx_ISR_JEOS_POS            = 6;    /** @brief ADC group injected end of sequence conversions flag */
  static const int32_t ADCx_ISR_JEOC_POS            = 5;    /** @brief ADC group injected end of unitary conversion flag */
  static const int32_t ADCx_ISR_OVR_POS             = 4;    /** @brief ADC group regular overrun flag */
  static const int32_t ADCx_ISR_EOS_POS             = 3;    /** @brief ADC group regular end of sequence conversions flag */
  static const int32_t ADCx_ISR_EOC_POS             = 2;    /** @brief ADC group regular end of unitary conversion flag */
  static const int32_t ADCx_ISR_EOSMP_POS           = 1;    /** @brief ADC group regular end of sampling flag */
  static const int32_t ADCx_ISR_ADRDY_POS           = 0;    /** @brief ADC ready flag */
  static const int32_t ADCx_IER_JQOVFIE_POS         = 10;   /** @brief ADC group injected contexts queue overflow interrupt */
  static const int32_t ADCx_IER_JEOSIE_POS          = 6;    /** @brief ADC group injected end of sequence conversions interrupt */
  static const int32_t ADCx_IER_JEOCIE_POS          = 5;    /** @brief ADC group injected end of unitary conversion interrupt */
  static const int32_t ADCx_IER_OVRIE_POS           = 4;    /** @brief ADC group regular overrun interrupt */
  static const int32_t ADCx_IER_EOSIE_POS           = 3;    /** @brief ADC group regular end of sequence conversions interrupt */
  static const int32_t ADCx_IER_EOCIE_POS           = 2;    /** @brief ADC group regular end of unitary conversion interrupt */
  static const int32_t ADCx_IER_EOSMPIE_POS         = 1;    /** @brief ADC group regular end of sampling interrupt */
  static const int32_t ADCx_IER_ADRDYIE_POS         = 0;    /** @brief ADC ready interrupt */
  static const int32_t ADCx_CR_ADCAL_POS            = 31;   /** @brief ADC calibration */
  static const int32_t ADCx_CR_ADCALDIF_POS         = 30;   /** @brief ADC differential mode for calibration */
  static const int32_t ADCx_CR_DEEPPWD_POS          = 29;   /** @brief ADC deep power down enable */
  static const int32_t ADCx_CR_ADVREGEN_POS         = 28;   /** @brief ADC voltage regulator enable */
  static const int32_t ADCx_CR_ADCALLIN_POS         = 16;   /** @brief Linearity calibration */
  static const int32_t ADCx_CR_BOOST_POS            = 8;    /** @brief Boost mode control */
  static const int32_t ADCx_CR_JADSTP_POS           = 5;    /** @brief ADC group injected conversion stop */
  static const int32_t ADCx_CR_ADSTP_POS            = 4;    /** @brief ADC group regular conversion stop */
  static const int32_t ADCx_CR_JADSTART_POS         = 3;    /** @brief ADC group injected conversion start */
  static const int32_t ADCx_CR_ADSTART_POS          = 2;    /** @brief ADC group regular conversion start */
  static const int32_t ADCx_CR_ADDIS_POS            = 1;    /** @brief ADC disable */
  static const int32_t ADCx_CR_ADEN_POS             = 0;    /** @brief ADC enable */
  static const int32_t ADCx_CFGR_JQDIS_POS          = 31;   /** @brief ADC group injected contexts queue disable */
  static const int32_t ADCx_CFGR_AWDCH1CH_POS       = 26;   /** @brief ADC analog watchdog 1 monitored channel selection */
  static const int32_t ADCx_CFGR_JAUTO_POS          = 25;   /** @brief ADC group injected automatic trigger mode */
  static const int32_t ADCx_CFGR_JAWD1EN_POS        = 24;   /** @brief ADC analog watchdog 1 enable on scope ADC group injected */
  static const int32_t ADCx_CFGR_AWD1EN_POS         = 23;   /** @brief ADC analog watchdog 1 enable on scope ADC group regular */
  static const int32_t ADCx_CFGR_AWD1SGL_POS        = 22;   /** @brief ADC analog watchdog 1 monitoring a single channel or all channels */
  static const int32_t ADCx_CFGR_JQM_POS            = 21;   /** @brief ADC group injected contexts queue mode */
  static const int32_t ADCx_CFGR_JDISCEN_POS        = 20;   /** @brief ADC group injected sequencer discontinuous mode */
  static const int32_t ADCx_CFGR_DISCNUM_POS        = 17;   /** @brief ADC group regular sequencer discontinuous number of ranks */
  static const int32_t ADCx_CFGR_DISCEN_POS         = 16;   /** @brief ADC group regular sequencer discontinuous mode */
  static const int32_t ADCx_CFGR_AUTDLY_POS         = 14;   /** @brief ADC low power auto wait */
  static const int32_t ADCx_CFGR_CONT_POS           = 13;   /** @brief ADC group regular continuous conversion mode */
  static const int32_t ADCx_CFGR_OVRMOD_POS         = 12;   /** @brief ADC group regular overrun configuration */
  static const int32_t ADCx_CFGR_EXTEN_POS          = 10;   /** @brief ADC group regular external trigger polarity */
  static const int32_t ADCx_CFGR_EXTSEL_POS         = 5;    /** @brief ADC group regular external trigger source */
  static const int32_t ADCx_CFGR_RES_POS            = 2;    /** @brief ADC data resolution */
  static const int32_t ADCx_CFGR_DMNGT_POS          = 0;    /** @brief ADC DMA transfer enable */
  static const int32_t ADCx_CFGR2_ROVSE_POS         = 0;    /** @brief ADC oversampler enable on scope ADC group regular */
  static const int32_t ADCx_CFGR2_JOVSE_POS         = 1;    /** @brief ADC oversampler enable on scope ADC group injected */
  static const int32_t ADCx_CFGR2_OVSS_POS          = 5;    /** @brief ADC oversampling shift */
  static const int32_t ADCx_CFGR2_TROVS_POS         = 9;    /** @brief ADC oversampling discontinuous mode (triggered mode) for ADC group regular */
  static const int32_t ADCx_CFGR2_ROVSM_POS         = 10;   /** @brief Regular oversampling mode */
  static const int32_t ADCx_CFGR2_OSR_POS           = 16;   /** @brief Oversampling ratio */
  static const int32_t ADCx_CFGR2_LSHIFT_POS        = 28;   /** @brief Left shift factor */
  static const int32_t ADCx_LTRx_LTR1_POS           = 0;    /** @brief ADC analog watchdog 1 threshold low */
  static const int32_t ADCx_LHTR1_LHTR1_POS         = 0;    /** @brief ADC analog watchdog 2 threshold low */
  static const int32_t ADCx_SQRx_L3_POS             = 0;    /** @brief L3 */
  static const int32_t ADCx_DR_RDATA_POS            = 0;    /** @brief ADC group regular conversion data */
  static const int32_t ADCx_JSQR_JEXTEN_POS         = 7;    /** @brief ADC group injected external trigger polarity */
  static const int32_t ADCx_JSQR_JEXTSEL_POS        = 2;    /** @brief ADC group injected external trigger source */
  static const int32_t ADCx_JSQR_JL_POS             = 0;    /** @brief ADC group injected sequencer scan length */
  static const int32_t ADCx_OFRx_SSATE_POS          = 31;   /** @brief ADC offset number 1 enable */
  static const int32_t ADCx_OFRx_OFFSET1_CH_POS     = 26;   /** @brief ADC offset number 1 channel selection */
  static const int32_t ADCx_OFRx_OFFSET1_POS        = 0;    /** @brief ADC offset number 1 offset level */
  static const int32_t ADCx_AWDxCR_AWD2CH_POS       = 0;    /** @brief ADC analog watchdog 2 monitored channel selection */
  static const int32_t ADCx_DIFSEL_DIFSEL_POS       = 0;    /** @brief ADC channel differential or single-ended mode for channel */
  static const int32_t ADCx_CALFACT_CALFACT_D_POS   = 16;   /** @brief ADC calibration factor in differential mode */
  static const int32_t ADCx_CALFACT_CALFACT_S_POS   = 0;    /** @brief ADC calibration factor in single-ended mode */
  static const int32_t ADCx_PCSEL_PCSEL_POS         = 0;    /** @brief Channel x (vinp[i]) pre selection */
  static const int32_t ADCx_HTRx_HTR2_POS           = 0;    /** @brief Analog watchdog 2 higher threshold */
  static const int32_t ADCx_CALFACT2_LINCALFACT_POS = 0;    /** @brief Linearity calibration factor */

  /**** @subsection Enumerated ADCx Register Field Positions ****/

  static const int32_t ADCx_ISR_AWDx_POS[4] = {
    [1] = 7,   /** @brief ADC analog watchdog 1 flag */
    [2] = 8,   /** @brief ADC analog watchdog 2 flag */
    [3] = 9,   /** @brief ADC analog watchdog 3 flag */
  };

  static const int32_t ADCx_IER_AWDxIE_POS[4] = {
    [1] = 7,   /** @brief ADC analog watchdog 1 interrupt */
    [2] = 8,   /** @brief ADC analog watchdog 2 interrupt */
    [3] = 9,   /** @brief ADC analog watchdog 3 interrupt */
  };

  static const int32_t ADCx_CR_LINCALRDYWx_POS[7] = {
    [1] = 22,   /** @brief Linearity calibration ready word 1 */
    [2] = 23,   /** @brief Linearity calibration ready word 2 */
    [3] = 24,   /** @brief Linearity calibration ready word 3 */
    [4] = 25,   /** @brief Linearity calibration ready word 4 */
    [5] = 26,   /** @brief Linearity calibration ready word 5 */
    [6] = 27,   /** @brief Linearity calibration ready word 6 */
  };

  static const int32_t ADCx_CFGR2_RSHIFTx_POS[5] = {
    [1] = 11,   /** @brief Right-shift data after offset 1 correction */
    [2] = 12,   /** @brief Right-shift data after offset 2 correction */
    [3] = 13,   /** @brief Right-shift data after offset 3 correction */
    [4] = 14,   /** @brief Right-shift data after offset 4 correction */
  };

  static const int32_t ADCx_SMPRx_SMPx_POS[10] = {
    [1]  = 3,    /** @brief ADC channel 1 sampling time selection */
    [2]  = 6,    /** @brief ADC channel 2 sampling time selection */
    [3]  = 9,    /** @brief ADC channel 3 sampling time selection */
    [4]  = 12,   /** @brief ADC channel 4 sampling time selection */
    [5]  = 15,   /** @brief ADC channel 5 sampling time selection */
    [6]  = 18,   /** @brief ADC channel 6 sampling time selection */
    [7]  = 21,   /** @brief ADC channel 7 sampling time selection */
    [8]  = 24,   /** @brief ADC channel 8 sampling time selection */
    [9]  = 27,   /** @brief ADC channel 9 sampling time selection */
  };

  static const int32_t ADCx_SQRx_SQx_POS[5] = {
    [1] = 6,    /** @brief ADC group regular sequencer rank 1 */
    [2] = 12,   /** @brief ADC group regular sequencer rank 2 */
    [3] = 18,   /** @brief ADC group regular sequencer rank 3 */
    [4] = 24,   /** @brief ADC group regular sequencer rank 4 */
  };

  static const int32_t ADCx_JSQR_JSQx_POS[5] = {
    [1] = 9,    /** @brief ADC group injected sequencer rank 1 */
    [2] = 15,   /** @brief ADC group injected sequencer rank 2 */
    [3] = 21,   /** @brief ADC group injected sequencer rank 3 */
    [4] = 27,   /** @brief ADC group injected sequencer rank 4 */
  };

  /**********************************************************************************************
   * @section ADCx_COMMON Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated ADCx_COMMON Register Pointers ****/

  static RO_ uint32_t* const ADCx_COMMON_CSR_PTR[13] = {
    [3]  = (RO_ uint32_t* const)0x58026300U,   /** @brief ADC common status register */
    [12] = (RO_ uint32_t* const)0x40022300U,   /** @brief ADC common status register */
  };

  static RW_ uint32_t* const ADCx_COMMON_CCR_PTR[13] = {
    [3]  = (RW_ uint32_t* const)0x58026308U,   /** @brief ADC common control register */
    [12] = (RW_ uint32_t* const)0x40022308U,   /** @brief ADC common control register */
  };

  static RO_ uint32_t* const ADCx_COMMON_CDR_PTR[13] = {
    [3]  = (RO_ uint32_t* const)0x5802630CU,   /** @brief ADC common regular data register for dual and triple modes */
    [12] = (RO_ uint32_t* const)0x4002230CU,   /** @brief ADC common regular data register for dual and triple modes */
  };

  static RO_ uint32_t* const ADCx_COMMON_CDR2_PTR[13] = {
    [3]  = (RO_ uint32_t* const)0x58026310U,   /** @brief ADC x common regular data register for 32-bit dual mode */
    [12] = (RO_ uint32_t* const)0x40022310U,   /** @brief ADC x common regular data register for 32-bit dual mode */
  };

  /**** @subsection ADCx_COMMON Register Field Masks ****/

  static const uint32_t ADCx_COMMON_CSR_ADRDY_MST_MSK = 0x00000001U;   /** @brief Master ADC ready */
  static const uint32_t ADCx_COMMON_CSR_EOSMP_MST_MSK = 0x00000002U;   /** @brief End of sampling phase flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_EOC_MST_MSK   = 0x00000004U;   /** @brief End of regular conversion of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_EOS_MST_MSK   = 0x00000008U;   /** @brief End of regular sequence flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_OVR_MST_MSK   = 0x00000010U;   /** @brief Overrun flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_JEOC_MST_MSK  = 0x00000020U;   /** @brief End of injected conversion flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_JEOS_MST_MSK  = 0x00000040U;   /** @brief End of injected sequence flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_JQOVF_MST_MSK = 0x00000400U;   /** @brief Injected context queue overflow flag of the master ADC */
  static const uint32_t ADCx_COMMON_CSR_ADRDY_SLV_MSK = 0x00010000U;   /** @brief Slave ADC ready */
  static const uint32_t ADCx_COMMON_CSR_EOSMP_SLV_MSK = 0x00020000U;   /** @brief End of sampling phase flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_EOC_SLV_MSK   = 0x00040000U;   /** @brief End of regular conversion of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_EOS_SLV_MSK   = 0x00080000U;   /** @brief End of regular sequence flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_OVR_SLV_MSK   = 0x00100000U;   /** @brief Overrun flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_JEOC_SLV_MSK  = 0x00200000U;   /** @brief End of injected conversion flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_JEOS_SLV_MSK  = 0x00400000U;   /** @brief End of injected sequence flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CSR_JQOVF_SLV_MSK = 0x04000000U;   /** @brief Injected context queue overflow flag of the slave ADC */
  static const uint32_t ADCx_COMMON_CCR_DUAL_MSK      = 0x0000001FU;   /** @brief Dual ADC mode selection */
  static const uint32_t ADCx_COMMON_CCR_DELAY_MSK     = 0x00000F00U;   /** @brief Delay between 2 sampling phases */
  static const uint32_t ADCx_COMMON_CCR_DAMDF_MSK     = 0x0000C000U;   /** @brief Dual ADC mode data format */
  static const uint32_t ADCx_COMMON_CCR_CKMODE_MSK    = 0x00030000U;   /** @brief ADC clock mode */
  static const uint32_t ADCx_COMMON_CCR_PRESC_MSK     = 0x003C0000U;   /** @brief ADC prescaler */
  static const uint32_t ADCx_COMMON_CCR_VREFEN_MSK    = 0x00400000U;   /** @brief VREFINT enable */
  static const uint32_t ADCx_COMMON_CCR_TSEN_MSK      = 0x00800000U;   /** @brief Temperature sensor enable */
  static const uint32_t ADCx_COMMON_CCR_VBATEN_MSK    = 0x01000000U;   /** @brief VBAT enable */
  static const uint32_t ADCx_COMMON_CDR_RDATA_SLV_MSK = 0xFFFF0000U;   /** @brief Regular data of the slave ADC */
  static const uint32_t ADCx_COMMON_CDR_RDATA_MST_MSK = 0x0000FFFFU;   /** @brief Regular data of the master ADC */

  /**** @subsection Enumerated ADCx_COMMON Register Field Masks ****/

  static const uint32_t ADCx_COMMON_CSR_AWDx_MST_MSK[4] = {
    [1] = 0x00000080U,   /** @brief Analog watchdog 1 flag of the master ADC */
    [2] = 0x00000100U,   /** @brief Analog watchdog 2 flag of the master ADC */
    [3] = 0x00000200U,   /** @brief Analog watchdog 3 flag of the master ADC */
  };

  static const uint32_t ADCx_COMMON_CSR_AWDx_SLV_MSK[4] = {
    [1] = 0x00800000U,   /** @brief Analog watchdog 1 flag of the slave ADC */
    [2] = 0x01000000U,   /** @brief Analog watchdog 2 flag of the slave ADC */
    [3] = 0x02000000U,   /** @brief Analog watchdog 3 flag of the slave ADC */
  };

  /**** @subsection ADCx_COMMON Register Field Positions ****/

  static const int32_t ADCx_COMMON_CSR_ADRDY_MST_POS = 0;    /** @brief Master ADC ready */
  static const int32_t ADCx_COMMON_CSR_EOSMP_MST_POS = 1;    /** @brief End of sampling phase flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_EOC_MST_POS   = 2;    /** @brief End of regular conversion of the master ADC */
  static const int32_t ADCx_COMMON_CSR_EOS_MST_POS   = 3;    /** @brief End of regular sequence flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_OVR_MST_POS   = 4;    /** @brief Overrun flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_JEOC_MST_POS  = 5;    /** @brief End of injected conversion flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_JEOS_MST_POS  = 6;    /** @brief End of injected sequence flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_JQOVF_MST_POS = 10;   /** @brief Injected context queue overflow flag of the master ADC */
  static const int32_t ADCx_COMMON_CSR_ADRDY_SLV_POS = 16;   /** @brief Slave ADC ready */
  static const int32_t ADCx_COMMON_CSR_EOSMP_SLV_POS = 17;   /** @brief End of sampling phase flag of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_EOC_SLV_POS   = 18;   /** @brief End of regular conversion of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_EOS_SLV_POS   = 19;   /** @brief End of regular sequence flag of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_OVR_SLV_POS   = 20;   /** @brief Overrun flag of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_JEOC_SLV_POS  = 21;   /** @brief End of injected conversion flag of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_JEOS_SLV_POS  = 22;   /** @brief End of injected sequence flag of the slave ADC */
  static const int32_t ADCx_COMMON_CSR_JQOVF_SLV_POS = 26;   /** @brief Injected context queue overflow flag of the slave ADC */
  static const int32_t ADCx_COMMON_CCR_DUAL_POS      = 0;    /** @brief Dual ADC mode selection */
  static const int32_t ADCx_COMMON_CCR_DELAY_POS     = 8;    /** @brief Delay between 2 sampling phases */
  static const int32_t ADCx_COMMON_CCR_DAMDF_POS     = 14;   /** @brief Dual ADC mode data format */
  static const int32_t ADCx_COMMON_CCR_CKMODE_POS    = 16;   /** @brief ADC clock mode */
  static const int32_t ADCx_COMMON_CCR_PRESC_POS     = 18;   /** @brief ADC prescaler */
  static const int32_t ADCx_COMMON_CCR_VREFEN_POS    = 22;   /** @brief VREFINT enable */
  static const int32_t ADCx_COMMON_CCR_TSEN_POS      = 23;   /** @brief Temperature sensor enable */
  static const int32_t ADCx_COMMON_CCR_VBATEN_POS    = 24;   /** @brief VBAT enable */
  static const int32_t ADCx_COMMON_CDR_RDATA_SLV_POS = 16;   /** @brief Regular data of the slave ADC */
  static const int32_t ADCx_COMMON_CDR_RDATA_MST_POS = 0;    /** @brief Regular data of the master ADC */

  /**** @subsection Enumerated ADCx_COMMON Register Field Positions ****/

  static const int32_t ADCx_COMMON_CSR_AWDx_MST_POS[4] = {
    [1] = 7,   /** @brief Analog watchdog 1 flag of the master ADC */
    [2] = 8,   /** @brief Analog watchdog 2 flag of the master ADC */
    [3] = 9,   /** @brief Analog watchdog 3 flag of the master ADC */
  };

  static const int32_t ADCx_COMMON_CSR_AWDx_SLV_POS[4] = {
    [1] = 23,   /** @brief Analog watchdog 1 flag of the slave ADC */
    [2] = 24,   /** @brief Analog watchdog 2 flag of the slave ADC */
    [3] = 25,   /** @brief Analog watchdog 3 flag of the slave ADC */
  };

  /**********************************************************************************************
   * @section LPTIMx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated LPTIMx Register Pointers ****/

  static RO_ uint32_t* const LPTIMx_ISR_PTR[6] = {
    [1] = (RO_ uint32_t* const)0x40002400U,   /** @brief Interrupt and status register */
    [2] = (RO_ uint32_t* const)0x58002400U,   /** @brief Interrupt and status register */
    [3] = (RO_ uint32_t* const)0x58002800U,   /** @brief Interrupt and status register */
    [4] = (RO_ uint32_t* const)0x58002C00U,   /** @brief Interrupt and status register */
    [5] = (RO_ uint32_t* const)0x58003000U,   /** @brief Interrupt and status register */
  };

  static WO_ uint32_t* const LPTIMx_ICR_PTR[6] = {
    [1] = (WO_ uint32_t* const)0x40002404U,   /** @brief Interrupt clear register */
    [2] = (WO_ uint32_t* const)0x58002404U,   /** @brief Interrupt clear register */
    [3] = (WO_ uint32_t* const)0x58002804U,   /** @brief Interrupt clear register */
    [4] = (WO_ uint32_t* const)0x58002C04U,   /** @brief Interrupt clear register */
    [5] = (WO_ uint32_t* const)0x58003004U,   /** @brief Interrupt clear register */
  };

  static RW_ uint32_t* const LPTIMx_IER_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x40002408U,   /** @brief Interrupt enable register */
    [2] = (RW_ uint32_t* const)0x58002408U,   /** @brief Interrupt enable register */
    [3] = (RW_ uint32_t* const)0x58002808U,   /** @brief Interrupt enable register */
    [4] = (RW_ uint32_t* const)0x58002C08U,   /** @brief Interrupt enable register */
    [5] = (RW_ uint32_t* const)0x58003008U,   /** @brief Interrupt enable register */
  };

  static RW_ uint32_t* const LPTIMx_CFGR_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x4000240CU,   /** @brief Configuration register */
    [2] = (RW_ uint32_t* const)0x5800240CU,   /** @brief Configuration register */
    [3] = (RW_ uint32_t* const)0x5800280CU,   /** @brief Configuration register */
    [4] = (RW_ uint32_t* const)0x58002C0CU,   /** @brief Configuration register */
    [5] = (RW_ uint32_t* const)0x5800300CU,   /** @brief Configuration register */
  };

  static RW_ uint32_t* const LPTIMx_CR_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x40002410U,   /** @brief Control register */
    [2] = (RW_ uint32_t* const)0x58002410U,   /** @brief Control register */
    [3] = (RW_ uint32_t* const)0x58002810U,   /** @brief Control register */
    [4] = (RW_ uint32_t* const)0x58002C10U,   /** @brief Control register */
    [5] = (RW_ uint32_t* const)0x58003010U,   /** @brief Control register */
  };

  static RW_ uint32_t* const LPTIMx_CMP_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x40002414U,   /** @brief Compare register */
    [2] = (RW_ uint32_t* const)0x58002414U,   /** @brief Compare register */
    [3] = (RW_ uint32_t* const)0x58002814U,   /** @brief Compare register */
    [4] = (RW_ uint32_t* const)0x58002C14U,   /** @brief Compare register */
    [5] = (RW_ uint32_t* const)0x58003014U,   /** @brief Compare register */
  };

  static RW_ uint32_t* const LPTIMx_ARR_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x40002418U,   /** @brief Autoreload register */
    [2] = (RW_ uint32_t* const)0x58002418U,   /** @brief Autoreload register */
    [3] = (RW_ uint32_t* const)0x58002818U,   /** @brief Autoreload register */
    [4] = (RW_ uint32_t* const)0x58002C18U,   /** @brief Autoreload register */
    [5] = (RW_ uint32_t* const)0x58003018U,   /** @brief Autoreload register */
  };

  static RO_ uint32_t* const LPTIMx_CNT_PTR[6] = {
    [1] = (RO_ uint32_t* const)0x4000241CU,   /** @brief Counter register */
    [2] = (RO_ uint32_t* const)0x5800241CU,   /** @brief Counter register */
    [3] = (RO_ uint32_t* const)0x5800281CU,   /** @brief Counter register */
    [4] = (RO_ uint32_t* const)0x58002C1CU,   /** @brief Counter register */
    [5] = (RO_ uint32_t* const)0x5800301CU,   /** @brief Counter register */
  };

  static RW_ uint32_t* const LPTIMx_CFGR2_PTR[6] = {
    [1] = (RW_ uint32_t* const)0x40002424U,   /** @brief LPTIM configuration register 2 */
    [2] = (RW_ uint32_t* const)0x58002424U,   /** @brief LPTIM configuration register 2 */
    [3] = (RW_ uint32_t* const)0x58002824U,   /** @brief LPTIM configuration register 2 */
    [4] = (RW_ uint32_t* const)0x58002C24U,   /** @brief LPTIM configuration register 2 */
    [5] = (RW_ uint32_t* const)0x58003024U,   /** @brief LPTIM configuration register 2 */
  };

  /**** @subsection LPTIMx Register Field Masks ****/

  static const uint32_t LPTIMx_ISR_DOWN_MSK       = 0x00000040U;   /** @brief Counter direction change up to down */
  static const uint32_t LPTIMx_ISR_UP_MSK         = 0x00000020U;   /** @brief Counter direction change down to up */
  static const uint32_t LPTIMx_ISR_ARROK_MSK      = 0x00000010U;   /** @brief Autoreload register update OK */
  static const uint32_t LPTIMx_ISR_CMPOK_MSK      = 0x00000008U;   /** @brief Compare register update OK */
  static const uint32_t LPTIMx_ISR_EXTTRIG_MSK    = 0x00000004U;   /** @brief External trigger edge event */
  static const uint32_t LPTIMx_ISR_ARRM_MSK       = 0x00000002U;   /** @brief Autoreload match */
  static const uint32_t LPTIMx_ISR_CMPM_MSK       = 0x00000001U;   /** @brief Compare match */
  static const uint32_t LPTIMx_ICR_DOWNCF_MSK     = 0x00000040U;   /** @brief Direction change to down clear flag */
  static const uint32_t LPTIMx_ICR_UPCF_MSK       = 0x00000020U;   /** @brief Direction change to UP clear flag */
  static const uint32_t LPTIMx_ICR_ARROKCF_MSK    = 0x00000010U;   /** @brief Autoreload register update OK clear flag */
  static const uint32_t LPTIMx_ICR_CMPOKCF_MSK    = 0x00000008U;   /** @brief Compare register update OK clear flag */
  static const uint32_t LPTIMx_ICR_EXTTRIGCF_MSK  = 0x00000004U;   /** @brief External trigger valid edge clear flag */
  static const uint32_t LPTIMx_ICR_ARRMCF_MSK     = 0x00000002U;   /** @brief Autoreload match clear flag */
  static const uint32_t LPTIMx_ICR_CMPMCF_MSK     = 0x00000001U;   /** @brief Compare match clear flag */
  static const uint32_t LPTIMx_IER_DOWNIE_MSK     = 0x00000040U;   /** @brief Direction change to down interrupt enable */
  static const uint32_t LPTIMx_IER_UPIE_MSK       = 0x00000020U;   /** @brief Direction change to UP interrupt enable */
  static const uint32_t LPTIMx_IER_ARROKIE_MSK    = 0x00000010U;   /** @brief Autoreload register update OK interrupt enable */
  static const uint32_t LPTIMx_IER_CMPOKIE_MSK    = 0x00000008U;   /** @brief Compare register update OK interrupt enable */
  static const uint32_t LPTIMx_IER_EXTTRIGIE_MSK  = 0x00000004U;   /** @brief External trigger valid edge interrupt enable */
  static const uint32_t LPTIMx_IER_ARRMIE_MSK     = 0x00000002U;   /** @brief Autoreload match interrupt enable */
  static const uint32_t LPTIMx_IER_CMPMIE_MSK     = 0x00000001U;   /** @brief Compare match interrupt enable */
  static const uint32_t LPTIMx_CFGR_ENC_MSK       = 0x01000000U;   /** @brief Encoder mode enable */
  static const uint32_t LPTIMx_CFGR_COUNTMODE_MSK = 0x00800000U;   /** @brief Counter mode enabled */
  static const uint32_t LPTIMx_CFGR_PRELOAD_MSK   = 0x00400000U;   /** @brief Registers update mode */
  static const uint32_t LPTIMx_CFGR_WAVPOL_MSK    = 0x00200000U;   /** @brief Waveform shape polarity */
  static const uint32_t LPTIMx_CFGR_WAVE_MSK      = 0x00100000U;   /** @brief Waveform shape */
  static const uint32_t LPTIMx_CFGR_TIMOUT_MSK    = 0x00080000U;   /** @brief Timeout enable */
  static const uint32_t LPTIMx_CFGR_TRIGEN_MSK    = 0x00060000U;   /** @brief Trigger enable and polarity */
  static const uint32_t LPTIMx_CFGR_TRIGSEL_MSK   = 0x0000E000U;   /** @brief Trigger selector */
  static const uint32_t LPTIMx_CFGR_PRESC_MSK     = 0x00000E00U;   /** @brief Clock prescaler */
  static const uint32_t LPTIMx_CFGR_TRGFLT_MSK    = 0x000000C0U;   /** @brief Configurable digital filter for trigger */
  static const uint32_t LPTIMx_CFGR_CKFLT_MSK     = 0x00000018U;   /** @brief Configurable digital filter for external clock */
  static const uint32_t LPTIMx_CFGR_CKPOL_MSK     = 0x00000006U;   /** @brief Clock polarity */
  static const uint32_t LPTIMx_CFGR_CKSEL_MSK     = 0x00000001U;   /** @brief Clock selector */
  static const uint32_t LPTIMx_CR_ENABLE_MSK      = 0x00000001U;   /** @brief LPTIM enable */
  static const uint32_t LPTIMx_CR_SNGSTRT_MSK     = 0x00000002U;   /** @brief LPTIM start in single mode */
  static const uint32_t LPTIMx_CR_CNTSTRT_MSK     = 0x00000004U;   /** @brief Timer start in continuous mode */
  static const uint32_t LPTIMx_CR_COUNTRST_MSK    = 0x00000008U;   /** @brief Counter reset */
  static const uint32_t LPTIMx_CR_RSTARE_MSK      = 0x00000010U;   /** @brief Reset after read enable */
  static const uint32_t LPTIMx_CMP_CMP_MSK        = 0x0000FFFFU;   /** @brief Compare value */
  static const uint32_t LPTIMx_ARR_ARR_MSK        = 0x0000FFFFU;   /** @brief Auto reload value */
  static const uint32_t LPTIMx_CNT_CNT_MSK        = 0x0000FFFFU;   /** @brief Counter value */

  /**** @subsection Enumerated LPTIMx Register Field Masks ****/

  static const uint32_t LPTIMx_CFGR2_INxSEL_MSK[3] = {
    [1] = 0x00000003U,   /** @brief LPTIM input 1 selection */
    [2] = 0x00000030U,   /** @brief LPTIM input 2 selection */
  };

  /**** @subsection LPTIMx Register Field Positions ****/

  static const int32_t LPTIMx_ISR_DOWN_POS       = 6;    /** @brief Counter direction change up to down */
  static const int32_t LPTIMx_ISR_UP_POS         = 5;    /** @brief Counter direction change down to up */
  static const int32_t LPTIMx_ISR_ARROK_POS      = 4;    /** @brief Autoreload register update OK */
  static const int32_t LPTIMx_ISR_CMPOK_POS      = 3;    /** @brief Compare register update OK */
  static const int32_t LPTIMx_ISR_EXTTRIG_POS    = 2;    /** @brief External trigger edge event */
  static const int32_t LPTIMx_ISR_ARRM_POS       = 1;    /** @brief Autoreload match */
  static const int32_t LPTIMx_ISR_CMPM_POS       = 0;    /** @brief Compare match */
  static const int32_t LPTIMx_ICR_DOWNCF_POS     = 6;    /** @brief Direction change to down clear flag */
  static const int32_t LPTIMx_ICR_UPCF_POS       = 5;    /** @brief Direction change to UP clear flag */
  static const int32_t LPTIMx_ICR_ARROKCF_POS    = 4;    /** @brief Autoreload register update OK clear flag */
  static const int32_t LPTIMx_ICR_CMPOKCF_POS    = 3;    /** @brief Compare register update OK clear flag */
  static const int32_t LPTIMx_ICR_EXTTRIGCF_POS  = 2;    /** @brief External trigger valid edge clear flag */
  static const int32_t LPTIMx_ICR_ARRMCF_POS     = 1;    /** @brief Autoreload match clear flag */
  static const int32_t LPTIMx_ICR_CMPMCF_POS     = 0;    /** @brief Compare match clear flag */
  static const int32_t LPTIMx_IER_DOWNIE_POS     = 6;    /** @brief Direction change to down interrupt enable */
  static const int32_t LPTIMx_IER_UPIE_POS       = 5;    /** @brief Direction change to UP interrupt enable */
  static const int32_t LPTIMx_IER_ARROKIE_POS    = 4;    /** @brief Autoreload register update OK interrupt enable */
  static const int32_t LPTIMx_IER_CMPOKIE_POS    = 3;    /** @brief Compare register update OK interrupt enable */
  static const int32_t LPTIMx_IER_EXTTRIGIE_POS  = 2;    /** @brief External trigger valid edge interrupt enable */
  static const int32_t LPTIMx_IER_ARRMIE_POS     = 1;    /** @brief Autoreload match interrupt enable */
  static const int32_t LPTIMx_IER_CMPMIE_POS     = 0;    /** @brief Compare match interrupt enable */
  static const int32_t LPTIMx_CFGR_ENC_POS       = 24;   /** @brief Encoder mode enable */
  static const int32_t LPTIMx_CFGR_COUNTMODE_POS = 23;   /** @brief Counter mode enabled */
  static const int32_t LPTIMx_CFGR_PRELOAD_POS   = 22;   /** @brief Registers update mode */
  static const int32_t LPTIMx_CFGR_WAVPOL_POS    = 21;   /** @brief Waveform shape polarity */
  static const int32_t LPTIMx_CFGR_WAVE_POS      = 20;   /** @brief Waveform shape */
  static const int32_t LPTIMx_CFGR_TIMOUT_POS    = 19;   /** @brief Timeout enable */
  static const int32_t LPTIMx_CFGR_TRIGEN_POS    = 17;   /** @brief Trigger enable and polarity */
  static const int32_t LPTIMx_CFGR_TRIGSEL_POS   = 13;   /** @brief Trigger selector */
  static const int32_t LPTIMx_CFGR_PRESC_POS     = 9;    /** @brief Clock prescaler */
  static const int32_t LPTIMx_CFGR_TRGFLT_POS    = 6;    /** @brief Configurable digital filter for trigger */
  static const int32_t LPTIMx_CFGR_CKFLT_POS     = 3;    /** @brief Configurable digital filter for external clock */
  static const int32_t LPTIMx_CFGR_CKPOL_POS     = 1;    /** @brief Clock polarity */
  static const int32_t LPTIMx_CFGR_CKSEL_POS     = 0;    /** @brief Clock selector */
  static const int32_t LPTIMx_CR_ENABLE_POS      = 0;    /** @brief LPTIM enable */
  static const int32_t LPTIMx_CR_SNGSTRT_POS     = 1;    /** @brief LPTIM start in single mode */
  static const int32_t LPTIMx_CR_CNTSTRT_POS     = 2;    /** @brief Timer start in continuous mode */
  static const int32_t LPTIMx_CR_COUNTRST_POS    = 3;    /** @brief Counter reset */
  static const int32_t LPTIMx_CR_RSTARE_POS      = 4;    /** @brief Reset after read enable */
  static const int32_t LPTIMx_CMP_CMP_POS        = 0;    /** @brief Compare value */
  static const int32_t LPTIMx_ARR_ARR_POS        = 0;    /** @brief Auto reload value */
  static const int32_t LPTIMx_CNT_CNT_POS        = 0;    /** @brief Counter value */

  /**** @subsection Enumerated LPTIMx Register Field Positions ****/

  static const int32_t LPTIMx_CFGR2_INxSEL_POS[3] = {
    [1] = 0,   /** @brief LPTIM input 1 selection */
    [2] = 4,   /** @brief LPTIM input 2 selection */
  };

  /**********************************************************************************************
   * @section LPUART1 Register Information
   **********************************************************************************************/

  /**** @subsection LPUART1 Register Pointers ****/

  static RW_ uint32_t* const LPUART1_BRR_PTR   = (RW_ uint32_t* const)0x58000C0CU;   /** @brief Baud rate register */
  static RW_ uint32_t* const LPUART1_GTPR_PTR  = (RW_ uint32_t* const)0x58000C10U;   /** @brief Guard time and prescaler register */
  static RW_ uint32_t* const LPUART1_RTOR_PTR  = (RW_ uint32_t* const)0x58000C14U;   /** @brief Receiver timeout register */
  static WO_ uint32_t* const LPUART1_RQR_PTR   = (WO_ uint32_t* const)0x58000C18U;   /** @brief Request register */
  static RO_ uint32_t* const LPUART1_ISR_PTR   = (RO_ uint32_t* const)0x58000C1CU;   /** @brief Interrupt & status register */
  static WO_ uint32_t* const LPUART1_ICR_PTR   = (WO_ uint32_t* const)0x58000C20U;   /** @brief Interrupt flag clear register */
  static RO_ uint32_t* const LPUART1_RDR_PTR   = (RO_ uint32_t* const)0x58000C24U;   /** @brief Receive data register */
  static RW_ uint32_t* const LPUART1_TDR_PTR   = (RW_ uint32_t* const)0x58000C28U;   /** @brief Transmit data register */
  static RW_ uint32_t* const LPUART1_PRESC_PTR = (RW_ uint32_t* const)0x58000C2CU;   /** @brief Prescaler register */

  /**** @subsection Enumerated LPUART1 Register Pointers ****/

  static RW_ uint32_t* const LPUART1_CRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000C00U,   /** @brief Control register 1 */
    [2] = (RW_ uint32_t* const)0x58000C04U,   /** @brief Control register 2 */
    [3] = (RW_ uint32_t* const)0x58000C08U,   /** @brief Control register 3 */
  };

  /**** @subsection LPUART1 Register Field Masks ****/

  static const uint32_t LPUART1_CRx_RXFFIE_MSK      = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
  static const uint32_t LPUART1_CRx_TXFEIE_MSK      = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
  static const uint32_t LPUART1_CRx_FIFOEN_MSK      = 0x20000000U;   /** @brief FIFO mode enable */
  static const uint32_t LPUART1_CRx_DEAT_MSK        = 0x03E00000U;   /** @brief Driver enable assertion time */
  static const uint32_t LPUART1_CRx_DEDT_MSK        = 0x001F0000U;   /** @brief Driver enable deassertion time */
  static const uint32_t LPUART1_CRx_CMIE_MSK        = 0x00004000U;   /** @brief Character match interrupt enable */
  static const uint32_t LPUART1_CRx_MME_MSK         = 0x00002000U;   /** @brief Mute mode enable */
  static const uint32_t LPUART1_CRx_WAKE_MSK        = 0x00000800U;   /** @brief Receiver wakeup method */
  static const uint32_t LPUART1_CRx_PCE_MSK         = 0x00000400U;   /** @brief Parity control enable */
  static const uint32_t LPUART1_CRx_PS_MSK          = 0x00000200U;   /** @brief Parity selection */
  static const uint32_t LPUART1_CRx_PEIE_MSK        = 0x00000100U;   /** @brief PE interrupt enable */
  static const uint32_t LPUART1_CRx_TXEIE_MSK       = 0x00000080U;   /** @brief Interrupt enable */
  static const uint32_t LPUART1_CRx_TCIE_MSK        = 0x00000040U;   /** @brief Transmission complete interrupt enable */
  static const uint32_t LPUART1_CRx_RXNEIE_MSK      = 0x00000020U;   /** @brief RXNE interrupt enable */
  static const uint32_t LPUART1_CRx_IDLEIE_MSK      = 0x00000010U;   /** @brief IDLE interrupt enable */
  static const uint32_t LPUART1_CRx_TE_MSK          = 0x00000008U;   /** @brief Transmitter enable */
  static const uint32_t LPUART1_CRx_RE_MSK          = 0x00000004U;   /** @brief Receiver enable */
  static const uint32_t LPUART1_CRx_UESM_MSK        = 0x00000002U;   /** @brief USART enable in stop mode */
  static const uint32_t LPUART1_CRx_UE_MSK          = 0x00000001U;   /** @brief USART enable */
  static const uint32_t LPUART1_BRR_BRR_MSK         = 0x000FFFFFU;   /** @brief BRR */
  static const uint32_t LPUART1_GTPR_GT_MSK         = 0x0000FF00U;   /** @brief Guard time value */
  static const uint32_t LPUART1_GTPR_PSC_MSK        = 0x000000FFU;   /** @brief Prescaler value */
  static const uint32_t LPUART1_RTOR_BLEN_MSK       = 0xFF000000U;   /** @brief Block length */
  static const uint32_t LPUART1_RTOR_RTO_MSK        = 0x00FFFFFFU;   /** @brief Receiver timeout value */
  static const uint32_t LPUART1_RQR_TXFRQ_MSK       = 0x00000010U;   /** @brief Transmit data flush request */
  static const uint32_t LPUART1_RQR_RXFRQ_MSK       = 0x00000008U;   /** @brief Receive data flush request */
  static const uint32_t LPUART1_RQR_MMRQ_MSK        = 0x00000004U;   /** @brief Mute mode request */
  static const uint32_t LPUART1_RQR_SBKRQ_MSK       = 0x00000002U;   /** @brief Send break request */
  static const uint32_t LPUART1_RQR_ABRRQ_MSK       = 0x00000001U;   /** @brief Auto baud rate request */
  static const uint32_t LPUART1_ISR_TXFT_MSK        = 0x08000000U;   /** @brief TXFIFO threshold flag */
  static const uint32_t LPUART1_ISR_RXFT_MSK        = 0x04000000U;   /** @brief RXFIFO threshold flag */
  static const uint32_t LPUART1_ISR_RXFF_MSK        = 0x01000000U;   /** @brief RXFIFO full */
  static const uint32_t LPUART1_ISR_TXFE_MSK        = 0x00800000U;   /** @brief TXFIFO empty */
  static const uint32_t LPUART1_ISR_REACK_MSK       = 0x00400000U;   /** @brief REACK */
  static const uint32_t LPUART1_ISR_TEACK_MSK       = 0x00200000U;   /** @brief TEACK */
  static const uint32_t LPUART1_ISR_WUF_MSK         = 0x00100000U;   /** @brief WUF */
  static const uint32_t LPUART1_ISR_RWU_MSK         = 0x00080000U;   /** @brief RWU */
  static const uint32_t LPUART1_ISR_SBKF_MSK        = 0x00040000U;   /** @brief SBKF */
  static const uint32_t LPUART1_ISR_CMF_MSK         = 0x00020000U;   /** @brief CMF */
  static const uint32_t LPUART1_ISR_BUSY_MSK        = 0x00010000U;   /** @brief BUSY */
  static const uint32_t LPUART1_ISR_CTS_MSK         = 0x00000400U;   /** @brief CTS */
  static const uint32_t LPUART1_ISR_CTSIF_MSK       = 0x00000200U;   /** @brief CTSIF */
  static const uint32_t LPUART1_ISR_TXE_MSK         = 0x00000080U;   /** @brief TXE */
  static const uint32_t LPUART1_ISR_TC_MSK          = 0x00000040U;   /** @brief TC */
  static const uint32_t LPUART1_ISR_RXNE_MSK        = 0x00000020U;   /** @brief RXNE */
  static const uint32_t LPUART1_ISR_IDLE_MSK        = 0x00000010U;   /** @brief IDLE */
  static const uint32_t LPUART1_ISR_ORE_MSK         = 0x00000008U;   /** @brief ORE */
  static const uint32_t LPUART1_ISR_NE_MSK          = 0x00000004U;   /** @brief NE */
  static const uint32_t LPUART1_ISR_FE_MSK          = 0x00000002U;   /** @brief FE */
  static const uint32_t LPUART1_ISR_PE_MSK          = 0x00000001U;   /** @brief PE */
  static const uint32_t LPUART1_ICR_WUCF_MSK        = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
  static const uint32_t LPUART1_ICR_CMCF_MSK        = 0x00020000U;   /** @brief Character match clear flag */
  static const uint32_t LPUART1_ICR_CTSCF_MSK       = 0x00000200U;   /** @brief CTS clear flag */
  static const uint32_t LPUART1_ICR_TCCF_MSK        = 0x00000040U;   /** @brief Transmission complete clear flag */
  static const uint32_t LPUART1_ICR_IDLECF_MSK      = 0x00000010U;   /** @brief Idle line detected clear flag */
  static const uint32_t LPUART1_ICR_ORECF_MSK       = 0x00000008U;   /** @brief Overrun error clear flag */
  static const uint32_t LPUART1_ICR_NCF_MSK         = 0x00000004U;   /** @brief Noise detected clear flag */
  static const uint32_t LPUART1_ICR_FECF_MSK        = 0x00000002U;   /** @brief Framing error clear flag */
  static const uint32_t LPUART1_ICR_PECF_MSK        = 0x00000001U;   /** @brief Parity error clear flag */
  static const uint32_t LPUART1_RDR_RDR_MSK         = 0x000001FFU;   /** @brief Receive data value */
  static const uint32_t LPUART1_TDR_TDR_MSK         = 0x000001FFU;   /** @brief Transmit data value */
  static const uint32_t LPUART1_PRESC_PRESCALER_MSK = 0x0000000FU;   /** @brief Clock prescaler */

  /**** @subsection Enumerated LPUART1 Register Field Masks ****/

  static const uint32_t LPUART1_CRx_Mx_MSK[2] = {
    [0] = 0x00001000U,   /** @brief Word length */
    [1] = 0x10000000U,   /** @brief Word length */
  };

  /**** @subsection LPUART1 Register Field Positions ****/

  static const int32_t LPUART1_CRx_RXFFIE_POS      = 31;   /** @brief RXFIFO full interrupt enable */
  static const int32_t LPUART1_CRx_TXFEIE_POS      = 30;   /** @brief TXFIFO empty interrupt enable */
  static const int32_t LPUART1_CRx_FIFOEN_POS      = 29;   /** @brief FIFO mode enable */
  static const int32_t LPUART1_CRx_DEAT_POS        = 21;   /** @brief Driver enable assertion time */
  static const int32_t LPUART1_CRx_DEDT_POS        = 16;   /** @brief Driver enable deassertion time */
  static const int32_t LPUART1_CRx_CMIE_POS        = 14;   /** @brief Character match interrupt enable */
  static const int32_t LPUART1_CRx_MME_POS         = 13;   /** @brief Mute mode enable */
  static const int32_t LPUART1_CRx_WAKE_POS        = 11;   /** @brief Receiver wakeup method */
  static const int32_t LPUART1_CRx_PCE_POS         = 10;   /** @brief Parity control enable */
  static const int32_t LPUART1_CRx_PS_POS          = 9;    /** @brief Parity selection */
  static const int32_t LPUART1_CRx_PEIE_POS        = 8;    /** @brief PE interrupt enable */
  static const int32_t LPUART1_CRx_TXEIE_POS       = 7;    /** @brief Interrupt enable */
  static const int32_t LPUART1_CRx_TCIE_POS        = 6;    /** @brief Transmission complete interrupt enable */
  static const int32_t LPUART1_CRx_RXNEIE_POS      = 5;    /** @brief RXNE interrupt enable */
  static const int32_t LPUART1_CRx_IDLEIE_POS      = 4;    /** @brief IDLE interrupt enable */
  static const int32_t LPUART1_CRx_TE_POS          = 3;    /** @brief Transmitter enable */
  static const int32_t LPUART1_CRx_RE_POS          = 2;    /** @brief Receiver enable */
  static const int32_t LPUART1_CRx_UESM_POS        = 1;    /** @brief USART enable in stop mode */
  static const int32_t LPUART1_CRx_UE_POS          = 0;    /** @brief USART enable */
  static const int32_t LPUART1_BRR_BRR_POS         = 0;    /** @brief BRR */
  static const int32_t LPUART1_GTPR_GT_POS         = 8;    /** @brief Guard time value */
  static const int32_t LPUART1_GTPR_PSC_POS        = 0;    /** @brief Prescaler value */
  static const int32_t LPUART1_RTOR_BLEN_POS       = 24;   /** @brief Block length */
  static const int32_t LPUART1_RTOR_RTO_POS        = 0;    /** @brief Receiver timeout value */
  static const int32_t LPUART1_RQR_TXFRQ_POS       = 4;    /** @brief Transmit data flush request */
  static const int32_t LPUART1_RQR_RXFRQ_POS       = 3;    /** @brief Receive data flush request */
  static const int32_t LPUART1_RQR_MMRQ_POS        = 2;    /** @brief Mute mode request */
  static const int32_t LPUART1_RQR_SBKRQ_POS       = 1;    /** @brief Send break request */
  static const int32_t LPUART1_RQR_ABRRQ_POS       = 0;    /** @brief Auto baud rate request */
  static const int32_t LPUART1_ISR_TXFT_POS        = 27;   /** @brief TXFIFO threshold flag */
  static const int32_t LPUART1_ISR_RXFT_POS        = 26;   /** @brief RXFIFO threshold flag */
  static const int32_t LPUART1_ISR_RXFF_POS        = 24;   /** @brief RXFIFO full */
  static const int32_t LPUART1_ISR_TXFE_POS        = 23;   /** @brief TXFIFO empty */
  static const int32_t LPUART1_ISR_REACK_POS       = 22;   /** @brief REACK */
  static const int32_t LPUART1_ISR_TEACK_POS       = 21;   /** @brief TEACK */
  static const int32_t LPUART1_ISR_WUF_POS         = 20;   /** @brief WUF */
  static const int32_t LPUART1_ISR_RWU_POS         = 19;   /** @brief RWU */
  static const int32_t LPUART1_ISR_SBKF_POS        = 18;   /** @brief SBKF */
  static const int32_t LPUART1_ISR_CMF_POS         = 17;   /** @brief CMF */
  static const int32_t LPUART1_ISR_BUSY_POS        = 16;   /** @brief BUSY */
  static const int32_t LPUART1_ISR_CTS_POS         = 10;   /** @brief CTS */
  static const int32_t LPUART1_ISR_CTSIF_POS       = 9;    /** @brief CTSIF */
  static const int32_t LPUART1_ISR_TXE_POS         = 7;    /** @brief TXE */
  static const int32_t LPUART1_ISR_TC_POS          = 6;    /** @brief TC */
  static const int32_t LPUART1_ISR_RXNE_POS        = 5;    /** @brief RXNE */
  static const int32_t LPUART1_ISR_IDLE_POS        = 4;    /** @brief IDLE */
  static const int32_t LPUART1_ISR_ORE_POS         = 3;    /** @brief ORE */
  static const int32_t LPUART1_ISR_NE_POS          = 2;    /** @brief NE */
  static const int32_t LPUART1_ISR_FE_POS          = 1;    /** @brief FE */
  static const int32_t LPUART1_ISR_PE_POS          = 0;    /** @brief PE */
  static const int32_t LPUART1_ICR_WUCF_POS        = 20;   /** @brief Wakeup from stop mode clear flag */
  static const int32_t LPUART1_ICR_CMCF_POS        = 17;   /** @brief Character match clear flag */
  static const int32_t LPUART1_ICR_CTSCF_POS       = 9;    /** @brief CTS clear flag */
  static const int32_t LPUART1_ICR_TCCF_POS        = 6;    /** @brief Transmission complete clear flag */
  static const int32_t LPUART1_ICR_IDLECF_POS      = 4;    /** @brief Idle line detected clear flag */
  static const int32_t LPUART1_ICR_ORECF_POS       = 3;    /** @brief Overrun error clear flag */
  static const int32_t LPUART1_ICR_NCF_POS         = 2;    /** @brief Noise detected clear flag */
  static const int32_t LPUART1_ICR_FECF_POS        = 1;    /** @brief Framing error clear flag */
  static const int32_t LPUART1_ICR_PECF_POS        = 0;    /** @brief Parity error clear flag */
  static const int32_t LPUART1_RDR_RDR_POS         = 0;    /** @brief Receive data value */
  static const int32_t LPUART1_TDR_TDR_POS         = 0;    /** @brief Transmit data value */
  static const int32_t LPUART1_PRESC_PRESCALER_POS = 0;    /** @brief Clock prescaler */

  /**** @subsection Enumerated LPUART1 Register Field Positions ****/

  static const int32_t LPUART1_CRx_Mx_POS[2] = {
    [0] = 12,   /** @brief Word length */
    [1] = 28,   /** @brief Word length */
  };

  /**********************************************************************************************
   * @section SYSCFG Register Information
   **********************************************************************************************/

  /**** @subsection SYSCFG Register Pointers ****/

  static RW_ uint32_t* const SYSCFG_PMCR_PTR  = (RW_ uint32_t* const)0x58000404U;   /** @brief Peripheral mode configuration register */
  static RW_ uint32_t* const SYSCFG_CCCSR_PTR = (RW_ uint32_t* const)0x58000420U;   /** @brief Compensation cell control/status register */
  static RO_ uint32_t* const SYSCFG_CCVR_PTR  = (RO_ uint32_t* const)0x58000424U;   /** @brief SYSCFG compensation cell value register */
  static RW_ uint32_t* const SYSCFG_CCCR_PTR  = (RW_ uint32_t* const)0x58000428U;   /** @brief SYSCFG compensation cell code register */
  static RO_ uint32_t* const SYSCFG_PKGR_PTR  = (RO_ uint32_t* const)0x58000524U;   /** @brief SYSCFG package register */

  /**** @subsection Enumerated SYSCFG Register Pointers ****/

  static RW_ uint32_t* const SYSCFG_EXTICRx_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x58000408U,   /** @brief External interrupt configuration register 1 */
    [2] = (RW_ uint32_t* const)0x5800040CU,   /** @brief External interrupt configuration register 2 */
    [3] = (RW_ uint32_t* const)0x58000410U,   /** @brief External interrupt configuration register 3 */
    [4] = (RW_ uint32_t* const)0x58000414U,   /** @brief External interrupt configuration register 4 */
  };

  static RO_ uint32_t* const SYSCFG_URx_PTR[18] = {
    [0]  = (RO_ uint32_t* const)0x58000700U,   /** @brief SYSCFG user register 0 */
    [2]  = (RO_ uint32_t* const)0x58000708U,   /** @brief SYSCFG user register 2 */
    [3]  = (RO_ uint32_t* const)0x5800070CU,   /** @brief SYSCFG user register 3 */
    [4]  = (RO_ uint32_t* const)0x58000710U,   /** @brief SYSCFG user register 4 */
    [5]  = (RO_ uint32_t* const)0x58000714U,   /** @brief SYSCFG user register 5 */
    [6]  = (RO_ uint32_t* const)0x58000718U,   /** @brief SYSCFG user register 6 */
    [7]  = (RO_ uint32_t* const)0x5800071CU,   /** @brief SYSCFG user register 7 */
    [8]  = (RO_ uint32_t* const)0x58000720U,   /** @brief SYSCFG user register 8 */
    [9]  = (RO_ uint32_t* const)0x58000724U,   /** @brief SYSCFG user register 9 */
    [10] = (RO_ uint32_t* const)0x58000728U,   /** @brief SYSCFG user register 10 */
    [11] = (RO_ uint32_t* const)0x5800072CU,   /** @brief SYSCFG user register 11 */
    [12] = (RO_ uint32_t* const)0x58000730U,   /** @brief SYSCFG user register 12 */
    [13] = (RO_ uint32_t* const)0x58000734U,   /** @brief SYSCFG user register 13 */
    [14] = (RO_ uint32_t* const)0x58000738U,   /** @brief SYSCFG user register 14 */
    [15] = (RO_ uint32_t* const)0x5800073CU,   /** @brief SYSCFG user register 15 */
    [16] = (RO_ uint32_t* const)0x58000740U,   /** @brief SYSCFG user register 16 */
    [17] = (RO_ uint32_t* const)0x58000744U,   /** @brief SYSCFG user register 17 */
  };

  /**** @subsection SYSCFG Register Field Masks ****/

  static const uint32_t SYSCFG_PMCR_BOOSTE_MSK = 0x00000100U;   /** @brief Booster enable */
  static const uint32_t SYSCFG_PMCR_EPIS_MSK   = 0x00E00000U;   /** @brief Ethernet PHY interface selection */
  static const uint32_t SYSCFG_CCCSR_EN_MSK    = 0x00000001U;   /** @brief Enable */
  static const uint32_t SYSCFG_CCCSR_CS_MSK    = 0x00000002U;   /** @brief Code selection */
  static const uint32_t SYSCFG_CCCSR_READY_MSK = 0x00000100U;   /** @brief Compensation cell ready flag */
  static const uint32_t SYSCFG_CCCSR_HSLV_MSK  = 0x00010000U;   /** @brief High-speed at low-voltage */
  static const uint32_t SYSCFG_CCVR_NCV_MSK    = 0x0000000FU;   /** @brief NMOS compensation value */
  static const uint32_t SYSCFG_CCVR_PCV_MSK    = 0x000000F0U;   /** @brief PMOS compensation value */
  static const uint32_t SYSCFG_CCCR_NCC_MSK    = 0x0000000FU;   /** @brief NMOS compensation code */
  static const uint32_t SYSCFG_CCCR_PCC_MSK    = 0x000000F0U;   /** @brief PMOS compensation code */
  static const uint32_t SYSCFG_PKGR_PKG_MSK    = 0x0000000FU;   /** @brief Package */
  static const uint32_t SYSCFG_URx_BKS_MSK     = 0x00000001U;   /** @brief Bank swap */
  static const uint32_t SYSCFG_URx_RDP_MSK     = 0x00FF0000U;   /** @brief Readout protection */

  /**** @subsection Enumerated SYSCFG Register Field Masks ****/

  static const uint32_t SYSCFG_PMCR_I2CxFMP_MSK[5] = {
    [1] = 0x00000001U,   /** @brief I2C1 fm+ */
    [2] = 0x00000002U,   /** @brief I2C2 fm+ */
    [3] = 0x00000004U,   /** @brief I2C3 fm+ */
    [4] = 0x00000008U,   /** @brief I2C4 fm+ */
  };

  static const uint32_t SYSCFG_PMCR_PBxFMP_MSK[10] = {
    [6]  = 0x00000010U,   /** @brief PB(6) fm+ */
    [7]  = 0x00000020U,   /** @brief PB(7) fast mode plus */
    [8]  = 0x00000040U,   /** @brief PB(8) fast mode plus */
    [9]  = 0x00000080U,   /** @brief PB(9) fm+ */
  };

  static const uint32_t SYSCFG_PMCR_PAxSO_MSK[2] = {
    [0] = 0x01000000U,   /** @brief PA0 switch open */
    [1] = 0x02000000U,   /** @brief PA1 switch open */
  };

  static const uint32_t SYSCFG_PMCR_PCxSO_MSK[4] = {
    [2] = 0x04000000U,   /** @brief PC2 switch open */
    [3] = 0x08000000U,   /** @brief PC3 switch open */
  };

  static const uint32_t SYSCFG_EXTICRx_EXTIx_MSK[4] = {
    [0] = 0x0000000FU,   /** @brief EXTI x configuration (x = 0 to 3) */
    [1] = 0x000000F0U,   /** @brief EXTI x configuration (x = 0 to 3) */
    [2] = 0x00000F00U,   /** @brief EXTI x configuration (x = 0 to 3) */
    [3] = 0x0000F000U,   /** @brief EXTI x configuration (x = 0 to 3) */
  };

  /**** @subsection SYSCFG Register Field Positions ****/

  static const int32_t SYSCFG_PMCR_BOOSTE_POS = 8;    /** @brief Booster enable */
  static const int32_t SYSCFG_PMCR_EPIS_POS   = 21;   /** @brief Ethernet PHY interface selection */
  static const int32_t SYSCFG_CCCSR_EN_POS    = 0;    /** @brief Enable */
  static const int32_t SYSCFG_CCCSR_CS_POS    = 1;    /** @brief Code selection */
  static const int32_t SYSCFG_CCCSR_READY_POS = 8;    /** @brief Compensation cell ready flag */
  static const int32_t SYSCFG_CCCSR_HSLV_POS  = 16;   /** @brief High-speed at low-voltage */
  static const int32_t SYSCFG_CCVR_NCV_POS    = 0;    /** @brief NMOS compensation value */
  static const int32_t SYSCFG_CCVR_PCV_POS    = 4;    /** @brief PMOS compensation value */
  static const int32_t SYSCFG_CCCR_NCC_POS    = 0;    /** @brief NMOS compensation code */
  static const int32_t SYSCFG_CCCR_PCC_POS    = 4;    /** @brief PMOS compensation code */
  static const int32_t SYSCFG_PKGR_PKG_POS    = 0;    /** @brief Package */
  static const int32_t SYSCFG_URx_BKS_POS     = 0;    /** @brief Bank swap */
  static const int32_t SYSCFG_URx_RDP_POS     = 16;   /** @brief Readout protection */

  /**** @subsection Enumerated SYSCFG Register Field Positions ****/

  static const int32_t SYSCFG_PMCR_I2CxFMP_POS[5] = {
    [1] = 0,   /** @brief I2C1 fm+ */
    [2] = 1,   /** @brief I2C2 fm+ */
    [3] = 2,   /** @brief I2C3 fm+ */
    [4] = 3,   /** @brief I2C4 fm+ */
  };

  static const int32_t SYSCFG_PMCR_PBxFMP_POS[10] = {
    [6]  = 4,   /** @brief PB(6) fm+ */
    [7]  = 5,   /** @brief PB(7) fast mode plus */
    [8]  = 6,   /** @brief PB(8) fast mode plus */
    [9]  = 7,   /** @brief PB(9) fm+ */
  };

  static const int32_t SYSCFG_PMCR_PAxSO_POS[2] = {
    [0] = 24,   /** @brief PA0 switch open */
    [1] = 25,   /** @brief PA1 switch open */
  };

  static const int32_t SYSCFG_PMCR_PCxSO_POS[4] = {
    [2] = 26,   /** @brief PC2 switch open */
    [3] = 27,   /** @brief PC3 switch open */
  };

  static const int32_t SYSCFG_EXTICRx_EXTIx_POS[4] = {
    [0] = 0,    /** @brief EXTI x configuration (x = 0 to 3) */
    [1] = 4,    /** @brief EXTI x configuration (x = 0 to 3) */
    [2] = 8,    /** @brief EXTI x configuration (x = 0 to 3) */
    [3] = 12,   /** @brief EXTI x configuration (x = 0 to 3) */
  };

  /**********************************************************************************************
   * @section EXTI Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated EXTI Register Pointers ****/

  static RW_ uint32_t* const EXTI_RTSRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000000U,   /** @brief EXTI rising trigger selection register */
    [2] = (RW_ uint32_t* const)0x58000020U,   /** @brief EXTI rising trigger selection register */
    [3] = (RW_ uint32_t* const)0x58000040U,   /** @brief EXTI rising trigger selection register */
  };

  static RW_ uint32_t* const EXTI_FTSRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000004U,   /** @brief EXTI falling trigger selection register */
    [2] = (RW_ uint32_t* const)0x58000024U,   /** @brief EXTI falling trigger selection register */
    [3] = (RW_ uint32_t* const)0x58000044U,   /** @brief EXTI falling trigger selection register */
  };

  static RW_ uint32_t* const EXTI_SWIERx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000008U,   /** @brief EXTI software interrupt event register */
    [2] = (RW_ uint32_t* const)0x58000028U,   /** @brief EXTI software interrupt event register */
    [3] = (RW_ uint32_t* const)0x58000048U,   /** @brief EXTI software interrupt event register */
  };

  static RW_ uint32_t* const EXTI_D3PMRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x5800000CU,   /** @brief EXTI D3 pending mask register */
    [2] = (RW_ uint32_t* const)0x5800002CU,   /** @brief EXTI D3 pending mask register */
    [3] = (RW_ uint32_t* const)0x5800004CU,   /** @brief EXTI D3 pending mask register */
  };

  static RW_ uint32_t* const EXTI_D3PCRxL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x58000010U,   /** @brief EXTI D3 pending clear selection register low */
    [2] = (RW_ uint32_t* const)0x58000030U,   /** @brief EXTI D3 pending clear selection register low */
  };

  static RW_ uint32_t* const EXTI_D3PCRxH_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000014U,   /** @brief EXTI D3 pending clear selection register high */
    [2] = (RW_ uint32_t* const)0x58000034U,   /** @brief EXTI D3 pending clear selection register high */
    [3] = (RW_ uint32_t* const)0x58000054U,   /** @brief EXTI D3 pending clear selection register high */
  };

  static RW_ uint32_t* const EXTI_CPUIMRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000080U,   /** @brief EXTI interrupt mask register */
    [2] = (RW_ uint32_t* const)0x58000090U,   /** @brief EXTI interrupt mask register */
    [3] = (RW_ uint32_t* const)0x580000A0U,   /** @brief EXTI interrupt mask register */
  };

  static RW_ uint32_t* const EXTI_CPUEMRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000084U,   /** @brief EXTI event mask register */
    [2] = (RW_ uint32_t* const)0x58000094U,   /** @brief EXTI event mask register */
    [3] = (RW_ uint32_t* const)0x580000A4U,   /** @brief EXTI event mask register */
  };

  static RW_ uint32_t* const EXTI_CPUPRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x58000088U,   /** @brief EXTI pending register */
    [2] = (RW_ uint32_t* const)0x58000098U,   /** @brief EXTI pending register */
    [3] = (RW_ uint32_t* const)0x580000A8U,   /** @brief EXTI pending register */
  };

  /**** @subsection Enumerated EXTI Register Field Masks ****/

  static const uint32_t EXTI_RTSRx_TRx_MSK[22] = {
    [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const uint32_t EXTI_SWIERx_SWIERx_MSK[22] = {
    [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [16] = 0x00010000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [17] = 0x00020000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [18] = 0x00040000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const uint32_t EXTI_D3PMRx_MRx_MSK[26] = {
    [0]  = 0x00000001U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 0x00000002U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 0x00000004U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 0x00000008U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 0x00000010U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 0x00000020U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 0x00000040U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 0x00000080U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 0x00000100U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 0x00000200U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 0x00000400U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 0x00000800U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 0x00001000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 0x00002000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 0x00004000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 0x00008000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 0x00080000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 0x00100000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 0x00200000U,   /** @brief Rising trigger event configuration bit of configurable event input */
    [25] = 0x02000000U,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const uint32_t EXTI_D3PCRxL_PCSx_MSK[16] = {
    [0]  = 0x00000003U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [1]  = 0x0000000CU,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [2]  = 0x00000030U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [3]  = 0x000000C0U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [4]  = 0x00000300U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [5]  = 0x00000C00U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [6]  = 0x00003000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [7]  = 0x0000C000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [8]  = 0x00030000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [9]  = 0x000C0000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [10] = 0x00300000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [11] = 0x00C00000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [12] = 0x03000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [13] = 0x0C000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [14] = 0x30000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [15] = 0xC0000000U,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
  };

  static const uint32_t EXTI_CPUPRx_PRx_MSK[22] = {
    [0]  = 0x00000001U,   /** @brief CPU event mask on event input x */
    [1]  = 0x00000002U,   /** @brief CPU event mask on event input x */
    [2]  = 0x00000004U,   /** @brief CPU event mask on event input x */
    [3]  = 0x00000008U,   /** @brief CPU event mask on event input x */
    [4]  = 0x00000010U,   /** @brief CPU event mask on event input x */
    [5]  = 0x00000020U,   /** @brief CPU event mask on event input x */
    [6]  = 0x00000040U,   /** @brief CPU event mask on event input x */
    [7]  = 0x00000080U,   /** @brief CPU event mask on event input x */
    [8]  = 0x00000100U,   /** @brief CPU event mask on event input x */
    [9]  = 0x00000200U,   /** @brief CPU event mask on event input x */
    [10] = 0x00000400U,   /** @brief CPU event mask on event input x */
    [11] = 0x00000800U,   /** @brief CPU event mask on event input x */
    [12] = 0x00001000U,   /** @brief CPU event mask on event input x */
    [13] = 0x00002000U,   /** @brief CPU event mask on event input x */
    [14] = 0x00004000U,   /** @brief CPU event mask on event input x */
    [15] = 0x00008000U,   /** @brief CPU event mask on event input x */
    [16] = 0x00010000U,   /** @brief CPU event mask on event input x */
    [17] = 0x00020000U,   /** @brief CPU event mask on event input x */
    [18] = 0x00040000U,   /** @brief CPU event mask on event input x */
    [19] = 0x00080000U,   /** @brief CPU event mask on event input x */
    [20] = 0x00100000U,   /** @brief CPU event mask on event input x */
    [21] = 0x00200000U,   /** @brief CPU event mask on event input x */
  };

  /**** @subsection Enumerated EXTI Register Field Positions ****/

  static const int32_t EXTI_RTSRx_TRx_POS[22] = {
    [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
    [16] = 16,   /** @brief Rising trigger event configuration bit of configurable event input */
    [17] = 17,   /** @brief Rising trigger event configuration bit of configurable event input */
    [18] = 18,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const int32_t EXTI_SWIERx_SWIERx_POS[22] = {
    [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
    [16] = 16,   /** @brief Rising trigger event configuration bit of configurable event input */
    [17] = 17,   /** @brief Rising trigger event configuration bit of configurable event input */
    [18] = 18,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const int32_t EXTI_D3PMRx_MRx_POS[26] = {
    [0]  = 0,    /** @brief Rising trigger event configuration bit of configurable event input */
    [1]  = 1,    /** @brief Rising trigger event configuration bit of configurable event input */
    [2]  = 2,    /** @brief Rising trigger event configuration bit of configurable event input */
    [3]  = 3,    /** @brief Rising trigger event configuration bit of configurable event input */
    [4]  = 4,    /** @brief Rising trigger event configuration bit of configurable event input */
    [5]  = 5,    /** @brief Rising trigger event configuration bit of configurable event input */
    [6]  = 6,    /** @brief Rising trigger event configuration bit of configurable event input */
    [7]  = 7,    /** @brief Rising trigger event configuration bit of configurable event input */
    [8]  = 8,    /** @brief Rising trigger event configuration bit of configurable event input */
    [9]  = 9,    /** @brief Rising trigger event configuration bit of configurable event input */
    [10] = 10,   /** @brief Rising trigger event configuration bit of configurable event input */
    [11] = 11,   /** @brief Rising trigger event configuration bit of configurable event input */
    [12] = 12,   /** @brief Rising trigger event configuration bit of configurable event input */
    [13] = 13,   /** @brief Rising trigger event configuration bit of configurable event input */
    [14] = 14,   /** @brief Rising trigger event configuration bit of configurable event input */
    [15] = 15,   /** @brief Rising trigger event configuration bit of configurable event input */
    [19] = 19,   /** @brief Rising trigger event configuration bit of configurable event input */
    [20] = 20,   /** @brief Rising trigger event configuration bit of configurable event input */
    [21] = 21,   /** @brief Rising trigger event configuration bit of configurable event input */
    [25] = 25,   /** @brief Rising trigger event configuration bit of configurable event input */
  };

  static const int32_t EXTI_D3PCRxL_PCSx_POS[16] = {
    [0]  = 0,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [1]  = 2,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [2]  = 4,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [3]  = 6,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [4]  = 8,    /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [5]  = 10,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [6]  = 12,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [7]  = 14,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [8]  = 16,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [9]  = 18,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [10] = 20,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [11] = 22,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [12] = 24,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [13] = 26,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [14] = 28,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
    [15] = 30,   /** @brief D3 pending request clear input signal selection on event input x = truncate (n/2) */
  };

  static const int32_t EXTI_CPUPRx_PRx_POS[22] = {
    [0]  = 0,    /** @brief CPU event mask on event input x */
    [1]  = 1,    /** @brief CPU event mask on event input x */
    [2]  = 2,    /** @brief CPU event mask on event input x */
    [3]  = 3,    /** @brief CPU event mask on event input x */
    [4]  = 4,    /** @brief CPU event mask on event input x */
    [5]  = 5,    /** @brief CPU event mask on event input x */
    [6]  = 6,    /** @brief CPU event mask on event input x */
    [7]  = 7,    /** @brief CPU event mask on event input x */
    [8]  = 8,    /** @brief CPU event mask on event input x */
    [9]  = 9,    /** @brief CPU event mask on event input x */
    [10] = 10,   /** @brief CPU event mask on event input x */
    [11] = 11,   /** @brief CPU event mask on event input x */
    [12] = 12,   /** @brief CPU event mask on event input x */
    [13] = 13,   /** @brief CPU event mask on event input x */
    [14] = 14,   /** @brief CPU event mask on event input x */
    [15] = 15,   /** @brief CPU event mask on event input x */
    [16] = 16,   /** @brief CPU event mask on event input x */
    [17] = 17,   /** @brief CPU event mask on event input x */
    [18] = 18,   /** @brief CPU event mask on event input x */
    [19] = 19,   /** @brief CPU event mask on event input x */
    [20] = 20,   /** @brief CPU event mask on event input x */
    [21] = 21,   /** @brief CPU event mask on event input x */
  };

  /**********************************************************************************************
   * @section DELAY_BLOCK_SDMMCx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated DELAY_BLOCK_SDMMCx Register Pointers ****/

  static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52008000U,   /** @brief DLYB control register */
    [2] = (RW_ uint32_t* const)0x48022800U,   /** @brief DLYB control register */
  };

  static RW_ uint32_t* const DELAY_BLOCK_SDMMCx_CFGR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52008004U,   /** @brief DLYB configuration register */
    [2] = (RW_ uint32_t* const)0x48022804U,   /** @brief DLYB configuration register */
  };

  /**** @subsection DELAY_BLOCK_SDMMCx Register Field Masks ****/

  static const uint32_t DELAY_BLOCK_SDMMCx_CR_DEN_MSK    = 0x00000001U;   /** @brief Delay block enable bit */
  static const uint32_t DELAY_BLOCK_SDMMCx_CR_SEN_MSK    = 0x00000002U;   /** @brief Sampler length enable bit */
  static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_SEL_MSK  = 0x0000000FU;   /** @brief Select the phase for the output clock */
  static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_UNIT_MSK = 0x00007F00U;   /** @brief Delay defines the delay of a unit delay cell */
  static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_LNG_MSK  = 0x0FFF0000U;   /** @brief Delay line length value */
  static const uint32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF_MSK = 0x80000000U;   /** @brief Length valid flag */

  /**** @subsection DELAY_BLOCK_SDMMCx Register Field Positions ****/

  static const int32_t DELAY_BLOCK_SDMMCx_CR_DEN_POS    = 0;    /** @brief Delay block enable bit */
  static const int32_t DELAY_BLOCK_SDMMCx_CR_SEN_POS    = 1;    /** @brief Sampler length enable bit */
  static const int32_t DELAY_BLOCK_SDMMCx_CFGR_SEL_POS  = 0;    /** @brief Select the phase for the output clock */
  static const int32_t DELAY_BLOCK_SDMMCx_CFGR_UNIT_POS = 8;    /** @brief Delay defines the delay of a unit delay cell */
  static const int32_t DELAY_BLOCK_SDMMCx_CFGR_LNG_POS  = 16;   /** @brief Delay line length value */
  static const int32_t DELAY_BLOCK_SDMMCx_CFGR_LNGF_POS = 31;   /** @brief Length valid flag */

  /**********************************************************************************************
   * @section DELAY_BLOCK_QUADSPI Register Information
   **********************************************************************************************/

  /**** @subsection DELAY_BLOCK_QUADSPI Register Pointers ****/

  static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CR_PTR   = (RW_ uint32_t* const)0x52006000U;   /** @brief DLYB control register */
  static RW_ uint32_t* const DELAY_BLOCK_QUADSPI_CFGR_PTR = (RW_ uint32_t* const)0x52006004U;   /** @brief DLYB configuration register */

  /**** @subsection DELAY_BLOCK_QUADSPI Register Field Masks ****/

  static const uint32_t DELAY_BLOCK_QUADSPI_CR_DEN_MSK    = 0x00000001U;   /** @brief Delay block enable bit */
  static const uint32_t DELAY_BLOCK_QUADSPI_CR_SEN_MSK    = 0x00000002U;   /** @brief Sampler length enable bit */
  static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_MSK  = 0x0000000FU;   /** @brief Select the phase for the output clock */
  static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_MSK = 0x00007F00U;   /** @brief Delay defines the delay of a unit delay cell */
  static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_MSK  = 0x0FFF0000U;   /** @brief Delay line length value */
  static const uint32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_MSK = 0x80000000U;   /** @brief Length valid flag */

  /**** @subsection DELAY_BLOCK_QUADSPI Register Field Positions ****/

  static const int32_t DELAY_BLOCK_QUADSPI_CR_DEN_POS    = 0;    /** @brief Delay block enable bit */
  static const int32_t DELAY_BLOCK_QUADSPI_CR_SEN_POS    = 1;    /** @brief Sampler length enable bit */
  static const int32_t DELAY_BLOCK_QUADSPI_CFGR_SEL_POS  = 0;    /** @brief Select the phase for the output clock */
  static const int32_t DELAY_BLOCK_QUADSPI_CFGR_UNIT_POS = 8;    /** @brief Delay defines the delay of a unit delay cell */
  static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNG_POS  = 16;   /** @brief Delay line length value */
  static const int32_t DELAY_BLOCK_QUADSPI_CFGR_LNGF_POS = 31;   /** @brief Length valid flag */

  /**********************************************************************************************
   * @section FLASH Register Information
   **********************************************************************************************/

  /**** @subsection FLASH Register Pointers ****/

  static RW_ uint32_t* const FLASH_ACR_PTR        = (RW_ uint32_t* const)0x52002000U;   /** @brief Access control register */
  static RW_ uint32_t* const FLASH_ACR__PTR       = (RW_ uint32_t* const)0x52002100U;   /** @brief Access control register */
  static RW_ uint32_t* const FLASH_OPTKEYR_PTR    = (RW_ uint32_t* const)0x52002008U;   /** @brief FLASH option key register */
  static RW_ uint32_t* const FLASH_OPTKEYR__PTR   = (RW_ uint32_t* const)0x52002108U;   /** @brief FLASH option key register */
  static RW_ uint32_t* const FLASH_OPTCR_PTR      = (RW_ uint32_t* const)0x52002018U;   /** @brief FLASH option control register */
  static RW_ uint32_t* const FLASH_OPTCR__PTR     = (RW_ uint32_t* const)0x52002118U;   /** @brief FLASH option control register */
  static RW_ uint32_t* const FLASH_OPTSR_CUR__PTR = (RW_ uint32_t* const)0x5200211CU;   /** @brief FLASH option status register */
  static RW_ uint32_t* const FLASH_OPTSR_CUR_PTR  = (RW_ uint32_t* const)0x5200201CU;   /** @brief FLASH option status register */
  static RW_ uint32_t* const FLASH_OPTSR_PRG_PTR  = (RW_ uint32_t* const)0x52002020U;   /** @brief FLASH option status register */
  static RW_ uint32_t* const FLASH_OPTSR_PRG__PTR = (RW_ uint32_t* const)0x52002120U;   /** @brief FLASH option status register */
  static WO_ uint32_t* const FLASH_OPTCCR__PTR    = (WO_ uint32_t* const)0x52002124U;   /** @brief FLASH option clear control register */
  static WO_ uint32_t* const FLASH_OPTCCR_PTR     = (WO_ uint32_t* const)0x52002024U;   /** @brief FLASH option clear control register */
  static RO_ uint32_t* const FLASH_BOOT_CURR_PTR  = (RO_ uint32_t* const)0x52002040U;   /** @brief FLASH register with boot address */
  static RO_ uint32_t* const FLASH_BOOT_PRGR_PTR  = (RO_ uint32_t* const)0x52002044U;   /** @brief FLASH register with boot address */
  static RW_ uint32_t* const FLASH_CRCDATAR_PTR   = (RW_ uint32_t* const)0x5200205CU;   /** @brief FLASH CRC data register */

  /**** @subsection Enumerated FLASH Register Pointers ****/

  static RW_ uint32_t* const FLASH_KEYRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002004U,   /** @brief FLASH key register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002104U,   /** @brief FLASH key register for bank 2 */
  };

  static RW_ uint32_t* const FLASH_CRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200200CU,   /** @brief FLASH control register for bank 1 */
    [2] = (RW_ uint32_t* const)0x5200210CU,   /** @brief FLASH control register for bank 2 */
  };

  static RW_ uint32_t* const FLASH_SRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002010U,   /** @brief FLASH status register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002110U,   /** @brief FLASH status register for bank 2 */
  };

  static RW_ uint32_t* const FLASH_CCRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002014U,   /** @brief FLASH clear control register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002114U,   /** @brief FLASH clear control register for bank 2 */
  };

  static RO_ uint32_t* const FLASH_PRAR_CURx_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52002028U,   /** @brief FLASH protection address for bank 1 */
    [2] = (RO_ uint32_t* const)0x52002128U,   /** @brief FLASH protection address for bank 1 */
  };

  static RW_ uint32_t* const FLASH_PRAR_PRGx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200202CU,   /** @brief FLASH protection address for bank 1 */
    [2] = (RW_ uint32_t* const)0x5200202CU,   /** @brief FLASH protection address for bank 2 */
  };

  static RW_ uint32_t* const FLASH_SCAR_CURx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002030U,   /** @brief FLASH secure address for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002130U,   /** @brief FLASH secure address for bank 2 */
  };

  static RW_ uint32_t* const FLASH_SCAR_PRGx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002034U,   /** @brief FLASH secure address for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002134U,   /** @brief FLASH secure address for bank 2 */
  };

  static RO_ uint32_t* const FLASH_WPSN_CURxR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52002038U,   /** @brief FLASH write sector protection for bank 1 */
    [2] = (RO_ uint32_t* const)0x52002138U,   /** @brief FLASH write sector protection for bank 2 */
  };

  static RW_ uint32_t* const FLASH_WPSN_PRGxR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5200203CU,   /** @brief FLASH write sector protection for bank 1 */
    [2] = (RW_ uint32_t* const)0x5200213CU,   /** @brief FLASH write sector protection for bank 2 */
  };

  static RW_ uint32_t* const FLASH_CRCCRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002050U,   /** @brief FLASH CRC control register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002150U,   /** @brief FLASH CRC control register for bank 1 */
  };

  static RW_ uint32_t* const FLASH_CRCSADDxR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002054U,   /** @brief FLASH CRC start address register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002154U,   /** @brief FLASH CRC start address register for bank 2 */
  };

  static RW_ uint32_t* const FLASH_CRCEADDxR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x52002058U,   /** @brief FLASH CRC end address register for bank 1 */
    [2] = (RW_ uint32_t* const)0x52002158U,   /** @brief FLASH CRC end address register for bank 2 */
  };

  static RO_ uint32_t* const FLASH_ECC_FAxR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x52002060U,   /** @brief FLASH ECC fail address for bank 1 */
    [2] = (RO_ uint32_t* const)0x52002160U,   /** @brief FLASH ECC fail address for bank 2 */
  };

  /**** @subsection FLASH Register Field Masks ****/

  static const uint32_t FLASH_ACR_LATENCY_MSK                = 0x00000007U;   /** @brief Read latency */
  static const uint32_t FLASH_ACR_WRHIGHFREQ_MSK             = 0x00000030U;   /** @brief Flash signal delay */
  static const uint32_t FLASH_ACR__LATENCY_MSK               = 0x00000007U;   /** @brief Read latency */
  static const uint32_t FLASH_ACR__WRHIGHFREQ_MSK            = 0x00000030U;   /** @brief Flash signal delay */
  static const uint32_t FLASH_CRx_LOCK1_MSK                  = 0x00000001U;   /** @brief Bank 1 configuration lock bit */
  static const uint32_t FLASH_CRx_PG1_MSK                    = 0x00000002U;   /** @brief Bank 1 program enable bit */
  static const uint32_t FLASH_CRx_SER1_MSK                   = 0x00000004U;   /** @brief Bank 1 sector erase request */
  static const uint32_t FLASH_CRx_BER1_MSK                   = 0x00000008U;   /** @brief Bank 1 erase request */
  static const uint32_t FLASH_CRx_PSIZE1_MSK                 = 0x00000030U;   /** @brief Bank 1 program size */
  static const uint32_t FLASH_CRx_FW1_MSK                    = 0x00000040U;   /** @brief Bank 1 write forcing control bit */
  static const uint32_t FLASH_CRx_START1_MSK                 = 0x00000080U;   /** @brief Bank 1 bank or sector erase start control bit */
  static const uint32_t FLASH_CRx_SNB1_MSK                   = 0x00000700U;   /** @brief Bank 1 sector erase selection number */
  static const uint32_t FLASH_CRx_CRC_EN_MSK                 = 0x00008000U;   /** @brief Bank 1 CRC control bit */
  static const uint32_t FLASH_CRx_EOPIE1_MSK                 = 0x00010000U;   /** @brief Bank 1 end-of-program interrupt control bit */
  static const uint32_t FLASH_CRx_WRPERRIE1_MSK              = 0x00020000U;   /** @brief Bank 1 write protection error interrupt enable bit */
  static const uint32_t FLASH_CRx_PGSERRIE1_MSK              = 0x00040000U;   /** @brief Bank 1 programming sequence error interrupt enable bit */
  static const uint32_t FLASH_CRx_STRBERRIE1_MSK             = 0x00080000U;   /** @brief Bank 1 strobe error interrupt enable bit */
  static const uint32_t FLASH_CRx_INCERRIE1_MSK              = 0x00200000U;   /** @brief Bank 1 inconsistency error interrupt enable bit */
  static const uint32_t FLASH_CRx_OPERRIE1_MSK               = 0x00400000U;   /** @brief Bank 1 write/erase error interrupt enable bit */
  static const uint32_t FLASH_CRx_RDPERRIE1_MSK              = 0x00800000U;   /** @brief Bank 1 read protection error interrupt enable bit */
  static const uint32_t FLASH_CRx_RDSERRIE1_MSK              = 0x01000000U;   /** @brief Bank 1 secure error interrupt enable bit */
  static const uint32_t FLASH_CRx_SNECCERRIE1_MSK            = 0x02000000U;   /** @brief Bank 1 ECC single correction error interrupt enable bit */
  static const uint32_t FLASH_CRx_DBECCERRIE1_MSK            = 0x04000000U;   /** @brief Bank 1 ECC double detection error interrupt enable bit */
  static const uint32_t FLASH_CRx_CRCENDIE1_MSK              = 0x08000000U;   /** @brief Bank 1 end of CRC calculation interrupt enable bit */
  static const uint32_t FLASH_SRx_BSY1_MSK                   = 0x00000001U;   /** @brief Bank 1 ongoing program flag */
  static const uint32_t FLASH_SRx_WBNE1_MSK                  = 0x00000002U;   /** @brief Bank 1 write buffer not empty flag */
  static const uint32_t FLASH_SRx_QW1_MSK                    = 0x00000004U;   /** @brief Bank 1 wait queue flag */
  static const uint32_t FLASH_SRx_CRC_BUSY1_MSK              = 0x00000008U;   /** @brief Bank 1 CRC busy flag */
  static const uint32_t FLASH_SRx_EOP1_MSK                   = 0x00010000U;   /** @brief Bank 1 end-of-program flag */
  static const uint32_t FLASH_SRx_WRPERR1_MSK                = 0x00020000U;   /** @brief Bank 1 write protection error flag */
  static const uint32_t FLASH_SRx_PGSERR1_MSK                = 0x00040000U;   /** @brief Bank 1 programming sequence error flag */
  static const uint32_t FLASH_SRx_STRBERR1_MSK               = 0x00080000U;   /** @brief Bank 1 strobe error flag */
  static const uint32_t FLASH_SRx_INCERR1_MSK                = 0x00200000U;   /** @brief Bank 1 inconsistency error flag */
  static const uint32_t FLASH_SRx_OPERR1_MSK                 = 0x00400000U;   /** @brief Bank 1 write/erase error flag */
  static const uint32_t FLASH_SRx_RDPERR1_MSK                = 0x00800000U;   /** @brief Bank 1 read protection error flag */
  static const uint32_t FLASH_SRx_RDSERR1_MSK                = 0x01000000U;   /** @brief Bank 1 secure error flag */
  static const uint32_t FLASH_SRx_SNECCERR11_MSK             = 0x02000000U;   /** @brief Bank 1 single correction error flag */
  static const uint32_t FLASH_SRx_DBECCERR1_MSK              = 0x04000000U;   /** @brief Bank 1 ECC double detection error flag */
  static const uint32_t FLASH_SRx_CRCEND1_MSK                = 0x08000000U;   /** @brief Bank 1 crc-complete flag */
  static const uint32_t FLASH_CCRx_CLR_EOP1_MSK              = 0x00010000U;   /** @brief Bank 1 EOP1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_WRPERR1_MSK           = 0x00020000U;   /** @brief Bank 1 WRPERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_PGSERR1_MSK           = 0x00040000U;   /** @brief Bank 1 PGSERR1 flag clear bi */
  static const uint32_t FLASH_CCRx_CLR_STRBERR1_MSK          = 0x00080000U;   /** @brief Bank 1 STRBERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_INCERR1_MSK           = 0x00200000U;   /** @brief Bank 1 INCERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_OPERR1_MSK            = 0x00400000U;   /** @brief Bank 1 OPERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_RDPERR1_MSK           = 0x00800000U;   /** @brief Bank 1 RDPERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_RDSERR1_MSK           = 0x01000000U;   /** @brief Bank 1 RDSERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_SNECCERR1_MSK         = 0x02000000U;   /** @brief Bank 1 SNECCERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_DBECCERR1_MSK         = 0x04000000U;   /** @brief Bank 1 DBECCERR1 flag clear bit */
  static const uint32_t FLASH_CCRx_CLR_CRCEND1_MSK           = 0x08000000U;   /** @brief Bank 1 CRCEND1 flag clear bit */
  static const uint32_t FLASH_OPTCR_OPTLOCK_MSK              = 0x00000001U;   /** @brief FLASH_OPTCR lock option configuration bit */
  static const uint32_t FLASH_OPTCR_OPTSTART_MSK             = 0x00000002U;   /** @brief Option byte start change option configuration bit */
  static const uint32_t FLASH_OPTCR_MER_MSK                  = 0x00000010U;   /** @brief Flash mass erase enable bit */
  static const uint32_t FLASH_OPTCR_OPTCHANGEERRIE_MSK       = 0x40000000U;   /** @brief Option byte change error interrupt enable bit */
  static const uint32_t FLASH_OPTCR_SWAP_BANK_MSK            = 0x80000000U;   /** @brief Bank swapping configuration bit */
  static const uint32_t FLASH_OPTCR__OPTLOCK_MSK             = 0x00000001U;   /** @brief FLASH_OPTCR lock option configuration bit */
  static const uint32_t FLASH_OPTCR__OPTSTART_MSK            = 0x00000002U;   /** @brief Option byte start change option configuration bit */
  static const uint32_t FLASH_OPTCR__MER_MSK                 = 0x00000010U;   /** @brief Flash mass erase enable bit */
  static const uint32_t FLASH_OPTCR__OPTCHANGEERRIE_MSK      = 0x40000000U;   /** @brief Option byte change error interrupt enable bit */
  static const uint32_t FLASH_OPTCR__SWAP_BANK_MSK           = 0x80000000U;   /** @brief Bank swapping configuration bit */
  static const uint32_t FLASH_OPTSR_CUR__OPT_BUSY_MSK        = 0x00000001U;   /** @brief Option byte change ongoing flag */
  static const uint32_t FLASH_OPTSR_CUR__BOR_LEV_MSK         = 0x0000000CU;   /** @brief Brownout level option status bit */
  static const uint32_t FLASH_OPTSR_CUR__IWDG1_HW_MSK        = 0x00000010U;   /** @brief IWDG1 control option status bit */
  static const uint32_t FLASH_OPTSR_CUR__NRST_STOP_D1_MSK    = 0x00000040U;   /** @brief D1 dstop entry reset option status bit */
  static const uint32_t FLASH_OPTSR_CUR__NRST_STBY_D1_MSK    = 0x00000080U;   /** @brief D1 dstandby entry reset option status bit */
  static const uint32_t FLASH_OPTSR_CUR__RDP_MSK             = 0x0000FF00U;   /** @brief Readout protection level option status byte */
  static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP_MSK    = 0x00020000U;   /** @brief IWDG stop mode freeze option status bit */
  static const uint32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY_MSK    = 0x00040000U;   /** @brief IWDG standby mode freeze option status bit */
  static const uint32_t FLASH_OPTSR_CUR__ST_RAM_SIZE_MSK     = 0x00180000U;   /** @brief DTCM RAM size option status */
  static const uint32_t FLASH_OPTSR_CUR__SECURITY_MSK        = 0x00200000U;   /** @brief Security enable option status bit */
  static const uint32_t FLASH_OPTSR_CUR__RSS1_MSK            = 0x04000000U;   /** @brief User option bit 1 */
  static const uint32_t FLASH_OPTSR_CUR__PERSO_OK_MSK        = 0x10000000U;   /** @brief Device personalization status bit */
  static const uint32_t FLASH_OPTSR_CUR__IO_HSLV_MSK         = 0x20000000U;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
  static const uint32_t FLASH_OPTSR_CUR__OPTCHANGEERR_MSK    = 0x40000000U;   /** @brief Option byte change error flag */
  static const uint32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_MSK   = 0x80000000U;   /** @brief Bank swapping option status bit */
  static const uint32_t FLASH_OPTSR_CUR_OPT_BUSY_MSK         = 0x00000001U;   /** @brief Option byte change ongoing flag */
  static const uint32_t FLASH_OPTSR_CUR_BOR_LEV_MSK          = 0x0000000CU;   /** @brief Brownout level option status bit */
  static const uint32_t FLASH_OPTSR_CUR_IWDG1_HW_MSK         = 0x00000010U;   /** @brief IWDG1 control option status bit */
  static const uint32_t FLASH_OPTSR_CUR_NRST_STOP_D1_MSK     = 0x00000040U;   /** @brief D1 dstop entry reset option status bit */
  static const uint32_t FLASH_OPTSR_CUR_NRST_STBY_D1_MSK     = 0x00000080U;   /** @brief D1 dstandby entry reset option status bit */
  static const uint32_t FLASH_OPTSR_CUR_RDP_MSK              = 0x0000FF00U;   /** @brief Readout protection level option status byte */
  static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP_MSK     = 0x00020000U;   /** @brief IWDG stop mode freeze option status bit */
  static const uint32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY_MSK     = 0x00040000U;   /** @brief IWDG standby mode freeze option status bit */
  static const uint32_t FLASH_OPTSR_CUR_ST_RAM_SIZE_MSK      = 0x00180000U;   /** @brief DTCM RAM size option status */
  static const uint32_t FLASH_OPTSR_CUR_SECURITY_MSK         = 0x00200000U;   /** @brief Security enable option status bit */
  static const uint32_t FLASH_OPTSR_CUR_RSS1_MSK             = 0x04000000U;   /** @brief User option bit 1 */
  static const uint32_t FLASH_OPTSR_CUR_PERSO_OK_MSK         = 0x10000000U;   /** @brief Device personalization status bit */
  static const uint32_t FLASH_OPTSR_CUR_IO_HSLV_MSK          = 0x20000000U;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
  static const uint32_t FLASH_OPTSR_CUR_OPTCHANGEERR_MSK     = 0x40000000U;   /** @brief Option byte change error flag */
  static const uint32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_MSK    = 0x80000000U;   /** @brief Bank swapping option status bit */
  static const uint32_t FLASH_OPTSR_PRG_BOR_LEV_MSK          = 0x0000000CU;   /** @brief BOR reset level option configuration bits */
  static const uint32_t FLASH_OPTSR_PRG_IWDG1_HW_MSK         = 0x00000010U;   /** @brief IWDG1 option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_NRST_STOP_D1_MSK     = 0x00000040U;   /** @brief Option byte erase after D1 dstop option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_NRST_STBY_D1_MSK     = 0x00000080U;   /** @brief Option byte erase after D1 dstandby option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_RDP_MSK              = 0x0000FF00U;   /** @brief Readout protection level option configuration byte */
  static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP_MSK     = 0x00020000U;   /** @brief IWDG stop mode freeze option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY_MSK     = 0x00040000U;   /** @brief IWDG standby mode freeze option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_ST_RAM_SIZE_MSK      = 0x00180000U;   /** @brief DTCM size select option configuration bits */
  static const uint32_t FLASH_OPTSR_PRG_SECURITY_MSK         = 0x00200000U;   /** @brief Security option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG_IO_HSLV_MSK          = 0x20000000U;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
  static const uint32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_MSK    = 0x80000000U;   /** @brief Bank swapping option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__BOR_LEV_MSK         = 0x0000000CU;   /** @brief BOR reset level option configuration bits */
  static const uint32_t FLASH_OPTSR_PRG__IWDG1_HW_MSK        = 0x00000010U;   /** @brief IWDG1 option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__NRST_STOP_D1_MSK    = 0x00000040U;   /** @brief Option byte erase after D1 dstop option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__NRST_STBY_D1_MSK    = 0x00000080U;   /** @brief Option byte erase after D1 dstandby option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__RDP_MSK             = 0x0000FF00U;   /** @brief Readout protection level option configuration byte */
  static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP_MSK    = 0x00020000U;   /** @brief IWDG stop mode freeze option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY_MSK    = 0x00040000U;   /** @brief IWDG standby mode freeze option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__ST_RAM_SIZE_MSK     = 0x00180000U;   /** @brief DTCM size select option configuration bits */
  static const uint32_t FLASH_OPTSR_PRG__SECURITY_MSK        = 0x00200000U;   /** @brief Security option configuration bit */
  static const uint32_t FLASH_OPTSR_PRG__IO_HSLV_MSK         = 0x20000000U;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
  static const uint32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_MSK   = 0x80000000U;   /** @brief Bank swapping option configuration bit */
  static const uint32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_MSK   = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
  static const uint32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_MSK    = 0x40000000U;   /** @brief OPTCHANGEERR reset bit */
  static const uint32_t FLASH_PRAR_CURx_PROT_AREA_START1_MSK = 0x00000FFFU;   /** @brief Bank 1 lowest PCROP protected address */
  static const uint32_t FLASH_PRAR_CURx_PROT_AREA_END1_MSK   = 0x0FFF0000U;   /** @brief Bank 1 highest PCROP protected address */
  static const uint32_t FLASH_PRAR_CURx_DMEP1_MSK            = 0x80000000U;   /** @brief Bank 1 PCROP protected erase enable option status bit */
  static const uint32_t FLASH_PRAR_PRGx_PROT_AREA_START1_MSK = 0x00000FFFU;   /** @brief Bank 1 lowest PCROP protected address configuration */
  static const uint32_t FLASH_PRAR_PRGx_PROT_AREA_END1_MSK   = 0x0FFF0000U;   /** @brief Bank 1 highest PCROP protected address configuration */
  static const uint32_t FLASH_PRAR_PRGx_DMEP1_MSK            = 0x80000000U;   /** @brief Bank 1 PCROP protected erase enable option configuration bit */
  static const uint32_t FLASH_SCAR_CURx_SEC_AREA_START1_MSK  = 0x00000FFFU;   /** @brief Bank 1 lowest secure protected address */
  static const uint32_t FLASH_SCAR_CURx_SEC_AREA_END1_MSK    = 0x0FFF0000U;   /** @brief Bank 1 highest secure protected address */
  static const uint32_t FLASH_SCAR_CURx_DMES1_MSK            = 0x80000000U;   /** @brief Bank 1 secure protected erase enable option status bit */
  static const uint32_t FLASH_SCAR_PRGx_SEC_AREA_START1_MSK  = 0x00000FFFU;   /** @brief Bank 1 lowest secure protected address configuration */
  static const uint32_t FLASH_SCAR_PRGx_SEC_AREA_END1_MSK    = 0x0FFF0000U;   /** @brief Bank 1 highest secure protected address configuration */
  static const uint32_t FLASH_SCAR_PRGx_DMES1_MSK            = 0x80000000U;   /** @brief Bank 1 secure protected erase enable option configuration bit */
  static const uint32_t FLASH_WPSN_CURxR_WRPSN1_MSK          = 0x000000FFU;   /** @brief Bank 1 sector write protection option status byte */
  static const uint32_t FLASH_WPSN_PRGxR_WRPSN1_MSK          = 0x000000FFU;   /** @brief Bank 1 sector write protection configuration byte */
  static const uint32_t FLASH_CRCCRx_CRC_SECT_MSK            = 0x00000007U;   /** @brief Bank 1 CRC sector number */
  static const uint32_t FLASH_CRCCRx_ALL_BANK_MSK            = 0x00000080U;   /** @brief Bank 1 CRC select bit */
  static const uint32_t FLASH_CRCCRx_CRC_BY_SECT_MSK         = 0x00000100U;   /** @brief Bank 1 CRC sector mode select bit */
  static const uint32_t FLASH_CRCCRx_ADD_SECT_MSK            = 0x00000200U;   /** @brief Bank 1 CRC sector select bit */
  static const uint32_t FLASH_CRCCRx_CLEAN_SECT_MSK          = 0x00000400U;   /** @brief Bank 1 CRC sector list clear bit */
  static const uint32_t FLASH_CRCCRx_START_CRC_MSK           = 0x00010000U;   /** @brief Bank 1 CRC start bit */
  static const uint32_t FLASH_CRCCRx_CLEAN_CRC_MSK           = 0x00020000U;   /** @brief Bank 1 CRC clear bit */
  static const uint32_t FLASH_CRCCRx_CRC_BURST_MSK           = 0x00300000U;   /** @brief Bank 1 CRC burst size */
  static const uint32_t FLASH_ECC_FAxR_FAIL_ECC_ADDR1_MSK    = 0x00007FFFU;   /** @brief Bank 1 ECC error address */

  /**** @subsection Enumerated FLASH Register Field Masks ****/

  static const uint32_t FLASH_OPTSR_PRG_RSSx_MSK[3] = {
    [1] = 0x04000000U,   /** @brief User option configuration bit 1 */
    [2] = 0x08000000U,   /** @brief User option configuration bit 2 */
  };

  static const uint32_t FLASH_BOOT_CURR_BOOT_ADDx_MSK[2] = {
    [0] = 0x0000FFFFU,   /** @brief Boot address 0 */
    [1] = 0xFFFF0000U,   /** @brief Boot address 1 */
  };

  /**** @subsection FLASH Register Field Positions ****/

  static const int32_t FLASH_ACR_LATENCY_POS                = 0;    /** @brief Read latency */
  static const int32_t FLASH_ACR_WRHIGHFREQ_POS             = 4;    /** @brief Flash signal delay */
  static const int32_t FLASH_ACR__LATENCY_POS               = 0;    /** @brief Read latency */
  static const int32_t FLASH_ACR__WRHIGHFREQ_POS            = 4;    /** @brief Flash signal delay */
  static const int32_t FLASH_CRx_LOCK1_POS                  = 0;    /** @brief Bank 1 configuration lock bit */
  static const int32_t FLASH_CRx_PG1_POS                    = 1;    /** @brief Bank 1 program enable bit */
  static const int32_t FLASH_CRx_SER1_POS                   = 2;    /** @brief Bank 1 sector erase request */
  static const int32_t FLASH_CRx_BER1_POS                   = 3;    /** @brief Bank 1 erase request */
  static const int32_t FLASH_CRx_PSIZE1_POS                 = 4;    /** @brief Bank 1 program size */
  static const int32_t FLASH_CRx_FW1_POS                    = 6;    /** @brief Bank 1 write forcing control bit */
  static const int32_t FLASH_CRx_START1_POS                 = 7;    /** @brief Bank 1 bank or sector erase start control bit */
  static const int32_t FLASH_CRx_SNB1_POS                   = 8;    /** @brief Bank 1 sector erase selection number */
  static const int32_t FLASH_CRx_CRC_EN_POS                 = 15;   /** @brief Bank 1 CRC control bit */
  static const int32_t FLASH_CRx_EOPIE1_POS                 = 16;   /** @brief Bank 1 end-of-program interrupt control bit */
  static const int32_t FLASH_CRx_WRPERRIE1_POS              = 17;   /** @brief Bank 1 write protection error interrupt enable bit */
  static const int32_t FLASH_CRx_PGSERRIE1_POS              = 18;   /** @brief Bank 1 programming sequence error interrupt enable bit */
  static const int32_t FLASH_CRx_STRBERRIE1_POS             = 19;   /** @brief Bank 1 strobe error interrupt enable bit */
  static const int32_t FLASH_CRx_INCERRIE1_POS              = 21;   /** @brief Bank 1 inconsistency error interrupt enable bit */
  static const int32_t FLASH_CRx_OPERRIE1_POS               = 22;   /** @brief Bank 1 write/erase error interrupt enable bit */
  static const int32_t FLASH_CRx_RDPERRIE1_POS              = 23;   /** @brief Bank 1 read protection error interrupt enable bit */
  static const int32_t FLASH_CRx_RDSERRIE1_POS              = 24;   /** @brief Bank 1 secure error interrupt enable bit */
  static const int32_t FLASH_CRx_SNECCERRIE1_POS            = 25;   /** @brief Bank 1 ECC single correction error interrupt enable bit */
  static const int32_t FLASH_CRx_DBECCERRIE1_POS            = 26;   /** @brief Bank 1 ECC double detection error interrupt enable bit */
  static const int32_t FLASH_CRx_CRCENDIE1_POS              = 27;   /** @brief Bank 1 end of CRC calculation interrupt enable bit */
  static const int32_t FLASH_SRx_BSY1_POS                   = 0;    /** @brief Bank 1 ongoing program flag */
  static const int32_t FLASH_SRx_WBNE1_POS                  = 1;    /** @brief Bank 1 write buffer not empty flag */
  static const int32_t FLASH_SRx_QW1_POS                    = 2;    /** @brief Bank 1 wait queue flag */
  static const int32_t FLASH_SRx_CRC_BUSY1_POS              = 3;    /** @brief Bank 1 CRC busy flag */
  static const int32_t FLASH_SRx_EOP1_POS                   = 16;   /** @brief Bank 1 end-of-program flag */
  static const int32_t FLASH_SRx_WRPERR1_POS                = 17;   /** @brief Bank 1 write protection error flag */
  static const int32_t FLASH_SRx_PGSERR1_POS                = 18;   /** @brief Bank 1 programming sequence error flag */
  static const int32_t FLASH_SRx_STRBERR1_POS               = 19;   /** @brief Bank 1 strobe error flag */
  static const int32_t FLASH_SRx_INCERR1_POS                = 21;   /** @brief Bank 1 inconsistency error flag */
  static const int32_t FLASH_SRx_OPERR1_POS                 = 22;   /** @brief Bank 1 write/erase error flag */
  static const int32_t FLASH_SRx_RDPERR1_POS                = 23;   /** @brief Bank 1 read protection error flag */
  static const int32_t FLASH_SRx_RDSERR1_POS                = 24;   /** @brief Bank 1 secure error flag */
  static const int32_t FLASH_SRx_SNECCERR11_POS             = 25;   /** @brief Bank 1 single correction error flag */
  static const int32_t FLASH_SRx_DBECCERR1_POS              = 26;   /** @brief Bank 1 ECC double detection error flag */
  static const int32_t FLASH_SRx_CRCEND1_POS                = 27;   /** @brief Bank 1 crc-complete flag */
  static const int32_t FLASH_CCRx_CLR_EOP1_POS              = 16;   /** @brief Bank 1 EOP1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_WRPERR1_POS           = 17;   /** @brief Bank 1 WRPERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_PGSERR1_POS           = 18;   /** @brief Bank 1 PGSERR1 flag clear bi */
  static const int32_t FLASH_CCRx_CLR_STRBERR1_POS          = 19;   /** @brief Bank 1 STRBERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_INCERR1_POS           = 21;   /** @brief Bank 1 INCERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_OPERR1_POS            = 22;   /** @brief Bank 1 OPERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_RDPERR1_POS           = 23;   /** @brief Bank 1 RDPERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_RDSERR1_POS           = 24;   /** @brief Bank 1 RDSERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_SNECCERR1_POS         = 25;   /** @brief Bank 1 SNECCERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_DBECCERR1_POS         = 26;   /** @brief Bank 1 DBECCERR1 flag clear bit */
  static const int32_t FLASH_CCRx_CLR_CRCEND1_POS           = 27;   /** @brief Bank 1 CRCEND1 flag clear bit */
  static const int32_t FLASH_OPTCR_OPTLOCK_POS              = 0;    /** @brief FLASH_OPTCR lock option configuration bit */
  static const int32_t FLASH_OPTCR_OPTSTART_POS             = 1;    /** @brief Option byte start change option configuration bit */
  static const int32_t FLASH_OPTCR_MER_POS                  = 4;    /** @brief Flash mass erase enable bit */
  static const int32_t FLASH_OPTCR_OPTCHANGEERRIE_POS       = 30;   /** @brief Option byte change error interrupt enable bit */
  static const int32_t FLASH_OPTCR_SWAP_BANK_POS            = 31;   /** @brief Bank swapping configuration bit */
  static const int32_t FLASH_OPTCR__OPTLOCK_POS             = 0;    /** @brief FLASH_OPTCR lock option configuration bit */
  static const int32_t FLASH_OPTCR__OPTSTART_POS            = 1;    /** @brief Option byte start change option configuration bit */
  static const int32_t FLASH_OPTCR__MER_POS                 = 4;    /** @brief Flash mass erase enable bit */
  static const int32_t FLASH_OPTCR__OPTCHANGEERRIE_POS      = 30;   /** @brief Option byte change error interrupt enable bit */
  static const int32_t FLASH_OPTCR__SWAP_BANK_POS           = 31;   /** @brief Bank swapping configuration bit */
  static const int32_t FLASH_OPTSR_CUR__OPT_BUSY_POS        = 0;    /** @brief Option byte change ongoing flag */
  static const int32_t FLASH_OPTSR_CUR__BOR_LEV_POS         = 2;    /** @brief Brownout level option status bit */
  static const int32_t FLASH_OPTSR_CUR__IWDG1_HW_POS        = 4;    /** @brief IWDG1 control option status bit */
  static const int32_t FLASH_OPTSR_CUR__NRST_STOP_D1_POS    = 6;    /** @brief D1 dstop entry reset option status bit */
  static const int32_t FLASH_OPTSR_CUR__NRST_STBY_D1_POS    = 7;    /** @brief D1 dstandby entry reset option status bit */
  static const int32_t FLASH_OPTSR_CUR__RDP_POS             = 8;    /** @brief Readout protection level option status byte */
  static const int32_t FLASH_OPTSR_CUR__FZ_IWDG_STOP_POS    = 17;   /** @brief IWDG stop mode freeze option status bit */
  static const int32_t FLASH_OPTSR_CUR__FZ_IWDG_SDBY_POS    = 18;   /** @brief IWDG standby mode freeze option status bit */
  static const int32_t FLASH_OPTSR_CUR__ST_RAM_SIZE_POS     = 19;   /** @brief DTCM RAM size option status */
  static const int32_t FLASH_OPTSR_CUR__SECURITY_POS        = 21;   /** @brief Security enable option status bit */
  static const int32_t FLASH_OPTSR_CUR__RSS1_POS            = 26;   /** @brief User option bit 1 */
  static const int32_t FLASH_OPTSR_CUR__PERSO_OK_POS        = 28;   /** @brief Device personalization status bit */
  static const int32_t FLASH_OPTSR_CUR__IO_HSLV_POS         = 29;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
  static const int32_t FLASH_OPTSR_CUR__OPTCHANGEERR_POS    = 30;   /** @brief Option byte change error flag */
  static const int32_t FLASH_OPTSR_CUR__SWAP_BANK_OPT_POS   = 31;   /** @brief Bank swapping option status bit */
  static const int32_t FLASH_OPTSR_CUR_OPT_BUSY_POS         = 0;    /** @brief Option byte change ongoing flag */
  static const int32_t FLASH_OPTSR_CUR_BOR_LEV_POS          = 2;    /** @brief Brownout level option status bit */
  static const int32_t FLASH_OPTSR_CUR_IWDG1_HW_POS         = 4;    /** @brief IWDG1 control option status bit */
  static const int32_t FLASH_OPTSR_CUR_NRST_STOP_D1_POS     = 6;    /** @brief D1 dstop entry reset option status bit */
  static const int32_t FLASH_OPTSR_CUR_NRST_STBY_D1_POS     = 7;    /** @brief D1 dstandby entry reset option status bit */
  static const int32_t FLASH_OPTSR_CUR_RDP_POS              = 8;    /** @brief Readout protection level option status byte */
  static const int32_t FLASH_OPTSR_CUR_FZ_IWDG_STOP_POS     = 17;   /** @brief IWDG stop mode freeze option status bit */
  static const int32_t FLASH_OPTSR_CUR_FZ_IWDG_SDBY_POS     = 18;   /** @brief IWDG standby mode freeze option status bit */
  static const int32_t FLASH_OPTSR_CUR_ST_RAM_SIZE_POS      = 19;   /** @brief DTCM RAM size option status */
  static const int32_t FLASH_OPTSR_CUR_SECURITY_POS         = 21;   /** @brief Security enable option status bit */
  static const int32_t FLASH_OPTSR_CUR_RSS1_POS             = 26;   /** @brief User option bit 1 */
  static const int32_t FLASH_OPTSR_CUR_PERSO_OK_POS         = 28;   /** @brief Device personalization status bit */
  static const int32_t FLASH_OPTSR_CUR_IO_HSLV_POS          = 29;   /** @brief I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V) */
  static const int32_t FLASH_OPTSR_CUR_OPTCHANGEERR_POS     = 30;   /** @brief Option byte change error flag */
  static const int32_t FLASH_OPTSR_CUR_SWAP_BANK_OPT_POS    = 31;   /** @brief Bank swapping option status bit */
  static const int32_t FLASH_OPTSR_PRG_BOR_LEV_POS          = 2;    /** @brief BOR reset level option configuration bits */
  static const int32_t FLASH_OPTSR_PRG_IWDG1_HW_POS         = 4;    /** @brief IWDG1 option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_NRST_STOP_D1_POS     = 6;    /** @brief Option byte erase after D1 dstop option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_NRST_STBY_D1_POS     = 7;    /** @brief Option byte erase after D1 dstandby option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_RDP_POS              = 8;    /** @brief Readout protection level option configuration byte */
  static const int32_t FLASH_OPTSR_PRG_FZ_IWDG_STOP_POS     = 17;   /** @brief IWDG stop mode freeze option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_FZ_IWDG_SDBY_POS     = 18;   /** @brief IWDG standby mode freeze option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_ST_RAM_SIZE_POS      = 19;   /** @brief DTCM size select option configuration bits */
  static const int32_t FLASH_OPTSR_PRG_SECURITY_POS         = 21;   /** @brief Security option configuration bit */
  static const int32_t FLASH_OPTSR_PRG_IO_HSLV_POS          = 29;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
  static const int32_t FLASH_OPTSR_PRG_SWAP_BANK_OPT_POS    = 31;   /** @brief Bank swapping option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__BOR_LEV_POS         = 2;    /** @brief BOR reset level option configuration bits */
  static const int32_t FLASH_OPTSR_PRG__IWDG1_HW_POS        = 4;    /** @brief IWDG1 option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__NRST_STOP_D1_POS    = 6;    /** @brief Option byte erase after D1 dstop option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__NRST_STBY_D1_POS    = 7;    /** @brief Option byte erase after D1 dstandby option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__RDP_POS             = 8;    /** @brief Readout protection level option configuration byte */
  static const int32_t FLASH_OPTSR_PRG__FZ_IWDG_STOP_POS    = 17;   /** @brief IWDG stop mode freeze option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__FZ_IWDG_SDBY_POS    = 18;   /** @brief IWDG standby mode freeze option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__ST_RAM_SIZE_POS     = 19;   /** @brief DTCM size select option configuration bits */
  static const int32_t FLASH_OPTSR_PRG__SECURITY_POS        = 21;   /** @brief Security option configuration bit */
  static const int32_t FLASH_OPTSR_PRG__IO_HSLV_POS         = 29;   /** @brief I/O high-speed at low-voltage (PRODUCT_BELOW_25V) */
  static const int32_t FLASH_OPTSR_PRG__SWAP_BANK_OPT_POS   = 31;   /** @brief Bank swapping option configuration bit */
  static const int32_t FLASH_OPTCCR__CLR_OPTCHANGEERR_POS   = 30;   /** @brief OPTCHANGEERR reset bit */
  static const int32_t FLASH_OPTCCR_CLR_OPTCHANGEERR_POS    = 30;   /** @brief OPTCHANGEERR reset bit */
  static const int32_t FLASH_PRAR_CURx_PROT_AREA_START1_POS = 0;    /** @brief Bank 1 lowest PCROP protected address */
  static const int32_t FLASH_PRAR_CURx_PROT_AREA_END1_POS   = 16;   /** @brief Bank 1 highest PCROP protected address */
  static const int32_t FLASH_PRAR_CURx_DMEP1_POS            = 31;   /** @brief Bank 1 PCROP protected erase enable option status bit */
  static const int32_t FLASH_PRAR_PRGx_PROT_AREA_START1_POS = 0;    /** @brief Bank 1 lowest PCROP protected address configuration */
  static const int32_t FLASH_PRAR_PRGx_PROT_AREA_END1_POS   = 16;   /** @brief Bank 1 highest PCROP protected address configuration */
  static const int32_t FLASH_PRAR_PRGx_DMEP1_POS            = 31;   /** @brief Bank 1 PCROP protected erase enable option configuration bit */
  static const int32_t FLASH_SCAR_CURx_SEC_AREA_START1_POS  = 0;    /** @brief Bank 1 lowest secure protected address */
  static const int32_t FLASH_SCAR_CURx_SEC_AREA_END1_POS    = 16;   /** @brief Bank 1 highest secure protected address */
  static const int32_t FLASH_SCAR_CURx_DMES1_POS            = 31;   /** @brief Bank 1 secure protected erase enable option status bit */
  static const int32_t FLASH_SCAR_PRGx_SEC_AREA_START1_POS  = 0;    /** @brief Bank 1 lowest secure protected address configuration */
  static const int32_t FLASH_SCAR_PRGx_SEC_AREA_END1_POS    = 16;   /** @brief Bank 1 highest secure protected address configuration */
  static const int32_t FLASH_SCAR_PRGx_DMES1_POS            = 31;   /** @brief Bank 1 secure protected erase enable option configuration bit */
  static const int32_t FLASH_WPSN_CURxR_WRPSN1_POS          = 0;    /** @brief Bank 1 sector write protection option status byte */
  static const int32_t FLASH_WPSN_PRGxR_WRPSN1_POS          = 0;    /** @brief Bank 1 sector write protection configuration byte */
  static const int32_t FLASH_CRCCRx_CRC_SECT_POS            = 0;    /** @brief Bank 1 CRC sector number */
  static const int32_t FLASH_CRCCRx_ALL_BANK_POS            = 7;    /** @brief Bank 1 CRC select bit */
  static const int32_t FLASH_CRCCRx_CRC_BY_SECT_POS         = 8;    /** @brief Bank 1 CRC sector mode select bit */
  static const int32_t FLASH_CRCCRx_ADD_SECT_POS            = 9;    /** @brief Bank 1 CRC sector select bit */
  static const int32_t FLASH_CRCCRx_CLEAN_SECT_POS          = 10;   /** @brief Bank 1 CRC sector list clear bit */
  static const int32_t FLASH_CRCCRx_START_CRC_POS           = 16;   /** @brief Bank 1 CRC start bit */
  static const int32_t FLASH_CRCCRx_CLEAN_CRC_POS           = 17;   /** @brief Bank 1 CRC clear bit */
  static const int32_t FLASH_CRCCRx_CRC_BURST_POS           = 20;   /** @brief Bank 1 CRC burst size */
  static const int32_t FLASH_ECC_FAxR_FAIL_ECC_ADDR1_POS    = 0;    /** @brief Bank 1 ECC error address */

  /**** @subsection Enumerated FLASH Register Field Positions ****/

  static const int32_t FLASH_OPTSR_PRG_RSSx_POS[3] = {
    [1] = 26,   /** @brief User option configuration bit 1 */
    [2] = 27,   /** @brief User option configuration bit 2 */
  };

  static const int32_t FLASH_BOOT_CURR_BOOT_ADDx_POS[2] = {
    [0] = 0,    /** @brief Boot address 0 */
    [1] = 16,   /** @brief Boot address 1 */
  };

  /**********************************************************************************************
   * @section AXI Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated AXI Register Pointers ****/

  static RO_ uint32_t* const AXI_AXI_PERIPH_ID_x_PTR[5] = {
    [0] = (RO_ uint32_t* const)0x51001FE0U,   /** @brief AXI interconnect - peripheral ID0 register */
    [1] = (RO_ uint32_t* const)0x51001FE4U,   /** @brief AXI interconnect - peripheral ID1 register */
    [2] = (RO_ uint32_t* const)0x51001FE8U,   /** @brief AXI interconnect - peripheral ID2 register */
    [3] = (RO_ uint32_t* const)0x51001FECU,   /** @brief AXI interconnect - peripheral ID3 register */
    [4] = (RO_ uint32_t* const)0x51001FD0U,   /** @brief AXI interconnect - peripheral ID4 register */
  };

  static RO_ uint32_t* const AXI_AXI_COMP_ID_x_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x51001FF0U,   /** @brief AXI interconnect - component ID0 register */
    [1] = (RO_ uint32_t* const)0x51001FF4U,   /** @brief AXI interconnect - component ID1 register */
    [2] = (RO_ uint32_t* const)0x51001FF8U,   /** @brief AXI interconnect - component ID2 register */
    [3] = (RO_ uint32_t* const)0x51001FFCU,   /** @brief AXI interconnect - component ID3 register */
  };

  static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_ISS_BM_PTR[8] = {
    [1] = (RW_ uint32_t* const)0x51002008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [2] = (RW_ uint32_t* const)0x51003008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [3] = (RW_ uint32_t* const)0x51004008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [4] = (RW_ uint32_t* const)0x51005008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [5] = (RW_ uint32_t* const)0x51006008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [6] = (RW_ uint32_t* const)0x51007008U,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
    [7] = (RW_ uint32_t* const)0x5100800CU,   /** @brief AXI interconnect - TARG x bus matrix issuing functionality register */
  };

  static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD2_PTR[8] = {
    [1] = (RW_ uint32_t* const)0x51002024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    [2] = (RW_ uint32_t* const)0x51003024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
    [7] = (RW_ uint32_t* const)0x51008024U,   /** @brief AXI interconnect - TARG x bus matrix functionality 2 register */
  };

  static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_LB_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x5100202CU,   /** @brief AXI interconnect - TARG x long burst functionality modification */
    [2] = (RW_ uint32_t* const)0x5100302CU,   /** @brief AXI interconnect - TARG x long burst functionality modification */
  };

  static RW_ uint32_t* const AXI_AXI_TARGx_FN_MOD_PTR[8] = {
    [1] = (RW_ uint32_t* const)0x51002108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
    [2] = (RW_ uint32_t* const)0x51003108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
    [7] = (RW_ uint32_t* const)0x51008108U,   /** @brief AXI interconnect - TARG x long burst functionality modification */
  };

  static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD2_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x51042024U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
    [3] = (RW_ uint32_t* const)0x51044024U,   /** @brief AXI interconnect - INI x functionality modification 2 register */
  };

  static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_AHB_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x51042028U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
    [3] = (RW_ uint32_t* const)0x51044028U,   /** @brief AXI interconnect - INI x AHB functionality modification register */
  };

  static RW_ uint32_t* const AXI_AXI_INIx_READ_QOS_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x51042100U,   /** @brief AXI interconnect - INI x read qos register */
    [2] = (RW_ uint32_t* const)0x51043100U,   /** @brief AXI interconnect - INI x read qos register */
    [3] = (RW_ uint32_t* const)0x51044100U,   /** @brief AXI interconnect - INI x read qos register */
    [4] = (RW_ uint32_t* const)0x51045100U,   /** @brief AXI interconnect - INI x read qos register */
    [5] = (RW_ uint32_t* const)0x51046100U,   /** @brief AXI interconnect - INI x read qos register */
    [6] = (RW_ uint32_t* const)0x51047100U,   /** @brief AXI interconnect - INI x read qos register */
  };

  static RW_ uint32_t* const AXI_AXI_INIx_WRITE_QOS_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x51042104U,   /** @brief AXI interconnect - INI x write qos register */
    [2] = (RW_ uint32_t* const)0x51043104U,   /** @brief AXI interconnect - INI x write qos register */
    [3] = (RW_ uint32_t* const)0x51044104U,   /** @brief AXI interconnect - INI x write qos register */
    [4] = (RW_ uint32_t* const)0x51045104U,   /** @brief AXI interconnect - INI x write qos register */
    [5] = (RW_ uint32_t* const)0x51046104U,   /** @brief AXI interconnect - INI x write qos register */
    [6] = (RW_ uint32_t* const)0x51047104U,   /** @brief AXI interconnect - INI x write qos register */
  };

  static RW_ uint32_t* const AXI_AXI_INIx_FN_MOD_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x51042108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    [2] = (RW_ uint32_t* const)0x51043108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    [3] = (RW_ uint32_t* const)0x51044108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    [4] = (RW_ uint32_t* const)0x51045108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    [5] = (RW_ uint32_t* const)0x51046108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
    [6] = (RW_ uint32_t* const)0x51047108U,   /** @brief AXI interconnect - INI x issuing functionality modification register */
  };

  /**** @subsection AXI Register Field Masks ****/

  static const uint32_t AXI_AXI_PERIPH_ID_x_JEP106CON_MSK                  = 0x0000000FU;   /** @brief JEP106 continuation code */
  static const uint32_t AXI_AXI_PERIPH_ID_x_KCOUNT4_MSK                    = 0x000000F0U;   /** @brief Register file size */
  static const uint32_t AXI_AXI_COMP_ID_x_PREAMBLE_MSK                     = 0x000000FFU;   /** @brief Preamble bits 0 to 7 */
  static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_MSK  = 0x00000001U;   /** @brief READ_ISS_OVERRIDE */
  static const uint32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_MSK = 0x00000002U;   /** @brief Switch matrix write issuing override for target */
  static const uint32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE_MSK             = 0x00000001U;   /** @brief Disable packing of beats to match the output data width */
  static const uint32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB_MSK              = 0x00000001U;   /** @brief Controls burst breaking of long bursts */
  static const uint32_t AXI_AXI_TARGx_FN_MOD_READ_ISS_OVERRIDE_MSK         = 0x00000001U;   /** @brief Override AMIB read issuing capability */
  static const uint32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE_MSK        = 0x00000002U;   /** @brief Override AMIB write issuing capability */
  static const uint32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE_MSK              = 0x00000001U;   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
  static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_RD_INC_OVERRIDE_MSK        = 0x00000001U;   /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
  static const uint32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE_MSK        = 0x00000002U;   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
  static const uint32_t AXI_AXI_INIx_READ_QOS_AR_QOS_MSK                   = 0x0000000FU;   /** @brief Read channel qos setting */
  static const uint32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS_MSK                  = 0x0000000FU;   /** @brief Write channel qos setting */
  static const uint32_t AXI_AXI_INIx_FN_MOD_READ_ISS_OVERRIDE_MSK          = 0x00000001U;   /** @brief Override ASIB read issuing capability */
  static const uint32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE_MSK         = 0x00000002U;   /** @brief Override ASIB write issuing capability */

  /**** @subsection AXI Register Field Positions ****/

  static const int32_t AXI_AXI_PERIPH_ID_x_JEP106CON_POS                  = 0;   /** @brief JEP106 continuation code */
  static const int32_t AXI_AXI_PERIPH_ID_x_KCOUNT4_POS                    = 4;   /** @brief Register file size */
  static const int32_t AXI_AXI_COMP_ID_x_PREAMBLE_POS                     = 0;   /** @brief Preamble bits 0 to 7 */
  static const int32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_READ_ISS_OVERRIDE_POS  = 0;   /** @brief READ_ISS_OVERRIDE */
  static const int32_t AXI_AXI_TARGx_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE_POS = 1;   /** @brief Switch matrix write issuing override for target */
  static const int32_t AXI_AXI_TARGx_FN_MOD2_BYPASS_MERGE_POS             = 0;   /** @brief Disable packing of beats to match the output data width */
  static const int32_t AXI_AXI_TARGx_FN_MOD_LB_FN_MOD_LB_POS              = 0;   /** @brief Controls burst breaking of long bursts */
  static const int32_t AXI_AXI_TARGx_FN_MOD_READ_ISS_OVERRIDE_POS         = 0;   /** @brief Override AMIB read issuing capability */
  static const int32_t AXI_AXI_TARGx_FN_MOD_WRITE_ISS_OVERRIDE_POS        = 1;   /** @brief Override AMIB write issuing capability */
  static const int32_t AXI_AXI_INIx_FN_MOD2_BYPASS_MERGE_POS              = 0;   /** @brief Disables alteration of transactions by the up-sizer unless required by the protocol */
  static const int32_t AXI_AXI_INIx_FN_MOD_AHB_RD_INC_OVERRIDE_POS        = 0;   /** @brief Converts all ahb-lite write transactions to a series of single beat AXI */
  static const int32_t AXI_AXI_INIx_FN_MOD_AHB_WR_INC_OVERRIDE_POS        = 1;   /** @brief Converts all ahb-lite read transactions to a series of single beat AXI */
  static const int32_t AXI_AXI_INIx_READ_QOS_AR_QOS_POS                   = 0;   /** @brief Read channel qos setting */
  static const int32_t AXI_AXI_INIx_WRITE_QOS_AW_QOS_POS                  = 0;   /** @brief Write channel qos setting */
  static const int32_t AXI_AXI_INIx_FN_MOD_READ_ISS_OVERRIDE_POS          = 0;   /** @brief Override ASIB read issuing capability */
  static const int32_t AXI_AXI_INIx_FN_MOD_WRITE_ISS_OVERRIDE_POS         = 1;   /** @brief Override ASIB write issuing capability */

  /**********************************************************************************************
   * @section HASH Register Information
   **********************************************************************************************/

  /**** @subsection HASH Register Pointers ****/

  static RW_ uint32_t* const HASH_CR_PTR  = (RW_ uint32_t* const)0x48021400U;   /** @brief Control register */
  static RW_ uint32_t* const HASH_DIN_PTR = (RW_ uint32_t* const)0x48021404U;   /** @brief Data input register */
  static RW_ uint32_t* const HASH_STR_PTR = (RW_ uint32_t* const)0x48021408U;   /** @brief Start register */
  static RW_ uint32_t* const HASH_IMR_PTR = (RW_ uint32_t* const)0x48021420U;   /** @brief Interrupt enable register */
  static RW_ uint32_t* const HASH_SR_PTR  = (RW_ uint32_t* const)0x48021424U;   /** @brief Status register */

  /**** @subsection Enumerated HASH Register Pointers ****/

  static RO_ uint32_t* const HASH_HRx_PTR[5] = {
    [0] = (RO_ uint32_t* const)0x4802140CU,   /** @brief Digest registers */
    [1] = (RO_ uint32_t* const)0x48021410U,   /** @brief Digest registers */
    [2] = (RO_ uint32_t* const)0x48021414U,   /** @brief Digest registers */
    [3] = (RO_ uint32_t* const)0x48021418U,   /** @brief Digest registers */
    [4] = (RO_ uint32_t* const)0x4802141CU,   /** @brief Digest registers */
  };

  static RW_ uint32_t* const HASH_CSRx_PTR[54] = {
    [0]  = (RW_ uint32_t* const)0x480214F8U,   /** @brief Context swap registers */
    [1]  = (RW_ uint32_t* const)0x480214FCU,   /** @brief Context swap registers */
    [2]  = (RW_ uint32_t* const)0x48021500U,   /** @brief Context swap registers */
    [3]  = (RW_ uint32_t* const)0x48021504U,   /** @brief Context swap registers */
    [4]  = (RW_ uint32_t* const)0x48021508U,   /** @brief Context swap registers */
    [5]  = (RW_ uint32_t* const)0x4802150CU,   /** @brief Context swap registers */
    [6]  = (RW_ uint32_t* const)0x48021510U,   /** @brief Context swap registers */
    [7]  = (RW_ uint32_t* const)0x48021514U,   /** @brief Context swap registers */
    [8]  = (RW_ uint32_t* const)0x48021518U,   /** @brief Context swap registers */
    [9]  = (RW_ uint32_t* const)0x4802151CU,   /** @brief Context swap registers */
    [10] = (RW_ uint32_t* const)0x48021520U,   /** @brief Context swap registers */
    [11] = (RW_ uint32_t* const)0x48021524U,   /** @brief Context swap registers */
    [12] = (RW_ uint32_t* const)0x48021528U,   /** @brief Context swap registers */
    [13] = (RW_ uint32_t* const)0x4802152CU,   /** @brief Context swap registers */
    [14] = (RW_ uint32_t* const)0x48021530U,   /** @brief Context swap registers */
    [15] = (RW_ uint32_t* const)0x48021534U,   /** @brief Context swap registers */
    [16] = (RW_ uint32_t* const)0x48021538U,   /** @brief Context swap registers */
    [17] = (RW_ uint32_t* const)0x4802153CU,   /** @brief Context swap registers */
    [18] = (RW_ uint32_t* const)0x48021540U,   /** @brief Context swap registers */
    [19] = (RW_ uint32_t* const)0x48021544U,   /** @brief Context swap registers */
    [20] = (RW_ uint32_t* const)0x48021548U,   /** @brief Context swap registers */
    [21] = (RW_ uint32_t* const)0x4802154CU,   /** @brief Context swap registers */
    [22] = (RW_ uint32_t* const)0x48021550U,   /** @brief Context swap registers */
    [23] = (RW_ uint32_t* const)0x48021554U,   /** @brief Context swap registers */
    [24] = (RW_ uint32_t* const)0x48021558U,   /** @brief Context swap registers */
    [25] = (RW_ uint32_t* const)0x4802155CU,   /** @brief Context swap registers */
    [26] = (RW_ uint32_t* const)0x48021560U,   /** @brief Context swap registers */
    [27] = (RW_ uint32_t* const)0x48021564U,   /** @brief Context swap registers */
    [28] = (RW_ uint32_t* const)0x48021568U,   /** @brief Context swap registers */
    [29] = (RW_ uint32_t* const)0x4802156CU,   /** @brief Context swap registers */
    [30] = (RW_ uint32_t* const)0x48021570U,   /** @brief Context swap registers */
    [31] = (RW_ uint32_t* const)0x48021574U,   /** @brief Context swap registers */
    [32] = (RW_ uint32_t* const)0x48021578U,   /** @brief Context swap registers */
    [33] = (RW_ uint32_t* const)0x4802157CU,   /** @brief Context swap registers */
    [34] = (RW_ uint32_t* const)0x48021580U,   /** @brief Context swap registers */
    [35] = (RW_ uint32_t* const)0x48021584U,   /** @brief Context swap registers */
    [36] = (RW_ uint32_t* const)0x48021588U,   /** @brief Context swap registers */
    [37] = (RW_ uint32_t* const)0x4802158CU,   /** @brief Context swap registers */
    [38] = (RW_ uint32_t* const)0x48021590U,   /** @brief Context swap registers */
    [39] = (RW_ uint32_t* const)0x48021594U,   /** @brief Context swap registers */
    [40] = (RW_ uint32_t* const)0x48021598U,   /** @brief Context swap registers */
    [41] = (RW_ uint32_t* const)0x4802159CU,   /** @brief Context swap registers */
    [42] = (RW_ uint32_t* const)0x480215A0U,   /** @brief Context swap registers */
    [43] = (RW_ uint32_t* const)0x480215A4U,   /** @brief Context swap registers */
    [44] = (RW_ uint32_t* const)0x480215A8U,   /** @brief Context swap registers */
    [45] = (RW_ uint32_t* const)0x480215ACU,   /** @brief Context swap registers */
    [46] = (RW_ uint32_t* const)0x480215B0U,   /** @brief Context swap registers */
    [47] = (RW_ uint32_t* const)0x480215B4U,   /** @brief Context swap registers */
    [48] = (RW_ uint32_t* const)0x480215B8U,   /** @brief Context swap registers */
    [49] = (RW_ uint32_t* const)0x480215BCU,   /** @brief Context swap registers */
    [50] = (RW_ uint32_t* const)0x480215C0U,   /** @brief Context swap registers */
    [51] = (RW_ uint32_t* const)0x480215C4U,   /** @brief Context swap registers */
    [52] = (RW_ uint32_t* const)0x480215C8U,   /** @brief Context swap registers */
    [53] = (RW_ uint32_t* const)0x480215CCU,   /** @brief Context swap registers */
  };

  static RO_ uint32_t* const HASH_HASH_HRx_PTR[8] = {
    [0] = (RO_ uint32_t* const)0x48021710U,   /** @brief HASH digest register */
    [1] = (RO_ uint32_t* const)0x48021714U,   /** @brief Read-only */
    [2] = (RO_ uint32_t* const)0x48021718U,   /** @brief Read-only */
    [3] = (RO_ uint32_t* const)0x4802171CU,   /** @brief Read-only */
    [4] = (RO_ uint32_t* const)0x48021720U,   /** @brief Read-only */
    [5] = (RO_ uint32_t* const)0x48021724U,   /** @brief Read-only */
    [6] = (RO_ uint32_t* const)0x48021728U,   /** @brief Read-only */
    [7] = (RO_ uint32_t* const)0x4802172CU,   /** @brief Read-only */
  };

  /**** @subsection HASH Register Field Masks ****/

  static const uint32_t HASH_CR_INIT_MSK     = 0x00000004U;   /** @brief Initialize message digest calculation */
  static const uint32_t HASH_CR_DMAE_MSK     = 0x00000008U;   /** @brief DMA enable */
  static const uint32_t HASH_CR_DATATYPE_MSK = 0x00000030U;   /** @brief Data type selection */
  static const uint32_t HASH_CR_MODE_MSK     = 0x00000040U;   /** @brief Mode selection */
  static const uint32_t HASH_CR_NBW_MSK      = 0x00000F00U;   /** @brief Number of words already pushed */
  static const uint32_t HASH_CR_DINNE_MSK    = 0x00001000U;   /** @brief DIN not empty */
  static const uint32_t HASH_CR_MDMAT_MSK    = 0x00002000U;   /** @brief Multiple DMA transfers */
  static const uint32_t HASH_CR_LKEY_MSK     = 0x00010000U;   /** @brief Long key selection */
  static const uint32_t HASH_STR_DCAL_MSK    = 0x00000100U;   /** @brief Digest calculation */
  static const uint32_t HASH_STR_NBLW_MSK    = 0x0000001FU;   /** @brief Number of valid bits in the last word of the message */
  static const uint32_t HASH_IMR_DCIE_MSK    = 0x00000002U;   /** @brief Digest calculation completion interrupt enable */
  static const uint32_t HASH_IMR_DINIE_MSK   = 0x00000001U;   /** @brief Data input interrupt enable */
  static const uint32_t HASH_SR_BUSY_MSK     = 0x00000008U;   /** @brief Busy bit */
  static const uint32_t HASH_SR_DMAS_MSK     = 0x00000004U;   /** @brief DMA status */
  static const uint32_t HASH_SR_DCIS_MSK     = 0x00000002U;   /** @brief Digest calculation completion interrupt status */
  static const uint32_t HASH_SR_DINIS_MSK    = 0x00000001U;   /** @brief Data input interrupt status */

  /**** @subsection Enumerated HASH Register Field Masks ****/

  static const uint32_t HASH_CR_ALGOx_MSK[2] = {
    [0] = 0x00000080U,   /** @brief Algorithm selection */
    [1] = 0x00040000U,   /** @brief ALGO */
  };

  /**** @subsection HASH Register Field Positions ****/

  static const int32_t HASH_CR_INIT_POS     = 2;    /** @brief Initialize message digest calculation */
  static const int32_t HASH_CR_DMAE_POS     = 3;    /** @brief DMA enable */
  static const int32_t HASH_CR_DATATYPE_POS = 4;    /** @brief Data type selection */
  static const int32_t HASH_CR_MODE_POS     = 6;    /** @brief Mode selection */
  static const int32_t HASH_CR_NBW_POS      = 8;    /** @brief Number of words already pushed */
  static const int32_t HASH_CR_DINNE_POS    = 12;   /** @brief DIN not empty */
  static const int32_t HASH_CR_MDMAT_POS    = 13;   /** @brief Multiple DMA transfers */
  static const int32_t HASH_CR_LKEY_POS     = 16;   /** @brief Long key selection */
  static const int32_t HASH_STR_DCAL_POS    = 8;    /** @brief Digest calculation */
  static const int32_t HASH_STR_NBLW_POS    = 0;    /** @brief Number of valid bits in the last word of the message */
  static const int32_t HASH_IMR_DCIE_POS    = 1;    /** @brief Digest calculation completion interrupt enable */
  static const int32_t HASH_IMR_DINIE_POS   = 0;    /** @brief Data input interrupt enable */
  static const int32_t HASH_SR_BUSY_POS     = 3;    /** @brief Busy bit */
  static const int32_t HASH_SR_DMAS_POS     = 2;    /** @brief DMA status */
  static const int32_t HASH_SR_DCIS_POS     = 1;    /** @brief Digest calculation completion interrupt status */
  static const int32_t HASH_SR_DINIS_POS    = 0;    /** @brief Data input interrupt status */

  /**** @subsection Enumerated HASH Register Field Positions ****/

  static const int32_t HASH_CR_ALGOx_POS[2] = {
    [0] = 7,    /** @brief Algorithm selection */
    [1] = 18,   /** @brief ALGO */
  };

  /**********************************************************************************************
   * @section CRYP Register Information
   **********************************************************************************************/

  /**** @subsection CRYP Register Pointers ****/

  static RW_ uint32_t* const CRYP_CR_PTR    = (RW_ uint32_t* const)0x48021000U;   /** @brief Control register */
  static RO_ uint32_t* const CRYP_SR_PTR    = (RO_ uint32_t* const)0x48021004U;   /** @brief Status register */
  static RW_ uint32_t* const CRYP_DIN_PTR   = (RW_ uint32_t* const)0x48021008U;   /** @brief Data input register */
  static RO_ uint32_t* const CRYP_DOUT_PTR  = (RO_ uint32_t* const)0x4802100CU;   /** @brief Data output register */
  static RW_ uint32_t* const CRYP_DMACR_PTR = (RW_ uint32_t* const)0x48021010U;   /** @brief DMA control register */
  static RW_ uint32_t* const CRYP_IMSCR_PTR = (RW_ uint32_t* const)0x48021014U;   /** @brief Interrupt mask set/clear register */
  static RO_ uint32_t* const CRYP_RISR_PTR  = (RO_ uint32_t* const)0x48021018U;   /** @brief Raw interrupt status register */
  static RO_ uint32_t* const CRYP_MISR_PTR  = (RO_ uint32_t* const)0x4802101CU;   /** @brief Masked interrupt status register */

  /**** @subsection Enumerated CRYP Register Pointers ****/

  static WO_ uint32_t* const CRYP_KxLR_PTR[4] = {
    [0] = (WO_ uint32_t* const)0x48021020U,   /** @brief Key registers */
    [1] = (WO_ uint32_t* const)0x48021028U,   /** @brief Key registers */
    [2] = (WO_ uint32_t* const)0x48021030U,   /** @brief Key registers */
    [3] = (WO_ uint32_t* const)0x48021038U,   /** @brief Key registers */
  };

  static WO_ uint32_t* const CRYP_KxRR_PTR[4] = {
    [0] = (WO_ uint32_t* const)0x48021024U,   /** @brief Key registers */
    [1] = (WO_ uint32_t* const)0x4802102CU,   /** @brief Key registers */
    [2] = (WO_ uint32_t* const)0x48021034U,   /** @brief Key registers */
    [3] = (WO_ uint32_t* const)0x4802103CU,   /** @brief Key registers */
  };

  static RW_ uint32_t* const CRYP_IVxLR_PTR[2] = {
    [0] = (RW_ uint32_t* const)0x48021040U,   /** @brief Initialization vector registers */
    [1] = (RW_ uint32_t* const)0x48021048U,   /** @brief Initialization vector registers */
  };

  static RW_ uint32_t* const CRYP_IVxRR_PTR[2] = {
    [0] = (RW_ uint32_t* const)0x48021044U,   /** @brief Initialization vector registers */
    [1] = (RW_ uint32_t* const)0x4802104CU,   /** @brief Initialization vector registers */
  };

  static RW_ uint32_t* const CRYP_CSGCMCCMxR_PTR[8] = {
    [0] = (RW_ uint32_t* const)0x48021050U,   /** @brief Context swap register */
    [1] = (RW_ uint32_t* const)0x48021054U,   /** @brief Context swap register */
    [2] = (RW_ uint32_t* const)0x48021058U,   /** @brief Context swap register */
    [3] = (RW_ uint32_t* const)0x4802105CU,   /** @brief Context swap register */
    [4] = (RW_ uint32_t* const)0x48021060U,   /** @brief Context swap register */
    [5] = (RW_ uint32_t* const)0x48021064U,   /** @brief Context swap register */
    [6] = (RW_ uint32_t* const)0x48021068U,   /** @brief Context swap register */
    [7] = (RW_ uint32_t* const)0x4802106CU,   /** @brief Context swap register */
  };

  static RW_ uint32_t* const CRYP_CSGCMxR_PTR[8] = {
    [0] = (RW_ uint32_t* const)0x48021070U,   /** @brief Context swap register */
    [1] = (RW_ uint32_t* const)0x48021074U,   /** @brief Context swap register */
    [2] = (RW_ uint32_t* const)0x48021078U,   /** @brief Context swap register */
    [3] = (RW_ uint32_t* const)0x4802107CU,   /** @brief Context swap register */
    [4] = (RW_ uint32_t* const)0x48021080U,   /** @brief Context swap register */
    [5] = (RW_ uint32_t* const)0x48021084U,   /** @brief Context swap register */
    [6] = (RW_ uint32_t* const)0x48021088U,   /** @brief Context swap register */
    [7] = (RW_ uint32_t* const)0x4802108CU,   /** @brief Context swap register */
  };

  /**** @subsection CRYP Register Field Masks ****/

  static const uint32_t CRYP_CR_ALGODIR_MSK   = 0x00000004U;   /** @brief Algorithm direction */
  static const uint32_t CRYP_CR_DATATYPE_MSK  = 0x000000C0U;   /** @brief Data type selection */
  static const uint32_t CRYP_CR_KEYSIZE_MSK   = 0x00000300U;   /** @brief Key size selection (AES mode only) */
  static const uint32_t CRYP_CR_FFLUSH_MSK    = 0x00004000U;   /** @brief FIFO flush */
  static const uint32_t CRYP_CR_CRYPEN_MSK    = 0x00008000U;   /** @brief Cryptographic processor enable */
  static const uint32_t CRYP_CR_GCM_CCMPH_MSK = 0x00030000U;   /** @brief GCM_CCMPH */
  static const uint32_t CRYP_SR_BUSY_MSK      = 0x00000010U;   /** @brief Busy bit */
  static const uint32_t CRYP_SR_OFFU_MSK      = 0x00000008U;   /** @brief Output FIFO full */
  static const uint32_t CRYP_SR_OFNE_MSK      = 0x00000004U;   /** @brief Output FIFO not empty */
  static const uint32_t CRYP_SR_IFNF_MSK      = 0x00000002U;   /** @brief Input FIFO not full */
  static const uint32_t CRYP_SR_IFEM_MSK      = 0x00000001U;   /** @brief Input FIFO empty */
  static const uint32_t CRYP_DMACR_DOEN_MSK   = 0x00000002U;   /** @brief DMA output enable */
  static const uint32_t CRYP_DMACR_DIEN_MSK   = 0x00000001U;   /** @brief DMA input enable */
  static const uint32_t CRYP_IMSCR_OUTIM_MSK  = 0x00000002U;   /** @brief Output FIFO service interrupt mask */
  static const uint32_t CRYP_IMSCR_INIM_MSK   = 0x00000001U;   /** @brief Input FIFO service interrupt mask */
  static const uint32_t CRYP_RISR_OUTRIS_MSK  = 0x00000002U;   /** @brief Output FIFO service raw interrupt status */
  static const uint32_t CRYP_RISR_INRIS_MSK   = 0x00000001U;   /** @brief Input FIFO service raw interrupt status */
  static const uint32_t CRYP_MISR_OUTMIS_MSK  = 0x00000002U;   /** @brief Output FIFO service masked interrupt status */
  static const uint32_t CRYP_MISR_INMIS_MSK   = 0x00000001U;   /** @brief Input FIFO service masked interrupt status */

  /**** @subsection Enumerated CRYP Register Field Masks ****/

  static const uint32_t CRYP_CR_ALGOMODEx_MSK[4] = {
    [0] = 0x00000038U,   /** @brief Algorithm mode */
    [3] = 0x00080000U,   /** @brief ALGOMODE */
  };

  static const uint32_t CRYP_KxLR_B2x_MSK[56] = {
    [24] = 0x00000001U,   /** @brief B224 */
    [30] = 0x00000040U,   /** @brief B230 */
    [31] = 0x00000080U,   /** @brief B231 */
    [32] = 0x00000100U,   /** @brief B232 */
    [33] = 0x00000200U,   /** @brief B233 */
    [34] = 0x00000400U,   /** @brief B234 */
    [35] = 0x00000800U,   /** @brief B235 */
    [36] = 0x00001000U,   /** @brief B236 */
    [37] = 0x00002000U,   /** @brief B237 */
    [38] = 0x00004000U,   /** @brief B238 */
    [39] = 0x00008000U,   /** @brief B239 */
    [40] = 0x00010000U,   /** @brief B240 */
    [41] = 0x00020000U,   /** @brief B241 */
    [42] = 0x00040000U,   /** @brief B242 */
    [43] = 0x00080000U,   /** @brief B243 */
    [44] = 0x00100000U,   /** @brief B244 */
    [45] = 0x00200000U,   /** @brief B245 */
    [46] = 0x00400000U,   /** @brief B246 */
    [47] = 0x00800000U,   /** @brief B247 */
    [48] = 0x01000000U,   /** @brief B248 */
    [49] = 0x02000000U,   /** @brief B249 */
    [50] = 0x04000000U,   /** @brief B250 */
    [51] = 0x08000000U,   /** @brief B251 */
    [52] = 0x10000000U,   /** @brief B252 */
    [53] = 0x20000000U,   /** @brief B253 */
    [54] = 0x40000000U,   /** @brief B254 */
    [55] = 0x80000000U,   /** @brief B255 */
  };

  static const uint32_t CRYP_KxLR_B22x_MSK[10] = {
    [5]  = 0x00000002U,   /** @brief B225 */
    [6]  = 0x00000004U,   /** @brief B226 */
    [7]  = 0x00000008U,   /** @brief B227 */
    [8]  = 0x00000010U,   /** @brief B228 */
    [9]  = 0x00000020U,   /** @brief B229 */
  };

  static const uint32_t CRYP_KxRR_B19x_MSK[10] = {
    [2]  = 0x00000001U,   /** @brief B192 */
    [3]  = 0x00000002U,   /** @brief B193 */
    [4]  = 0x00000004U,   /** @brief B194 */
    [5]  = 0x00000008U,   /** @brief B195 */
    [6]  = 0x00000010U,   /** @brief B196 */
    [7]  = 0x00000020U,   /** @brief B197 */
    [8]  = 0x00000040U,   /** @brief B198 */
    [9]  = 0x00000080U,   /** @brief B199 */
  };

  static const uint32_t CRYP_KxRR_B20x_MSK[10] = {
    [1]  = 0x00000200U,   /** @brief B201 */
    [2]  = 0x00000400U,   /** @brief B202 */
    [3]  = 0x00000800U,   /** @brief B203 */
    [4]  = 0x00001000U,   /** @brief B204 */
    [5]  = 0x00002000U,   /** @brief B205 */
    [6]  = 0x00004000U,   /** @brief B206 */
    [7]  = 0x00008000U,   /** @brief B207 */
    [8]  = 0x00010000U,   /** @brief B208 */
    [9]  = 0x00020000U,   /** @brief B209 */
  };

  static const uint32_t CRYP_IVxLR_IVx_MSK[32] = {
    [0]  = 0x80000000U,   /** @brief IV0 */
    [1]  = 0x40000000U,   /** @brief IV1 */
    [2]  = 0x20000000U,   /** @brief IV2 */
    [3]  = 0x10000000U,   /** @brief IV3 */
    [4]  = 0x08000000U,   /** @brief IV4 */
    [5]  = 0x04000000U,   /** @brief IV5 */
    [6]  = 0x02000000U,   /** @brief IV6 */
    [7]  = 0x01000000U,   /** @brief IV7 */
    [8]  = 0x00800000U,   /** @brief IV8 */
    [9]  = 0x00400000U,   /** @brief IV9 */
    [10] = 0x00200000U,   /** @brief IV10 */
    [11] = 0x00100000U,   /** @brief IV11 */
    [12] = 0x00080000U,   /** @brief IV12 */
    [13] = 0x00040000U,   /** @brief IV13 */
    [14] = 0x00020000U,   /** @brief IV14 */
    [15] = 0x00010000U,   /** @brief IV15 */
    [16] = 0x00008000U,   /** @brief IV16 */
    [17] = 0x00004000U,   /** @brief IV17 */
    [18] = 0x00002000U,   /** @brief IV18 */
    [19] = 0x00001000U,   /** @brief IV19 */
    [20] = 0x00000800U,   /** @brief IV20 */
    [21] = 0x00000400U,   /** @brief IV21 */
    [22] = 0x00000200U,   /** @brief IV22 */
    [23] = 0x00000100U,   /** @brief IV23 */
    [24] = 0x00000080U,   /** @brief IV24 */
    [25] = 0x00000040U,   /** @brief IV25 */
    [26] = 0x00000020U,   /** @brief IV26 */
    [27] = 0x00000010U,   /** @brief IV27 */
    [28] = 0x00000008U,   /** @brief IV28 */
    [29] = 0x00000004U,   /** @brief IV29 */
    [31] = 0x00000001U,   /** @brief IV31 */
  };

  static const uint32_t CRYP_IVxLR_IV3x_MSK[2] = {
    [0] = 0x00000002U,   /** @brief IV30 */
  };

  static const uint32_t CRYP_IVxRR_IV6x_MSK[4] = {
    [0] = 0x00000008U,   /** @brief IV60 */
    [1] = 0x00000004U,   /** @brief IV61 */
    [2] = 0x00000002U,   /** @brief IV62 */
  };

  /**** @subsection CRYP Register Field Positions ****/

  static const int32_t CRYP_CR_ALGODIR_POS   = 2;    /** @brief Algorithm direction */
  static const int32_t CRYP_CR_DATATYPE_POS  = 6;    /** @brief Data type selection */
  static const int32_t CRYP_CR_KEYSIZE_POS   = 8;    /** @brief Key size selection (AES mode only) */
  static const int32_t CRYP_CR_FFLUSH_POS    = 14;   /** @brief FIFO flush */
  static const int32_t CRYP_CR_CRYPEN_POS    = 15;   /** @brief Cryptographic processor enable */
  static const int32_t CRYP_CR_GCM_CCMPH_POS = 16;   /** @brief GCM_CCMPH */
  static const int32_t CRYP_SR_BUSY_POS      = 4;    /** @brief Busy bit */
  static const int32_t CRYP_SR_OFFU_POS      = 3;    /** @brief Output FIFO full */
  static const int32_t CRYP_SR_OFNE_POS      = 2;    /** @brief Output FIFO not empty */
  static const int32_t CRYP_SR_IFNF_POS      = 1;    /** @brief Input FIFO not full */
  static const int32_t CRYP_SR_IFEM_POS      = 0;    /** @brief Input FIFO empty */
  static const int32_t CRYP_DMACR_DOEN_POS   = 1;    /** @brief DMA output enable */
  static const int32_t CRYP_DMACR_DIEN_POS   = 0;    /** @brief DMA input enable */
  static const int32_t CRYP_IMSCR_OUTIM_POS  = 1;    /** @brief Output FIFO service interrupt mask */
  static const int32_t CRYP_IMSCR_INIM_POS   = 0;    /** @brief Input FIFO service interrupt mask */
  static const int32_t CRYP_RISR_OUTRIS_POS  = 1;    /** @brief Output FIFO service raw interrupt status */
  static const int32_t CRYP_RISR_INRIS_POS   = 0;    /** @brief Input FIFO service raw interrupt status */
  static const int32_t CRYP_MISR_OUTMIS_POS  = 1;    /** @brief Output FIFO service masked interrupt status */
  static const int32_t CRYP_MISR_INMIS_POS   = 0;    /** @brief Input FIFO service masked interrupt status */

  /**** @subsection Enumerated CRYP Register Field Positions ****/

  static const int32_t CRYP_CR_ALGOMODEx_POS[4] = {
    [0] = 3,    /** @brief Algorithm mode */
    [3] = 19,   /** @brief ALGOMODE */
  };

  static const int32_t CRYP_KxLR_B2x_POS[56] = {
    [24] = 0,    /** @brief B224 */
    [30] = 6,    /** @brief B230 */
    [31] = 7,    /** @brief B231 */
    [32] = 8,    /** @brief B232 */
    [33] = 9,    /** @brief B233 */
    [34] = 10,   /** @brief B234 */
    [35] = 11,   /** @brief B235 */
    [36] = 12,   /** @brief B236 */
    [37] = 13,   /** @brief B237 */
    [38] = 14,   /** @brief B238 */
    [39] = 15,   /** @brief B239 */
    [40] = 16,   /** @brief B240 */
    [41] = 17,   /** @brief B241 */
    [42] = 18,   /** @brief B242 */
    [43] = 19,   /** @brief B243 */
    [44] = 20,   /** @brief B244 */
    [45] = 21,   /** @brief B245 */
    [46] = 22,   /** @brief B246 */
    [47] = 23,   /** @brief B247 */
    [48] = 24,   /** @brief B248 */
    [49] = 25,   /** @brief B249 */
    [50] = 26,   /** @brief B250 */
    [51] = 27,   /** @brief B251 */
    [52] = 28,   /** @brief B252 */
    [53] = 29,   /** @brief B253 */
    [54] = 30,   /** @brief B254 */
    [55] = 31,   /** @brief B255 */
  };

  static const int32_t CRYP_KxLR_B22x_POS[10] = {
    [5]  = 1,   /** @brief B225 */
    [6]  = 2,   /** @brief B226 */
    [7]  = 3,   /** @brief B227 */
    [8]  = 4,   /** @brief B228 */
    [9]  = 5,   /** @brief B229 */
  };

  static const int32_t CRYP_KxRR_B19x_POS[10] = {
    [2]  = 0,   /** @brief B192 */
    [3]  = 1,   /** @brief B193 */
    [4]  = 2,   /** @brief B194 */
    [5]  = 3,   /** @brief B195 */
    [6]  = 4,   /** @brief B196 */
    [7]  = 5,   /** @brief B197 */
    [8]  = 6,   /** @brief B198 */
    [9]  = 7,   /** @brief B199 */
  };

  static const int32_t CRYP_KxRR_B20x_POS[10] = {
    [1]  = 9,    /** @brief B201 */
    [2]  = 10,   /** @brief B202 */
    [3]  = 11,   /** @brief B203 */
    [4]  = 12,   /** @brief B204 */
    [5]  = 13,   /** @brief B205 */
    [6]  = 14,   /** @brief B206 */
    [7]  = 15,   /** @brief B207 */
    [8]  = 16,   /** @brief B208 */
    [9]  = 17,   /** @brief B209 */
  };

  static const int32_t CRYP_IVxLR_IVx_POS[32] = {
    [0]  = 31,   /** @brief IV0 */
    [1]  = 30,   /** @brief IV1 */
    [2]  = 29,   /** @brief IV2 */
    [3]  = 28,   /** @brief IV3 */
    [4]  = 27,   /** @brief IV4 */
    [5]  = 26,   /** @brief IV5 */
    [6]  = 25,   /** @brief IV6 */
    [7]  = 24,   /** @brief IV7 */
    [8]  = 23,   /** @brief IV8 */
    [9]  = 22,   /** @brief IV9 */
    [10] = 21,   /** @brief IV10 */
    [11] = 20,   /** @brief IV11 */
    [12] = 19,   /** @brief IV12 */
    [13] = 18,   /** @brief IV13 */
    [14] = 17,   /** @brief IV14 */
    [15] = 16,   /** @brief IV15 */
    [16] = 15,   /** @brief IV16 */
    [17] = 14,   /** @brief IV17 */
    [18] = 13,   /** @brief IV18 */
    [19] = 12,   /** @brief IV19 */
    [20] = 11,   /** @brief IV20 */
    [21] = 10,   /** @brief IV21 */
    [22] = 9,    /** @brief IV22 */
    [23] = 8,    /** @brief IV23 */
    [24] = 7,    /** @brief IV24 */
    [25] = 6,    /** @brief IV25 */
    [26] = 5,    /** @brief IV26 */
    [27] = 4,    /** @brief IV27 */
    [28] = 3,    /** @brief IV28 */
    [29] = 2,    /** @brief IV29 */
    [31] = 0,    /** @brief IV31 */
  };

  static const int32_t CRYP_IVxLR_IV3x_POS[2] = {
    [0] = 1,   /** @brief IV30 */
  };

  static const int32_t CRYP_IVxRR_IV6x_POS[4] = {
    [0] = 3,   /** @brief IV60 */
    [1] = 2,   /** @brief IV61 */
    [2] = 1,   /** @brief IV62 */
  };

  /**********************************************************************************************
   * @section DCMI Register Information
   **********************************************************************************************/

  /**** @subsection DCMI Register Pointers ****/

  static RW_ uint32_t* const DCMI_CR_PTR     = (RW_ uint32_t* const)0x48020000U;   /** @brief Control register 1 */
  static RO_ uint32_t* const DCMI_SR_PTR     = (RO_ uint32_t* const)0x48020004U;   /** @brief Status register */
  static RO_ uint32_t* const DCMI_RIS_PTR    = (RO_ uint32_t* const)0x48020008U;   /** @brief Raw interrupt status register */
  static RW_ uint32_t* const DCMI_IER_PTR    = (RW_ uint32_t* const)0x4802000CU;   /** @brief Interrupt enable register */
  static RO_ uint32_t* const DCMI_MIS_PTR    = (RO_ uint32_t* const)0x48020010U;   /** @brief Masked interrupt status register */
  static WO_ uint32_t* const DCMI_ICR_PTR    = (WO_ uint32_t* const)0x48020014U;   /** @brief Interrupt clear register */
  static RW_ uint32_t* const DCMI_ESCR_PTR   = (RW_ uint32_t* const)0x48020018U;   /** @brief Embedded synchronization code register */
  static RW_ uint32_t* const DCMI_ESUR_PTR   = (RW_ uint32_t* const)0x4802001CU;   /** @brief Embedded synchronization unmask register */
  static RW_ uint32_t* const DCMI_CWSTRT_PTR = (RW_ uint32_t* const)0x48020020U;   /** @brief Crop window start */
  static RW_ uint32_t* const DCMI_CWSIZE_PTR = (RW_ uint32_t* const)0x48020024U;   /** @brief Crop window size */
  static RO_ uint32_t* const DCMI_DR_PTR     = (RO_ uint32_t* const)0x48020028U;   /** @brief Data register */

  /**** @subsection DCMI Register Field Masks ****/

  static const uint32_t DCMI_CR_OELS_MSK        = 0x00100000U;   /** @brief Odd/Even line select (line select start) */
  static const uint32_t DCMI_CR_LSM_MSK         = 0x00080000U;   /** @brief Line select mode */
  static const uint32_t DCMI_CR_OEBS_MSK        = 0x00040000U;   /** @brief Odd/Even byte select (byte select start) */
  static const uint32_t DCMI_CR_BSM_MSK         = 0x00030000U;   /** @brief Byte select mode */
  static const uint32_t DCMI_CR_ENABLE_MSK      = 0x00004000U;   /** @brief DCMI enable */
  static const uint32_t DCMI_CR_EDM_MSK         = 0x00000C00U;   /** @brief Extended data mode */
  static const uint32_t DCMI_CR_FCRC_MSK        = 0x00000300U;   /** @brief Frame capture rate control */
  static const uint32_t DCMI_CR_VSPOL_MSK       = 0x00000080U;   /** @brief Vertical synchronization polarity */
  static const uint32_t DCMI_CR_HSPOL_MSK       = 0x00000040U;   /** @brief Horizontal synchronization polarity */
  static const uint32_t DCMI_CR_PCKPOL_MSK      = 0x00000020U;   /** @brief Pixel clock polarity */
  static const uint32_t DCMI_CR_ESS_MSK         = 0x00000010U;   /** @brief Embedded synchronization select */
  static const uint32_t DCMI_CR_JPEG_MSK        = 0x00000008U;   /** @brief JPEG format */
  static const uint32_t DCMI_CR_CROP_MSK        = 0x00000004U;   /** @brief Crop feature */
  static const uint32_t DCMI_CR_CM_MSK          = 0x00000002U;   /** @brief Capture mode */
  static const uint32_t DCMI_CR_CAPTURE_MSK     = 0x00000001U;   /** @brief Capture enable */
  static const uint32_t DCMI_SR_FNE_MSK         = 0x00000004U;   /** @brief FIFO not empty */
  static const uint32_t DCMI_SR_VSYNC_MSK       = 0x00000002U;   /** @brief VSYNC */
  static const uint32_t DCMI_SR_HSYNC_MSK       = 0x00000001U;   /** @brief HSYNC */
  static const uint32_t DCMI_RIS_LINE_RIS_MSK   = 0x00000010U;   /** @brief Line raw interrupt status */
  static const uint32_t DCMI_RIS_VSYNC_RIS_MSK  = 0x00000008U;   /** @brief VSYNC raw interrupt status */
  static const uint32_t DCMI_RIS_ERR_RIS_MSK    = 0x00000004U;   /** @brief Synchronization error raw interrupt status */
  static const uint32_t DCMI_RIS_OVR_RIS_MSK    = 0x00000002U;   /** @brief Overrun raw interrupt status */
  static const uint32_t DCMI_RIS_FRAME_RIS_MSK  = 0x00000001U;   /** @brief Capture complete raw interrupt status */
  static const uint32_t DCMI_IER_LINE_IE_MSK    = 0x00000010U;   /** @brief Line interrupt enable */
  static const uint32_t DCMI_IER_VSYNC_IE_MSK   = 0x00000008U;   /** @brief VSYNC interrupt enable */
  static const uint32_t DCMI_IER_ERR_IE_MSK     = 0x00000004U;   /** @brief Synchronization error interrupt enable */
  static const uint32_t DCMI_IER_OVR_IE_MSK     = 0x00000002U;   /** @brief Overrun interrupt enable */
  static const uint32_t DCMI_IER_FRAME_IE_MSK   = 0x00000001U;   /** @brief Capture complete interrupt enable */
  static const uint32_t DCMI_MIS_LINE_MIS_MSK   = 0x00000010U;   /** @brief Line masked interrupt status */
  static const uint32_t DCMI_MIS_VSYNC_MIS_MSK  = 0x00000008U;   /** @brief VSYNC masked interrupt status */
  static const uint32_t DCMI_MIS_ERR_MIS_MSK    = 0x00000004U;   /** @brief Synchronization error masked interrupt status */
  static const uint32_t DCMI_MIS_OVR_MIS_MSK    = 0x00000002U;   /** @brief Overrun masked interrupt status */
  static const uint32_t DCMI_MIS_FRAME_MIS_MSK  = 0x00000001U;   /** @brief Capture complete masked interrupt status */
  static const uint32_t DCMI_ICR_LINE_ISC_MSK   = 0x00000010U;   /** @brief Line interrupt status clear */
  static const uint32_t DCMI_ICR_VSYNC_ISC_MSK  = 0x00000008U;   /** @brief Vertical synch interrupt status clear */
  static const uint32_t DCMI_ICR_ERR_ISC_MSK    = 0x00000004U;   /** @brief Synchronization error interrupt status clear */
  static const uint32_t DCMI_ICR_OVR_ISC_MSK    = 0x00000002U;   /** @brief Overrun interrupt status clear */
  static const uint32_t DCMI_ICR_FRAME_ISC_MSK  = 0x00000001U;   /** @brief Capture complete interrupt status clear */
  static const uint32_t DCMI_ESCR_FEC_MSK       = 0xFF000000U;   /** @brief Frame end delimiter code */
  static const uint32_t DCMI_ESCR_LEC_MSK       = 0x00FF0000U;   /** @brief Line end delimiter code */
  static const uint32_t DCMI_ESCR_LSC_MSK       = 0x0000FF00U;   /** @brief Line start delimiter code */
  static const uint32_t DCMI_ESCR_FSC_MSK       = 0x000000FFU;   /** @brief Frame start delimiter code */
  static const uint32_t DCMI_ESUR_FEU_MSK       = 0xFF000000U;   /** @brief Frame end delimiter unmask */
  static const uint32_t DCMI_ESUR_LEU_MSK       = 0x00FF0000U;   /** @brief Line end delimiter unmask */
  static const uint32_t DCMI_ESUR_LSU_MSK       = 0x0000FF00U;   /** @brief Line start delimiter unmask */
  static const uint32_t DCMI_ESUR_FSU_MSK       = 0x000000FFU;   /** @brief Frame start delimiter unmask */
  static const uint32_t DCMI_CWSTRT_VST_MSK     = 0x1FFF0000U;   /** @brief Vertical start line count */
  static const uint32_t DCMI_CWSTRT_HOFFCNT_MSK = 0x00003FFFU;   /** @brief Horizontal offset count */
  static const uint32_t DCMI_CWSIZE_VLINE_MSK   = 0x3FFF0000U;   /** @brief Vertical line count */
  static const uint32_t DCMI_CWSIZE_CAPCNT_MSK  = 0x00003FFFU;   /** @brief Capture count */

  /**** @subsection Enumerated DCMI Register Field Masks ****/

  static const uint32_t DCMI_DR_BYTEx_MSK[4] = {
    [0] = 0x000000FFU,   /** @brief Data byte 0 */
    [1] = 0x0000FF00U,   /** @brief Data byte 1 */
    [2] = 0x00FF0000U,   /** @brief Data byte 2 */
    [3] = 0xFF000000U,   /** @brief Data byte 3 */
  };

  /**** @subsection DCMI Register Field Positions ****/

  static const int32_t DCMI_CR_OELS_POS        = 20;   /** @brief Odd/Even line select (line select start) */
  static const int32_t DCMI_CR_LSM_POS         = 19;   /** @brief Line select mode */
  static const int32_t DCMI_CR_OEBS_POS        = 18;   /** @brief Odd/Even byte select (byte select start) */
  static const int32_t DCMI_CR_BSM_POS         = 16;   /** @brief Byte select mode */
  static const int32_t DCMI_CR_ENABLE_POS      = 14;   /** @brief DCMI enable */
  static const int32_t DCMI_CR_EDM_POS         = 10;   /** @brief Extended data mode */
  static const int32_t DCMI_CR_FCRC_POS        = 8;    /** @brief Frame capture rate control */
  static const int32_t DCMI_CR_VSPOL_POS       = 7;    /** @brief Vertical synchronization polarity */
  static const int32_t DCMI_CR_HSPOL_POS       = 6;    /** @brief Horizontal synchronization polarity */
  static const int32_t DCMI_CR_PCKPOL_POS      = 5;    /** @brief Pixel clock polarity */
  static const int32_t DCMI_CR_ESS_POS         = 4;    /** @brief Embedded synchronization select */
  static const int32_t DCMI_CR_JPEG_POS        = 3;    /** @brief JPEG format */
  static const int32_t DCMI_CR_CROP_POS        = 2;    /** @brief Crop feature */
  static const int32_t DCMI_CR_CM_POS          = 1;    /** @brief Capture mode */
  static const int32_t DCMI_CR_CAPTURE_POS     = 0;    /** @brief Capture enable */
  static const int32_t DCMI_SR_FNE_POS         = 2;    /** @brief FIFO not empty */
  static const int32_t DCMI_SR_VSYNC_POS       = 1;    /** @brief VSYNC */
  static const int32_t DCMI_SR_HSYNC_POS       = 0;    /** @brief HSYNC */
  static const int32_t DCMI_RIS_LINE_RIS_POS   = 4;    /** @brief Line raw interrupt status */
  static const int32_t DCMI_RIS_VSYNC_RIS_POS  = 3;    /** @brief VSYNC raw interrupt status */
  static const int32_t DCMI_RIS_ERR_RIS_POS    = 2;    /** @brief Synchronization error raw interrupt status */
  static const int32_t DCMI_RIS_OVR_RIS_POS    = 1;    /** @brief Overrun raw interrupt status */
  static const int32_t DCMI_RIS_FRAME_RIS_POS  = 0;    /** @brief Capture complete raw interrupt status */
  static const int32_t DCMI_IER_LINE_IE_POS    = 4;    /** @brief Line interrupt enable */
  static const int32_t DCMI_IER_VSYNC_IE_POS   = 3;    /** @brief VSYNC interrupt enable */
  static const int32_t DCMI_IER_ERR_IE_POS     = 2;    /** @brief Synchronization error interrupt enable */
  static const int32_t DCMI_IER_OVR_IE_POS     = 1;    /** @brief Overrun interrupt enable */
  static const int32_t DCMI_IER_FRAME_IE_POS   = 0;    /** @brief Capture complete interrupt enable */
  static const int32_t DCMI_MIS_LINE_MIS_POS   = 4;    /** @brief Line masked interrupt status */
  static const int32_t DCMI_MIS_VSYNC_MIS_POS  = 3;    /** @brief VSYNC masked interrupt status */
  static const int32_t DCMI_MIS_ERR_MIS_POS    = 2;    /** @brief Synchronization error masked interrupt status */
  static const int32_t DCMI_MIS_OVR_MIS_POS    = 1;    /** @brief Overrun masked interrupt status */
  static const int32_t DCMI_MIS_FRAME_MIS_POS  = 0;    /** @brief Capture complete masked interrupt status */
  static const int32_t DCMI_ICR_LINE_ISC_POS   = 4;    /** @brief Line interrupt status clear */
  static const int32_t DCMI_ICR_VSYNC_ISC_POS  = 3;    /** @brief Vertical synch interrupt status clear */
  static const int32_t DCMI_ICR_ERR_ISC_POS    = 2;    /** @brief Synchronization error interrupt status clear */
  static const int32_t DCMI_ICR_OVR_ISC_POS    = 1;    /** @brief Overrun interrupt status clear */
  static const int32_t DCMI_ICR_FRAME_ISC_POS  = 0;    /** @brief Capture complete interrupt status clear */
  static const int32_t DCMI_ESCR_FEC_POS       = 24;   /** @brief Frame end delimiter code */
  static const int32_t DCMI_ESCR_LEC_POS       = 16;   /** @brief Line end delimiter code */
  static const int32_t DCMI_ESCR_LSC_POS       = 8;    /** @brief Line start delimiter code */
  static const int32_t DCMI_ESCR_FSC_POS       = 0;    /** @brief Frame start delimiter code */
  static const int32_t DCMI_ESUR_FEU_POS       = 24;   /** @brief Frame end delimiter unmask */
  static const int32_t DCMI_ESUR_LEU_POS       = 16;   /** @brief Line end delimiter unmask */
  static const int32_t DCMI_ESUR_LSU_POS       = 8;    /** @brief Line start delimiter unmask */
  static const int32_t DCMI_ESUR_FSU_POS       = 0;    /** @brief Frame start delimiter unmask */
  static const int32_t DCMI_CWSTRT_VST_POS     = 16;   /** @brief Vertical start line count */
  static const int32_t DCMI_CWSTRT_HOFFCNT_POS = 0;    /** @brief Horizontal offset count */
  static const int32_t DCMI_CWSIZE_VLINE_POS   = 16;   /** @brief Vertical line count */
  static const int32_t DCMI_CWSIZE_CAPCNT_POS  = 0;    /** @brief Capture count */

  /**** @subsection Enumerated DCMI Register Field Positions ****/

  static const int32_t DCMI_DR_BYTEx_POS[4] = {
    [0] = 0,    /** @brief Data byte 0 */
    [1] = 8,    /** @brief Data byte 1 */
    [2] = 16,   /** @brief Data byte 2 */
    [3] = 24,   /** @brief Data byte 3 */
  };

  /**********************************************************************************************
   * @section OTGx_HS_GLOBAL Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated OTGx_HS_GLOBAL Register Pointers ****/

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040000U,   /** @brief OTG_HS control and status register */
    [2] = (RW_ uint32_t* const)0x40080000U,   /** @brief OTG_HS control and status register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GOTGINT_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040004U,   /** @brief OTG_HS interrupt register */
    [2] = (RW_ uint32_t* const)0x40080004U,   /** @brief OTG_HS interrupt register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040008U,   /** @brief OTG_HS AHB configuration register */
    [2] = (RW_ uint32_t* const)0x40080008U,   /** @brief OTG_HS AHB configuration register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4004000CU,   /** @brief OTG_HS USB configuration register */
    [2] = (RW_ uint32_t* const)0x4008000CU,   /** @brief OTG_HS USB configuration register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040010U,   /** @brief OTG_HS reset register */
    [2] = (RW_ uint32_t* const)0x40080010U,   /** @brief OTG_HS reset register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040014U,   /** @brief OTG_HS core interrupt register */
    [2] = (RW_ uint32_t* const)0x40080014U,   /** @brief OTG_HS core interrupt register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040018U,   /** @brief OTG_HS interrupt mask register */
    [2] = (RW_ uint32_t* const)0x40080018U,   /** @brief OTG_HS interrupt mask register */
  };

  static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4004001CU,   /** @brief OTG_HS receive status debug read register (host mode) */
    [2] = (RO_ uint32_t* const)0x4008001CU,   /** @brief OTG_HS receive status debug read register (host mode) */
  };

  static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040020U,   /** @brief OTG_HS status read and pop register (host mode) */
    [2] = (RO_ uint32_t* const)0x40080020U,   /** @brief OTG_HS status read and pop register (host mode) */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040024U,   /** @brief OTG_HS receive FIFO size register */
    [2] = (RW_ uint32_t* const)0x40080024U,   /** @brief OTG_HS receive FIFO size register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    [2] = (RW_ uint32_t* const)0x40080028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
    [2] = (RW_ uint32_t* const)0x40080028U,   /** @brief OTG_HS nonperiodic transmit FIFO size register (host mode) */
  };

  static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4004002CU,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
    [2] = (RO_ uint32_t* const)0x4008002CU,   /** @brief OTG_HS nonperiodic transmit fifo/queue status register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GCCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040038U,   /** @brief OTG_HS general core configuration register */
    [2] = (RW_ uint32_t* const)0x40080038U,   /** @brief OTG_HS general core configuration register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_CID_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4004003CU,   /** @brief OTG_HS core ID register */
    [2] = (RW_ uint32_t* const)0x4008003CU,   /** @brief OTG_HS core ID register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040100U,   /** @brief OTG_HS host periodic transmit FIFO size register */
    [2] = (RW_ uint32_t* const)0x40080100U,   /** @brief OTG_HS host periodic transmit FIFO size register */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_PTR[3][8] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40040104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [2] = (RW_ uint32_t* const)0x40040108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [3] = (RW_ uint32_t* const)0x4004011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [4] = (RW_ uint32_t* const)0x40040120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [5] = (RW_ uint32_t* const)0x40040124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [6] = (RW_ uint32_t* const)0x40040128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [7] = (RW_ uint32_t* const)0x4004012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40080104U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [2] = (RW_ uint32_t* const)0x40080108U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [3] = (RW_ uint32_t* const)0x4008011CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [4] = (RW_ uint32_t* const)0x40080120U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [5] = (RW_ uint32_t* const)0x40080124U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [6] = (RW_ uint32_t* const)0x40080128U,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
      [7] = (RW_ uint32_t* const)0x4008012CU,   /** @brief OTG_HS device IN endpoint transmit FIFO size register */
    },
  };

  static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4004001CU,   /** @brief OTG_HS receive status debug read register (host mode) */
    [2] = (RO_ uint32_t* const)0x4008001CU,   /** @brief OTG_HS receive status debug read register (host mode) */
  };

  static RO_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040020U,   /** @brief OTG_HS status read and pop register (host mode) */
    [2] = (RO_ uint32_t* const)0x40080020U,   /** @brief OTG_HS status read and pop register (host mode) */
  };

  static RW_ uint32_t* const OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040054U,   /** @brief OTG core LPM configuration register */
    [2] = (RW_ uint32_t* const)0x40080054U,   /** @brief OTG core LPM configuration register */
  };

  /**** @subsection OTGx_HS_GLOBAL Register Field Masks ****/

  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_MSK            = 0x00000001U;   /** @brief Session request success */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_MSK               = 0x00000002U;   /** @brief Session request */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_MSK            = 0x00000100U;   /** @brief Host negotiation success */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_MSK             = 0x00000200U;   /** @brief HNP request */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_MSK           = 0x00000400U;   /** @brief Host set HNP enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_MSK            = 0x00000800U;   /** @brief Device HNP enabled */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_MSK            = 0x00010000U;   /** @brief Connector ID status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_MSK              = 0x00020000U;   /** @brief Long/short debounce time */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_MSK             = 0x00040000U;   /** @brief A-session valid */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_MSK             = 0x00080000U;   /** @brief B-session valid */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_MSK              = 0x00001000U;   /** @brief Embedded host enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_MSK             = 0x00000004U;   /** @brief Session end detected */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_MSK           = 0x00000100U;   /** @brief Session request success status change */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_MSK           = 0x00000200U;   /** @brief Host negotiation success status change */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_MSK            = 0x00020000U;   /** @brief Host negotiation detected */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_MSK           = 0x00040000U;   /** @brief A-device timeout change */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_MSK            = 0x00080000U;   /** @brief Debounce done */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_MSK            = 0x00100000U;   /** @brief ID input pin changed */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_MSK              = 0x00000001U;   /** @brief Global interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_MSK           = 0x0000001EU;   /** @brief Burst length/type */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_MSK             = 0x00000020U;   /** @brief DMA enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_MSK           = 0x00000080U;   /** @brief TxFIFO empty level */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_MSK          = 0x00000100U;   /** @brief Periodic txfifo empty level */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_MSK             = 0x00000007U;   /** @brief FS timeout calibration */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_MSK            = 0x00000040U;   /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_MSK            = 0x00000100U;   /** @brief SRP-capable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_MSK            = 0x00000200U;   /** @brief HNP-capable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_MSK              = 0x00003C00U;   /** @brief USB turnaround time */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_MSK           = 0x00008000U;   /** @brief PHY low-power clock select */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_MSK          = 0x00020000U;   /** @brief ULPI FS/LS select */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_MSK            = 0x00040000U;   /** @brief ULPI auto-resume */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_MSK           = 0x00080000U;   /** @brief ULPI clock suspendm */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_MSK        = 0x00100000U;   /** @brief ULPI external VBUS drive */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_MSK        = 0x00200000U;   /** @brief ULPI external VBUS indicator */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_MSK             = 0x00400000U;   /** @brief TermSel dline pulsing selection */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_MSK              = 0x00800000U;   /** @brief Indicator complement */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_MSK              = 0x01000000U;   /** @brief Indicator pass through */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_MSK           = 0x02000000U;   /** @brief ULPI interface protect disable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_MSK             = 0x20000000U;   /** @brief Forced host mode */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_MSK             = 0x40000000U;   /** @brief Forced peripheral mode */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_MSK             = 0x00000001U;   /** @brief Core soft reset */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_MSK             = 0x00000002U;   /** @brief HCLK soft reset */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_MSK             = 0x00000004U;   /** @brief Host frame counter reset */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_MSK           = 0x00000010U;   /** @brief RxFIFO flush */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_MSK           = 0x00000020U;   /** @brief TxFIFO flush */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_MSK            = 0x000007C0U;   /** @brief TxFIFO number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_MSK            = 0x80000000U;   /** @brief AHB master idle */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_MSK            = 0x40000000U;   /** @brief DMA request signal enabled for USB OTG HS */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_MSK              = 0x00000001U;   /** @brief Current mode of operation */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_MSK              = 0x00000002U;   /** @brief Mode mismatch interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_MSK            = 0x00000004U;   /** @brief OTG interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SOF_MSK               = 0x00000008U;   /** @brief Start of frame */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_MSK            = 0x00000010U;   /** @brief RxFIFO nonempty */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_MSK            = 0x00000020U;   /** @brief Nonperiodic txfifo empty */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_MSK          = 0x00000040U;   /** @brief Global IN nonperiodic NAK effective */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_MSK        = 0x00000080U;   /** @brief Global OUT NAK effective */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_MSK             = 0x00000400U;   /** @brief Early suspend */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_MSK           = 0x00000800U;   /** @brief USB suspend */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_MSK            = 0x00001000U;   /** @brief USB reset */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_MSK           = 0x00002000U;   /** @brief Enumeration done */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_MSK           = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_MSK              = 0x00008000U;   /** @brief End of periodic frame interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_MSK            = 0x00040000U;   /** @brief IN endpoint interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_MSK            = 0x00080000U;   /** @brief OUT endpoint interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_MSK          = 0x00100000U;   /** @brief Incomplete isochronous IN transfer */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_MSK = 0x00200000U;   /** @brief Incomplete periodic transfer */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_MSK         = 0x00400000U;   /** @brief Data fetch suspended */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_MSK           = 0x01000000U;   /** @brief Host port interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_MSK             = 0x02000000U;   /** @brief Host channels interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_MSK             = 0x04000000U;   /** @brief Periodic txfifo empty */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_MSK           = 0x10000000U;   /** @brief Connector ID status change */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_MSK           = 0x20000000U;   /** @brief Disconnect detected interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_MSK            = 0x40000000U;   /** @brief Session request/new session detected interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_MSK            = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_MSK             = 0x00000002U;   /** @brief Mode mismatch interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_MSK            = 0x00000004U;   /** @brief OTG interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_MSK              = 0x00000008U;   /** @brief Start of frame mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_MSK           = 0x00000010U;   /** @brief Receive FIFO nonempty mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_MSK           = 0x00000020U;   /** @brief Nonperiodic txfifo empty mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_MSK         = 0x00000040U;   /** @brief Global nonperiodic IN NAK effective mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_MSK         = 0x00000080U;   /** @brief Global OUT NAK effective mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_MSK            = 0x00000400U;   /** @brief Early suspend mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_MSK          = 0x00000800U;   /** @brief USB suspend mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_MSK            = 0x00001000U;   /** @brief USB reset mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_MSK          = 0x00002000U;   /** @brief Enumeration done mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_MSK          = 0x00004000U;   /** @brief Isochronous OUT packet dropped interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_MSK             = 0x00008000U;   /** @brief End of periodic frame interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_MSK            = 0x00040000U;   /** @brief IN endpoints interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_MSK            = 0x00080000U;   /** @brief OUT endpoints interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_MSK         = 0x00100000U;   /** @brief Incomplete isochronous IN transfer mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_MSK   = 0x00200000U;   /** @brief Incomplete periodic transfer mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_MSK            = 0x00400000U;   /** @brief Data fetch suspended mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_MSK             = 0x01000000U;   /** @brief Host port interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_MSK              = 0x02000000U;   /** @brief Host channels interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_MSK            = 0x04000000U;   /** @brief Periodic txfifo empty mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_MSK          = 0x10000000U;   /** @brief Connector ID status change mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_MSK           = 0x20000000U;   /** @brief Disconnect detected interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_MSK             = 0x40000000U;   /** @brief Session request/new session detected interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_MSK              = 0x80000000U;   /** @brief Resume/remote wakeup detected interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_MSK             = 0x00800000U;   /** @brief Reset detected interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_MSK           = 0x08000000U;   /** @brief LPM interrupt mask */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_MSK        = 0x0000000FU;   /** @brief Channel number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_MSK         = 0x00007FF0U;   /** @brief Byte count */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_MSK         = 0x00018000U;   /** @brief Data PID */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_MSK       = 0x001E0000U;   /** @brief Packet status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_MSK        = 0x0000000FU;   /** @brief Channel number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_MSK         = 0x00007FF0U;   /** @brief Byte count */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_MSK         = 0x00018000U;   /** @brief Data PID */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_MSK       = 0x001E0000U;   /** @brief Packet status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_MSK              = 0x0000FFFFU;   /** @brief RxFIFO depth */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_MSK    = 0x0000FFFFU;   /** @brief Nonperiodic transmit RAM start address */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_MSK     = 0xFFFF0000U;   /** @brief Nonperiodic txfifo depth */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_MSK    = 0x0000FFFFU;   /** @brief Endpoint 0 transmit RAM start address */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_MSK     = 0xFFFF0000U;   /** @brief Endpoint 0 txfifo depth */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_MSK         = 0x0000FFFFU;   /** @brief Nonperiodic txfifo space available */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_MSK         = 0x00FF0000U;   /** @brief Nonperiodic transmit request queue space available */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_MSK         = 0x7F000000U;   /** @brief Top of the nonperiodic transmit request queue */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_MSK              = 0x00010000U;   /** @brief Power down */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_MSK               = 0x00020000U;   /** @brief Battery charging detector (BCD) enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_MSK               = 0x00040000U;   /** @brief Data contact detection (DCD) mode enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDEN_MSK                = 0x00080000U;   /** @brief Primary detection (PD) mode enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDEN_MSK                = 0x00100000U;   /** @brief Secondary detection (SD) mode enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_MSK               = 0x00200000U;   /** @brief USB VBUS detection enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDET_MSK               = 0x00000001U;   /** @brief Data contact detection (DCD) status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDET_MSK                = 0x00000002U;   /** @brief Primary detection (PD) status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDET_MSK                = 0x00000004U;   /** @brief Secondary detection (SD) status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_MSK              = 0x00000008U;   /** @brief DM pull-up detection status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_MSK            = 0x0000FFFFU;   /** @brief Host periodic txfifo start address */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_MSK            = 0xFFFF0000U;   /** @brief Host periodic txfifo depth */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_MSK         = 0x0000FFFFU;   /** @brief IN endpoint fifox transmit RAM start address */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_MSK         = 0xFFFF0000U;   /** @brief IN endpoint txfifo depth */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_MSK      = 0x0000000FU;   /** @brief Endpoint number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_MSK       = 0x00007FF0U;   /** @brief Byte count */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_MSK       = 0x00018000U;   /** @brief Data PID */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_MSK     = 0x001E0000U;   /** @brief Packet status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_MSK     = 0x01E00000U;   /** @brief Frame number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_MSK      = 0x0000000FU;   /** @brief Endpoint number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_MSK       = 0x00007FF0U;   /** @brief Byte count */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_MSK       = 0x00018000U;   /** @brief Data PID */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_MSK     = 0x001E0000U;   /** @brief Packet status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_MSK     = 0x01E00000U;   /** @brief Frame number */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_MSK             = 0x00000001U;   /** @brief LPM support enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_MSK            = 0x00000002U;   /** @brief LPM token acknowledge enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_MSK              = 0x0000003CU;   /** @brief Best effort service latency */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_MSK           = 0x00000040U;   /** @brief BRemoteWake value */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_MSK            = 0x00000080U;   /** @brief L1 shallow sleep enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_MSK          = 0x00000F00U;   /** @brief BESL threshold */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_MSK            = 0x00001000U;   /** @brief L1 deep sleep enable */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_MSK            = 0x00006000U;   /** @brief LPM response */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_MSK            = 0x00008000U;   /** @brief Port sleep status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_MSK           = 0x00010000U;   /** @brief Sleep state resume OK */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_MSK          = 0x001E0000U;   /** @brief LPM channel index */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_MSK           = 0x00E00000U;   /** @brief LPM retry count */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_MSK            = 0x01000000U;   /** @brief Send LPM transaction */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_MSK        = 0x0E000000U;   /** @brief LPM retry count status */
  static const uint32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_MSK            = 0x10000000U;   /** @brief Enable best effort service latency */

  /**** @subsection OTGx_HS_GLOBAL Register Field Positions ****/

  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS_POS            = 0;    /** @brief Session request success */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ_POS               = 1;    /** @brief Session request */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS_POS            = 8;    /** @brief Host negotiation success */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ_POS             = 9;    /** @brief HNP request */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN_POS           = 10;   /** @brief Host set HNP enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN_POS            = 11;   /** @brief Device HNP enabled */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS_POS            = 16;   /** @brief Connector ID status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT_POS              = 17;   /** @brief Long/short debounce time */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD_POS             = 18;   /** @brief A-session valid */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD_POS             = 19;   /** @brief B-session valid */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN_POS              = 12;   /** @brief Embedded host enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SEDET_POS             = 2;    /** @brief Session end detected */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG_POS           = 8;    /** @brief Session request success status change */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG_POS           = 9;    /** @brief Host negotiation success status change */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET_POS            = 17;   /** @brief Host negotiation detected */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG_POS           = 18;   /** @brief A-device timeout change */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE_POS            = 19;   /** @brief Debounce done */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG_POS            = 20;   /** @brief ID input pin changed */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_GINT_POS              = 0;    /** @brief Global interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN_POS           = 1;    /** @brief Burst length/type */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN_POS             = 5;    /** @brief DMA enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL_POS           = 7;    /** @brief TxFIFO empty level */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL_POS          = 8;    /** @brief Periodic txfifo empty level */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL_POS             = 0;    /** @brief FS timeout calibration */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL_POS            = 6;    /** @brief USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP_POS            = 8;    /** @brief SRP-capable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP_POS            = 9;    /** @brief HNP-capable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT_POS              = 10;   /** @brief USB turnaround time */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS_POS           = 15;   /** @brief PHY low-power clock select */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS_POS          = 17;   /** @brief ULPI FS/LS select */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR_POS            = 18;   /** @brief ULPI auto-resume */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM_POS           = 19;   /** @brief ULPI clock suspendm */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD_POS        = 20;   /** @brief ULPI external VBUS drive */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI_POS        = 21;   /** @brief ULPI external VBUS indicator */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS_POS             = 22;   /** @brief TermSel dline pulsing selection */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI_POS              = 23;   /** @brief Indicator complement */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI_POS              = 24;   /** @brief Indicator pass through */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD_POS           = 25;   /** @brief ULPI interface protect disable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD_POS             = 29;   /** @brief Forced host mode */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD_POS             = 30;   /** @brief Forced peripheral mode */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST_POS             = 0;    /** @brief Core soft reset */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST_POS             = 1;    /** @brief HCLK soft reset */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST_POS             = 2;    /** @brief Host frame counter reset */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH_POS           = 4;    /** @brief RxFIFO flush */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH_POS           = 5;    /** @brief TxFIFO flush */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM_POS            = 6;    /** @brief TxFIFO number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL_POS            = 31;   /** @brief AHB master idle */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ_POS            = 30;   /** @brief DMA request signal enabled for USB OTG HS */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CMOD_POS              = 0;    /** @brief Current mode of operation */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_MMIS_POS              = 1;    /** @brief Mode mismatch interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT_POS            = 2;    /** @brief OTG interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SOF_POS               = 3;    /** @brief Start of frame */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL_POS            = 4;    /** @brief RxFIFO nonempty */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE_POS            = 5;    /** @brief Nonperiodic txfifo empty */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF_POS          = 6;    /** @brief Global IN nonperiodic NAK effective */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF_POS        = 7;    /** @brief Global OUT NAK effective */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP_POS             = 10;   /** @brief Early suspend */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP_POS           = 11;   /** @brief USB suspend */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_USBRST_POS            = 12;   /** @brief USB reset */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE_POS           = 13;   /** @brief Enumeration done */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP_POS           = 14;   /** @brief Isochronous OUT packet dropped interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_EOPF_POS              = 15;   /** @brief End of periodic frame interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT_POS            = 18;   /** @brief IN endpoint interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT_POS            = 19;   /** @brief OUT endpoint interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR_POS          = 20;   /** @brief Incomplete isochronous IN transfer */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT_POS = 21;   /** @brief Incomplete periodic transfer */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP_POS         = 22;   /** @brief Data fetch suspended */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT_POS           = 24;   /** @brief Host port interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_HCINT_POS             = 25;   /** @brief Host channels interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE_POS             = 26;   /** @brief Periodic txfifo empty */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG_POS           = 28;   /** @brief Connector ID status change */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT_POS           = 29;   /** @brief Disconnect detected interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT_POS            = 30;   /** @brief Session request/new session detected interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT_POS            = 31;   /** @brief Resume/remote wakeup detected interrupt */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_MMISM_POS             = 1;    /** @brief Mode mismatch interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT_POS            = 2;    /** @brief OTG interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SOFM_POS              = 3;    /** @brief Start of frame mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM_POS           = 4;    /** @brief Receive FIFO nonempty mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM_POS           = 5;    /** @brief Nonperiodic txfifo empty mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM_POS         = 6;    /** @brief Global nonperiodic IN NAK effective mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM_POS         = 7;    /** @brief Global OUT NAK effective mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM_POS            = 10;   /** @brief Early suspend mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM_POS          = 11;   /** @brief USB suspend mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_USBRST_POS            = 12;   /** @brief USB reset mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM_POS          = 13;   /** @brief Enumeration done mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM_POS          = 14;   /** @brief Isochronous OUT packet dropped interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM_POS             = 15;   /** @brief End of periodic frame interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT_POS            = 18;   /** @brief IN endpoints interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT_POS            = 19;   /** @brief OUT endpoints interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM_POS         = 20;   /** @brief Incomplete isochronous IN transfer mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM_POS   = 21;   /** @brief Incomplete periodic transfer mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM_POS            = 22;   /** @brief Data fetch suspended mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM_POS             = 24;   /** @brief Host port interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_HCIM_POS              = 25;   /** @brief Host channels interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM_POS            = 26;   /** @brief Periodic txfifo empty mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM_POS          = 28;   /** @brief Connector ID status change mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT_POS           = 29;   /** @brief Disconnect detected interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM_POS             = 30;   /** @brief Session request/new session detected interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_WUIM_POS              = 31;   /** @brief Resume/remote wakeup detected interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE_POS             = 23;   /** @brief Reset detected interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM_POS           = 27;   /** @brief LPM interrupt mask */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_CHNUM_POS        = 0;    /** @brief Channel number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_BCNT_POS         = 4;    /** @brief Byte count */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_DPID_POS         = 15;   /** @brief Data PID */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_HOST_PKTSTS_POS       = 17;   /** @brief Packet status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_CHNUM_POS        = 0;    /** @brief Channel number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_BCNT_POS         = 4;    /** @brief Byte count */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_DPID_POS         = 15;   /** @brief Data PID */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_HOST_PKTSTS_POS       = 17;   /** @brief Packet status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD_POS              = 0;    /** @brief RxFIFO depth */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFSA_POS    = 0;    /** @brief Nonperiodic transmit RAM start address */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_HNPTXFSIZ_HOST_NPTXFD_POS     = 16;   /** @brief Nonperiodic txfifo depth */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FSA_POS    = 0;    /** @brief Endpoint 0 transmit RAM start address */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXF0_DEVICE_TX0FD_POS     = 16;   /** @brief Endpoint 0 txfifo depth */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV_POS         = 0;    /** @brief Nonperiodic txfifo space available */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV_POS         = 16;   /** @brief Nonperiodic transmit request queue space available */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP_POS         = 24;   /** @brief Top of the nonperiodic transmit request queue */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN_POS              = 16;   /** @brief Power down */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_BCDEN_POS               = 17;   /** @brief Battery charging detector (BCD) enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDEN_POS               = 18;   /** @brief Data contact detection (DCD) mode enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDEN_POS                = 19;   /** @brief Primary detection (PD) mode enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDEN_POS                = 20;   /** @brief Secondary detection (SD) mode enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_VBDEN_POS               = 21;   /** @brief USB VBUS detection enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_DCDET_POS               = 0;    /** @brief Data contact detection (DCD) status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PDET_POS                = 1;    /** @brief Primary detection (PD) status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_SDET_POS                = 2;    /** @brief Secondary detection (SD) status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GCCFG_PS2DET_POS              = 3;    /** @brief DM pull-up detection status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA_POS            = 0;    /** @brief Host periodic txfifo start address */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD_POS            = 16;   /** @brief Host periodic txfifo depth */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXSA_POS         = 0;    /** @brief IN endpoint fifox transmit RAM start address */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_DIEPTXFx_INEPTXFD_POS         = 16;   /** @brief IN endpoint txfifo depth */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_EPNUM_POS      = 0;    /** @brief Endpoint number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_BCNT_POS       = 4;    /** @brief Byte count */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_DPID_POS       = 15;   /** @brief Data PID */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_PKTSTS_POS     = 17;   /** @brief Packet status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSR_DEVICE_FRMNUM_POS     = 21;   /** @brief Frame number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_EPNUM_POS      = 0;    /** @brief Endpoint number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_BCNT_POS       = 4;    /** @brief Byte count */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_DPID_POS       = 15;   /** @brief Data PID */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_PKTSTS_POS     = 17;   /** @brief Packet status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GRXSTSP_DEVICE_FRMNUM_POS     = 21;   /** @brief Frame number */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN_POS             = 0;    /** @brief LPM support enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK_POS            = 1;    /** @brief LPM token acknowledge enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESL_POS              = 2;    /** @brief Best effort service latency */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE_POS           = 6;    /** @brief BRemoteWake value */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN_POS            = 7;    /** @brief L1 shallow sleep enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS_POS          = 8;    /** @brief BESL threshold */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN_POS            = 12;   /** @brief L1 deep sleep enable */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST_POS            = 13;   /** @brief LPM response */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS_POS            = 15;   /** @brief Port sleep status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK_POS           = 16;   /** @brief Sleep state resume OK */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX_POS          = 17;   /** @brief LPM channel index */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT_POS           = 21;   /** @brief LPM retry count */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM_POS            = 24;   /** @brief Send LPM transaction */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS_POS        = 25;   /** @brief LPM retry count status */
  static const int32_t OTGx_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL_POS            = 28;   /** @brief Enable best effort service latency */

  /**********************************************************************************************
   * @section OTGx_HS_HOST Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated OTGx_HS_HOST Register Pointers ****/

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040400U,   /** @brief OTG_HS host configuration register */
    [2] = (RW_ uint32_t* const)0x40080400U,   /** @brief OTG_HS host configuration register */
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFIR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040404U,   /** @brief OTG_HS host frame interval register */
    [2] = (RW_ uint32_t* const)0x40080404U,   /** @brief OTG_HS host frame interval register */
  };

  static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HFNUM_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040408U,   /** @brief OTG_HS host frame number/frame time remaining register */
    [2] = (RO_ uint32_t* const)0x40080408U,   /** @brief OTG_HS host frame number/frame time remaining register */
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPTXSTS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
    [2] = (RW_ uint32_t* const)0x40080410U,   /** @brief OTG_HS_Host periodic transmit fifo/queue status register */
  };

  static RO_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINT_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040414U,   /** @brief OTG_HS host all channels interrupt register */
    [2] = (RO_ uint32_t* const)0x40080414U,   /** @brief OTG_HS host all channels interrupt register */
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HAINTMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040418U,   /** @brief OTG_HS host all channels interrupt mask register */
    [2] = (RW_ uint32_t* const)0x40080418U,   /** @brief OTG_HS host all channels interrupt mask register */
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HPRT_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040440U,   /** @brief OTG_HS host port control and status register */
    [2] = (RW_ uint32_t* const)0x40080440U,   /** @brief OTG_HS host port control and status register */
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCCHARx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x40040500U,   /** @brief OTG_HS host channel-0 characteristics register */
      [1]  = (RW_ uint32_t* const)0x40040520U,   /** @brief OTG_HS host channel-1 characteristics register */
      [2]  = (RW_ uint32_t* const)0x40040540U,   /** @brief OTG_HS host channel-2 characteristics register */
      [3]  = (RW_ uint32_t* const)0x40040560U,   /** @brief OTG_HS host channel-3 characteristics register */
      [4]  = (RW_ uint32_t* const)0x40040580U,   /** @brief OTG_HS host channel-4 characteristics register */
      [5]  = (RW_ uint32_t* const)0x400405A0U,   /** @brief OTG_HS host channel-5 characteristics register */
      [6]  = (RW_ uint32_t* const)0x400405C0U,   /** @brief OTG_HS host channel-6 characteristics register */
      [7]  = (RW_ uint32_t* const)0x400405E0U,   /** @brief OTG_HS host channel-7 characteristics register */
      [8]  = (RW_ uint32_t* const)0x40040600U,   /** @brief OTG_HS host channel-8 characteristics register */
      [9]  = (RW_ uint32_t* const)0x40040620U,   /** @brief OTG_HS host channel-9 characteristics register */
      [10] = (RW_ uint32_t* const)0x40040640U,   /** @brief OTG_HS host channel-10 characteristics register */
      [11] = (RW_ uint32_t* const)0x40040660U,   /** @brief OTG_HS host channel-11 characteristics register */
      [12] = (RW_ uint32_t* const)0x40040678U,   /** @brief OTG_HS host channel-12 characteristics register */
      [13] = (RW_ uint32_t* const)0x40040690U,   /** @brief OTG_HS host channel-13 characteristics register */
      [14] = (RW_ uint32_t* const)0x400406A8U,   /** @brief OTG_HS host channel-14 characteristics register */
      [15] = (RW_ uint32_t* const)0x400406C0U,   /** @brief OTG_HS host channel-15 characteristics register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x40080500U,   /** @brief OTG_HS host channel-0 characteristics register */
      [1]  = (RW_ uint32_t* const)0x40080520U,   /** @brief OTG_HS host channel-1 characteristics register */
      [2]  = (RW_ uint32_t* const)0x40080540U,   /** @brief OTG_HS host channel-2 characteristics register */
      [3]  = (RW_ uint32_t* const)0x40080560U,   /** @brief OTG_HS host channel-3 characteristics register */
      [4]  = (RW_ uint32_t* const)0x40080580U,   /** @brief OTG_HS host channel-4 characteristics register */
      [5]  = (RW_ uint32_t* const)0x400805A0U,   /** @brief OTG_HS host channel-5 characteristics register */
      [6]  = (RW_ uint32_t* const)0x400805C0U,   /** @brief OTG_HS host channel-6 characteristics register */
      [7]  = (RW_ uint32_t* const)0x400805E0U,   /** @brief OTG_HS host channel-7 characteristics register */
      [8]  = (RW_ uint32_t* const)0x40080600U,   /** @brief OTG_HS host channel-8 characteristics register */
      [9]  = (RW_ uint32_t* const)0x40080620U,   /** @brief OTG_HS host channel-9 characteristics register */
      [10] = (RW_ uint32_t* const)0x40080640U,   /** @brief OTG_HS host channel-10 characteristics register */
      [11] = (RW_ uint32_t* const)0x40080660U,   /** @brief OTG_HS host channel-11 characteristics register */
      [12] = (RW_ uint32_t* const)0x40080678U,   /** @brief OTG_HS host channel-12 characteristics register */
      [13] = (RW_ uint32_t* const)0x40080690U,   /** @brief OTG_HS host channel-13 characteristics register */
      [14] = (RW_ uint32_t* const)0x400806A8U,   /** @brief OTG_HS host channel-14 characteristics register */
      [15] = (RW_ uint32_t* const)0x400806C0U,   /** @brief OTG_HS host channel-15 characteristics register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCSPLTx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x40040504U,   /** @brief OTG_HS host channel-0 split control register */
      [1]  = (RW_ uint32_t* const)0x40040524U,   /** @brief OTG_HS host channel-1 split control register */
      [2]  = (RW_ uint32_t* const)0x40040544U,   /** @brief OTG_HS host channel-2 split control register */
      [3]  = (RW_ uint32_t* const)0x40040564U,   /** @brief OTG_HS host channel-3 split control register */
      [4]  = (RW_ uint32_t* const)0x40040584U,   /** @brief OTG_HS host channel-4 split control register */
      [5]  = (RW_ uint32_t* const)0x400405A4U,   /** @brief OTG_HS host channel-5 split control register */
      [6]  = (RW_ uint32_t* const)0x400405C4U,   /** @brief OTG_HS host channel-6 split control register */
      [7]  = (RW_ uint32_t* const)0x400405E4U,   /** @brief OTG_HS host channel-7 split control register */
      [8]  = (RW_ uint32_t* const)0x40040604U,   /** @brief OTG_HS host channel-8 split control register */
      [9]  = (RW_ uint32_t* const)0x40040624U,   /** @brief OTG_HS host channel-9 split control register */
      [10] = (RW_ uint32_t* const)0x40040644U,   /** @brief OTG_HS host channel-10 split control register */
      [11] = (RW_ uint32_t* const)0x40040664U,   /** @brief OTG_HS host channel-11 split control register */
      [12] = (RW_ uint32_t* const)0x4004067CU,   /** @brief OTG_HS host channel-12 split control register */
      [13] = (RW_ uint32_t* const)0x40040694U,   /** @brief OTG_HS host channel-13 split control register */
      [14] = (RW_ uint32_t* const)0x400406ACU,   /** @brief OTG_HS host channel-14 split control register */
      [15] = (RW_ uint32_t* const)0x400406C4U,   /** @brief OTG_HS host channel-15 split control register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x40080504U,   /** @brief OTG_HS host channel-0 split control register */
      [1]  = (RW_ uint32_t* const)0x40080524U,   /** @brief OTG_HS host channel-1 split control register */
      [2]  = (RW_ uint32_t* const)0x40080544U,   /** @brief OTG_HS host channel-2 split control register */
      [3]  = (RW_ uint32_t* const)0x40080564U,   /** @brief OTG_HS host channel-3 split control register */
      [4]  = (RW_ uint32_t* const)0x40080584U,   /** @brief OTG_HS host channel-4 split control register */
      [5]  = (RW_ uint32_t* const)0x400805A4U,   /** @brief OTG_HS host channel-5 split control register */
      [6]  = (RW_ uint32_t* const)0x400805C4U,   /** @brief OTG_HS host channel-6 split control register */
      [7]  = (RW_ uint32_t* const)0x400805E4U,   /** @brief OTG_HS host channel-7 split control register */
      [8]  = (RW_ uint32_t* const)0x40080604U,   /** @brief OTG_HS host channel-8 split control register */
      [9]  = (RW_ uint32_t* const)0x40080624U,   /** @brief OTG_HS host channel-9 split control register */
      [10] = (RW_ uint32_t* const)0x40080644U,   /** @brief OTG_HS host channel-10 split control register */
      [11] = (RW_ uint32_t* const)0x40080664U,   /** @brief OTG_HS host channel-11 split control register */
      [12] = (RW_ uint32_t* const)0x4008067CU,   /** @brief OTG_HS host channel-12 split control register */
      [13] = (RW_ uint32_t* const)0x40080694U,   /** @brief OTG_HS host channel-13 split control register */
      [14] = (RW_ uint32_t* const)0x400806ACU,   /** @brief OTG_HS host channel-14 split control register */
      [15] = (RW_ uint32_t* const)0x400806C4U,   /** @brief OTG_HS host channel-15 split control register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x40040508U,   /** @brief OTG_HS host channel-11 interrupt register */
      [1]  = (RW_ uint32_t* const)0x40040528U,   /** @brief OTG_HS host channel-1 interrupt register */
      [2]  = (RW_ uint32_t* const)0x40040548U,   /** @brief OTG_HS host channel-2 interrupt register */
      [3]  = (RW_ uint32_t* const)0x40040568U,   /** @brief OTG_HS host channel-3 interrupt register */
      [4]  = (RW_ uint32_t* const)0x40040588U,   /** @brief OTG_HS host channel-4 interrupt register */
      [5]  = (RW_ uint32_t* const)0x400405A8U,   /** @brief OTG_HS host channel-5 interrupt register */
      [6]  = (RW_ uint32_t* const)0x400405C8U,   /** @brief OTG_HS host channel-6 interrupt register */
      [7]  = (RW_ uint32_t* const)0x400405E8U,   /** @brief OTG_HS host channel-7 interrupt register */
      [8]  = (RW_ uint32_t* const)0x40040608U,   /** @brief OTG_HS host channel-8 interrupt register */
      [9]  = (RW_ uint32_t* const)0x40040628U,   /** @brief OTG_HS host channel-9 interrupt register */
      [10] = (RW_ uint32_t* const)0x40040648U,   /** @brief OTG_HS host channel-10 interrupt register */
      [11] = (RW_ uint32_t* const)0x40040668U,   /** @brief OTG_HS host channel-11 interrupt register */
      [12] = (RW_ uint32_t* const)0x40040680U,   /** @brief OTG_HS host channel-12 interrupt register */
      [13] = (RW_ uint32_t* const)0x40040698U,   /** @brief OTG_HS host channel-13 interrupt register */
      [14] = (RW_ uint32_t* const)0x400406B0U,   /** @brief OTG_HS host channel-14 interrupt register */
      [15] = (RW_ uint32_t* const)0x400406C8U,   /** @brief OTG_HS host channel-15 interrupt register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x40080508U,   /** @brief OTG_HS host channel-11 interrupt register */
      [1]  = (RW_ uint32_t* const)0x40080528U,   /** @brief OTG_HS host channel-1 interrupt register */
      [2]  = (RW_ uint32_t* const)0x40080548U,   /** @brief OTG_HS host channel-2 interrupt register */
      [3]  = (RW_ uint32_t* const)0x40080568U,   /** @brief OTG_HS host channel-3 interrupt register */
      [4]  = (RW_ uint32_t* const)0x40080588U,   /** @brief OTG_HS host channel-4 interrupt register */
      [5]  = (RW_ uint32_t* const)0x400805A8U,   /** @brief OTG_HS host channel-5 interrupt register */
      [6]  = (RW_ uint32_t* const)0x400805C8U,   /** @brief OTG_HS host channel-6 interrupt register */
      [7]  = (RW_ uint32_t* const)0x400805E8U,   /** @brief OTG_HS host channel-7 interrupt register */
      [8]  = (RW_ uint32_t* const)0x40080608U,   /** @brief OTG_HS host channel-8 interrupt register */
      [9]  = (RW_ uint32_t* const)0x40080628U,   /** @brief OTG_HS host channel-9 interrupt register */
      [10] = (RW_ uint32_t* const)0x40080648U,   /** @brief OTG_HS host channel-10 interrupt register */
      [11] = (RW_ uint32_t* const)0x40080668U,   /** @brief OTG_HS host channel-11 interrupt register */
      [12] = (RW_ uint32_t* const)0x40080680U,   /** @brief OTG_HS host channel-12 interrupt register */
      [13] = (RW_ uint32_t* const)0x40080698U,   /** @brief OTG_HS host channel-13 interrupt register */
      [14] = (RW_ uint32_t* const)0x400806B0U,   /** @brief OTG_HS host channel-14 interrupt register */
      [15] = (RW_ uint32_t* const)0x400806C8U,   /** @brief OTG_HS host channel-15 interrupt register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCINTMSKx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x4004050CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [1]  = (RW_ uint32_t* const)0x4004052CU,   /** @brief OTG_HS host channel-1 interrupt mask register */
      [2]  = (RW_ uint32_t* const)0x4004054CU,   /** @brief OTG_HS host channel-2 interrupt mask register */
      [3]  = (RW_ uint32_t* const)0x4004056CU,   /** @brief OTG_HS host channel-3 interrupt mask register */
      [4]  = (RW_ uint32_t* const)0x4004058CU,   /** @brief OTG_HS host channel-4 interrupt mask register */
      [5]  = (RW_ uint32_t* const)0x400405ACU,   /** @brief OTG_HS host channel-5 interrupt mask register */
      [6]  = (RW_ uint32_t* const)0x400405CCU,   /** @brief OTG_HS host channel-6 interrupt mask register */
      [7]  = (RW_ uint32_t* const)0x400405ECU,   /** @brief OTG_HS host channel-7 interrupt mask register */
      [8]  = (RW_ uint32_t* const)0x4004060CU,   /** @brief OTG_HS host channel-8 interrupt mask register */
      [9]  = (RW_ uint32_t* const)0x4004062CU,   /** @brief OTG_HS host channel-9 interrupt mask register */
      [10] = (RW_ uint32_t* const)0x4004064CU,   /** @brief OTG_HS host channel-10 interrupt mask register */
      [11] = (RW_ uint32_t* const)0x4004066CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [12] = (RW_ uint32_t* const)0x40040684U,   /** @brief OTG_HS host channel-12 interrupt mask register */
      [13] = (RW_ uint32_t* const)0x4004069CU,   /** @brief OTG_HS host channel-13 interrupt mask register */
      [14] = (RW_ uint32_t* const)0x400406B4U,   /** @brief OTG_HS host channel-14 interrupt mask register */
      [15] = (RW_ uint32_t* const)0x400406CCU,   /** @brief OTG_HS host channel-15 interrupt mask register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x4008050CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [1]  = (RW_ uint32_t* const)0x4008052CU,   /** @brief OTG_HS host channel-1 interrupt mask register */
      [2]  = (RW_ uint32_t* const)0x4008054CU,   /** @brief OTG_HS host channel-2 interrupt mask register */
      [3]  = (RW_ uint32_t* const)0x4008056CU,   /** @brief OTG_HS host channel-3 interrupt mask register */
      [4]  = (RW_ uint32_t* const)0x4008058CU,   /** @brief OTG_HS host channel-4 interrupt mask register */
      [5]  = (RW_ uint32_t* const)0x400805ACU,   /** @brief OTG_HS host channel-5 interrupt mask register */
      [6]  = (RW_ uint32_t* const)0x400805CCU,   /** @brief OTG_HS host channel-6 interrupt mask register */
      [7]  = (RW_ uint32_t* const)0x400805ECU,   /** @brief OTG_HS host channel-7 interrupt mask register */
      [8]  = (RW_ uint32_t* const)0x4008060CU,   /** @brief OTG_HS host channel-8 interrupt mask register */
      [9]  = (RW_ uint32_t* const)0x4008062CU,   /** @brief OTG_HS host channel-9 interrupt mask register */
      [10] = (RW_ uint32_t* const)0x4008064CU,   /** @brief OTG_HS host channel-10 interrupt mask register */
      [11] = (RW_ uint32_t* const)0x4008066CU,   /** @brief OTG_HS host channel-11 interrupt mask register */
      [12] = (RW_ uint32_t* const)0x40080684U,   /** @brief OTG_HS host channel-12 interrupt mask register */
      [13] = (RW_ uint32_t* const)0x4008069CU,   /** @brief OTG_HS host channel-13 interrupt mask register */
      [14] = (RW_ uint32_t* const)0x400806B4U,   /** @brief OTG_HS host channel-14 interrupt mask register */
      [15] = (RW_ uint32_t* const)0x400806CCU,   /** @brief OTG_HS host channel-15 interrupt mask register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCTSIZx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x40040510U,   /** @brief OTG_HS host channel-11 transfer size register */
      [1]  = (RW_ uint32_t* const)0x40040530U,   /** @brief OTG_HS host channel-1 transfer size register */
      [2]  = (RW_ uint32_t* const)0x40040550U,   /** @brief OTG_HS host channel-2 transfer size register */
      [3]  = (RW_ uint32_t* const)0x40040570U,   /** @brief OTG_HS host channel-3 transfer size register */
      [4]  = (RW_ uint32_t* const)0x40040590U,   /** @brief OTG_HS host channel-4 transfer size register */
      [5]  = (RW_ uint32_t* const)0x400405B0U,   /** @brief OTG_HS host channel-5 transfer size register */
      [6]  = (RW_ uint32_t* const)0x400405D0U,   /** @brief OTG_HS host channel-6 transfer size register */
      [7]  = (RW_ uint32_t* const)0x400405F0U,   /** @brief OTG_HS host channel-7 transfer size register */
      [8]  = (RW_ uint32_t* const)0x40040610U,   /** @brief OTG_HS host channel-8 transfer size register */
      [9]  = (RW_ uint32_t* const)0x40040630U,   /** @brief OTG_HS host channel-9 transfer size register */
      [10] = (RW_ uint32_t* const)0x40040650U,   /** @brief OTG_HS host channel-10 transfer size register */
      [11] = (RW_ uint32_t* const)0x40040670U,   /** @brief OTG_HS host channel-11 transfer size register */
      [12] = (RW_ uint32_t* const)0x40040688U,   /** @brief OTG_HS host channel-12 transfer size register */
      [13] = (RW_ uint32_t* const)0x400406A0U,   /** @brief OTG_HS host channel-13 transfer size register */
      [14] = (RW_ uint32_t* const)0x400406B8U,   /** @brief OTG_HS host channel-14 transfer size register */
      [15] = (RW_ uint32_t* const)0x400406D0U,   /** @brief OTG_HS host channel-15 transfer size register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x40080510U,   /** @brief OTG_HS host channel-11 transfer size register */
      [1]  = (RW_ uint32_t* const)0x40080530U,   /** @brief OTG_HS host channel-1 transfer size register */
      [2]  = (RW_ uint32_t* const)0x40080550U,   /** @brief OTG_HS host channel-2 transfer size register */
      [3]  = (RW_ uint32_t* const)0x40080570U,   /** @brief OTG_HS host channel-3 transfer size register */
      [4]  = (RW_ uint32_t* const)0x40080590U,   /** @brief OTG_HS host channel-4 transfer size register */
      [5]  = (RW_ uint32_t* const)0x400805B0U,   /** @brief OTG_HS host channel-5 transfer size register */
      [6]  = (RW_ uint32_t* const)0x400805D0U,   /** @brief OTG_HS host channel-6 transfer size register */
      [7]  = (RW_ uint32_t* const)0x400805F0U,   /** @brief OTG_HS host channel-7 transfer size register */
      [8]  = (RW_ uint32_t* const)0x40080610U,   /** @brief OTG_HS host channel-8 transfer size register */
      [9]  = (RW_ uint32_t* const)0x40080630U,   /** @brief OTG_HS host channel-9 transfer size register */
      [10] = (RW_ uint32_t* const)0x40080650U,   /** @brief OTG_HS host channel-10 transfer size register */
      [11] = (RW_ uint32_t* const)0x40080670U,   /** @brief OTG_HS host channel-11 transfer size register */
      [12] = (RW_ uint32_t* const)0x40080688U,   /** @brief OTG_HS host channel-12 transfer size register */
      [13] = (RW_ uint32_t* const)0x400806A0U,   /** @brief OTG_HS host channel-13 transfer size register */
      [14] = (RW_ uint32_t* const)0x400806B8U,   /** @brief OTG_HS host channel-14 transfer size register */
      [15] = (RW_ uint32_t* const)0x400806D0U,   /** @brief OTG_HS host channel-15 transfer size register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_HOST_OTG_HS_HCDMAx_PTR[3][16] = {
    [0] = {
      [0]  = (RW_ uint32_t* const)0x40040514U,   /** @brief OTG_HS host channel-0 DMA address register */
      [1]  = (RW_ uint32_t* const)0x40040534U,   /** @brief OTG_HS host channel-1 DMA address register */
      [2]  = (RW_ uint32_t* const)0x40040554U,   /** @brief OTG_HS host channel-2 DMA address register */
      [3]  = (RW_ uint32_t* const)0x40040574U,   /** @brief OTG_HS host channel-3 DMA address register */
      [4]  = (RW_ uint32_t* const)0x40040594U,   /** @brief OTG_HS host channel-4 DMA address register */
      [5]  = (RW_ uint32_t* const)0x400405B4U,   /** @brief OTG_HS host channel-5 DMA address register */
      [6]  = (RW_ uint32_t* const)0x400405D4U,   /** @brief OTG_HS host channel-6 DMA address register */
      [7]  = (RW_ uint32_t* const)0x400405F4U,   /** @brief OTG_HS host channel-7 DMA address register */
      [8]  = (RW_ uint32_t* const)0x40040614U,   /** @brief OTG_HS host channel-8 DMA address register */
      [9]  = (RW_ uint32_t* const)0x40040634U,   /** @brief OTG_HS host channel-9 DMA address register */
      [10] = (RW_ uint32_t* const)0x40040654U,   /** @brief OTG_HS host channel-10 DMA address register */
      [11] = (RW_ uint32_t* const)0x40040674U,   /** @brief OTG_HS host channel-11 DMA address register */
      [12] = (RW_ uint32_t* const)0x4004068CU,   /** @brief OTG_HS host channel-12 DMA address register */
      [13] = (RW_ uint32_t* const)0x400406A4U,   /** @brief OTG_HS host channel-13 DMA address register */
      [14] = (RW_ uint32_t* const)0x400406BCU,   /** @brief OTG_HS host channel-14 DMA address register */
      [15] = (RW_ uint32_t* const)0x400406D4U,   /** @brief OTG_HS host channel-15 DMA address register */
    },
    [1] = {
      [0]  = (RW_ uint32_t* const)0x40080514U,   /** @brief OTG_HS host channel-0 DMA address register */
      [1]  = (RW_ uint32_t* const)0x40080534U,   /** @brief OTG_HS host channel-1 DMA address register */
      [2]  = (RW_ uint32_t* const)0x40080554U,   /** @brief OTG_HS host channel-2 DMA address register */
      [3]  = (RW_ uint32_t* const)0x40080574U,   /** @brief OTG_HS host channel-3 DMA address register */
      [4]  = (RW_ uint32_t* const)0x40080594U,   /** @brief OTG_HS host channel-4 DMA address register */
      [5]  = (RW_ uint32_t* const)0x400805B4U,   /** @brief OTG_HS host channel-5 DMA address register */
      [6]  = (RW_ uint32_t* const)0x400805D4U,   /** @brief OTG_HS host channel-6 DMA address register */
      [7]  = (RW_ uint32_t* const)0x400805F4U,   /** @brief OTG_HS host channel-7 DMA address register */
      [8]  = (RW_ uint32_t* const)0x40080614U,   /** @brief OTG_HS host channel-8 DMA address register */
      [9]  = (RW_ uint32_t* const)0x40080634U,   /** @brief OTG_HS host channel-9 DMA address register */
      [10] = (RW_ uint32_t* const)0x40080654U,   /** @brief OTG_HS host channel-10 DMA address register */
      [11] = (RW_ uint32_t* const)0x40080674U,   /** @brief OTG_HS host channel-11 DMA address register */
      [12] = (RW_ uint32_t* const)0x4008068CU,   /** @brief OTG_HS host channel-12 DMA address register */
      [13] = (RW_ uint32_t* const)0x400806A4U,   /** @brief OTG_HS host channel-13 DMA address register */
      [14] = (RW_ uint32_t* const)0x400806BCU,   /** @brief OTG_HS host channel-14 DMA address register */
      [15] = (RW_ uint32_t* const)0x400806D4U,   /** @brief OTG_HS host channel-15 DMA address register */
    },
  };

  /**** @subsection OTGx_HS_HOST Register Field Masks ****/

  static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSPCS_MSK      = 0x00000003U;   /** @brief FS/LS PHY clock select */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS_MSK        = 0x00000004U;   /** @brief FS- and ls-only support */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL_MSK        = 0x0000FFFFU;   /** @brief Frame interval */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_FRNUM_MSK       = 0x0000FFFFU;   /** @brief Frame number */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM_MSK       = 0xFFFF0000U;   /** @brief Frame time remaining */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_MSK  = 0x0000FFFFU;   /** @brief Periodic transmit data FIFO space available */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_MSK   = 0x00FF0000U;   /** @brief Periodic transmit request queue space available */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_MSK   = 0xFF000000U;   /** @brief Top of the periodic transmit request queue */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT_MSK       = 0x0000FFFFU;   /** @brief Channel interrupts */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM_MSK   = 0x0000FFFFU;   /** @brief Channel interrupt mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PCSTS_MSK        = 0x00000001U;   /** @brief Port connect status */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PCDET_MSK        = 0x00000002U;   /** @brief Port connect detected */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PENA_MSK         = 0x00000004U;   /** @brief Port enable */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PENCHNG_MSK      = 0x00000008U;   /** @brief Port enable/disable change */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_POCA_MSK         = 0x00000010U;   /** @brief Port overcurrent active */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_POCCHNG_MSK      = 0x00000020U;   /** @brief Port overcurrent change */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PRES_MSK         = 0x00000040U;   /** @brief Port resume */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PSUSP_MSK        = 0x00000080U;   /** @brief Port suspend */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PRST_MSK         = 0x00000100U;   /** @brief Port reset */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PLSTS_MSK        = 0x00000C00U;   /** @brief Port line status */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PPWR_MSK         = 0x00001000U;   /** @brief Port power */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PTCTL_MSK        = 0x0001E000U;   /** @brief Port test control */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD_MSK         = 0x00060000U;   /** @brief Port speed */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MPSIZ_MSK     = 0x000007FFU;   /** @brief Maximum packet size */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPNUM_MSK     = 0x00007800U;   /** @brief Endpoint number */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPDIR_MSK     = 0x00008000U;   /** @brief Endpoint direction */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_LSDEV_MSK     = 0x00020000U;   /** @brief Low-speed device */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPTYP_MSK     = 0x000C0000U;   /** @brief Endpoint type */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MC_MSK        = 0x00300000U;   /** @brief Multi count (MC) / error count (EC) */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_DAD_MSK       = 0x1FC00000U;   /** @brief Device address */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_ODDFRM_MSK    = 0x20000000U;   /** @brief Odd frame */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHDIS_MSK     = 0x40000000U;   /** @brief Channel disable */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA_MSK     = 0x80000000U;   /** @brief Channel enable */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_PRTADDR_MSK   = 0x0000007FU;   /** @brief Port address */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_HUBADDR_MSK   = 0x00003F80U;   /** @brief Hub address */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_XACTPOS_MSK   = 0x0000C000U;   /** @brief XACTPOS */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_COMPLSPLT_MSK = 0x00010000U;   /** @brief Do complete split */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN_MSK   = 0x80000000U;   /** @brief Split enable */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_XFRC_MSK       = 0x00000001U;   /** @brief Transfer completed */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_CHH_MSK        = 0x00000002U;   /** @brief Channel halted */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_AHBERR_MSK     = 0x00000004U;   /** @brief AHB error */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_STALL_MSK      = 0x00000008U;   /** @brief STALL response received interrupt */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_NAK_MSK        = 0x00000010U;   /** @brief NAK response received interrupt */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_ACK_MSK        = 0x00000020U;   /** @brief ACK response received/transmitted interrupt */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_NYET_MSK       = 0x00000040U;   /** @brief Response received interrupt */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_TXERR_MSK      = 0x00000080U;   /** @brief Transaction error */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_BBERR_MSK      = 0x00000100U;   /** @brief Babble error */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_FRMOR_MSK      = 0x00000200U;   /** @brief Frame overrun */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR_MSK      = 0x00000400U;   /** @brief Data toggle error */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_XFRCM_MSK   = 0x00000001U;   /** @brief Transfer completed mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_CHHM_MSK    = 0x00000002U;   /** @brief Channel halted mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_AHBERR_MSK  = 0x00000004U;   /** @brief AHB error */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_STALLM_MSK  = 0x00000008U;   /** @brief STALL response received interrupt mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NAKM_MSK    = 0x00000010U;   /** @brief NAK response received interrupt mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_ACKM_MSK    = 0x00000020U;   /** @brief ACK response received/transmitted interrupt mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NYET_MSK    = 0x00000040U;   /** @brief Response received interrupt mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_TXERRM_MSK  = 0x00000080U;   /** @brief Transaction error mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_BBERRM_MSK  = 0x00000100U;   /** @brief Babble error mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_FRMORM_MSK  = 0x00000200U;   /** @brief Frame overrun mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_DTERRM_MSK  = 0x00000400U;   /** @brief Data toggle error mask */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_XFRSIZ_MSK    = 0x0007FFFFU;   /** @brief Transfer size */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_PKTCNT_MSK    = 0x1FF80000U;   /** @brief Packet count */
  static const uint32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID_MSK      = 0x60000000U;   /** @brief Data PID */

  /**** @subsection OTGx_HS_HOST Register Field Positions ****/

  static const int32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSPCS_POS      = 0;    /** @brief FS/LS PHY clock select */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCFG_FSLSS_POS        = 2;    /** @brief FS- and ls-only support */
  static const int32_t OTGx_HS_HOST_OTG_HS_HFIR_FRIVL_POS        = 0;    /** @brief Frame interval */
  static const int32_t OTGx_HS_HOST_OTG_HS_HFNUM_FRNUM_POS       = 0;    /** @brief Frame number */
  static const int32_t OTGx_HS_HOST_OTG_HS_HFNUM_FTREM_POS       = 16;   /** @brief Frame time remaining */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL_POS  = 0;    /** @brief Periodic transmit data FIFO space available */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV_POS   = 16;   /** @brief Periodic transmit request queue space available */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP_POS   = 24;   /** @brief Top of the periodic transmit request queue */
  static const int32_t OTGx_HS_HOST_OTG_HS_HAINT_HAINT_POS       = 0;    /** @brief Channel interrupts */
  static const int32_t OTGx_HS_HOST_OTG_HS_HAINTMSK_HAINTM_POS   = 0;    /** @brief Channel interrupt mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PCSTS_POS        = 0;    /** @brief Port connect status */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PCDET_POS        = 1;    /** @brief Port connect detected */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PENA_POS         = 2;    /** @brief Port enable */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PENCHNG_POS      = 3;    /** @brief Port enable/disable change */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_POCA_POS         = 4;    /** @brief Port overcurrent active */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_POCCHNG_POS      = 5;    /** @brief Port overcurrent change */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PRES_POS         = 6;    /** @brief Port resume */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PSUSP_POS        = 7;    /** @brief Port suspend */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PRST_POS         = 8;    /** @brief Port reset */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PLSTS_POS        = 10;   /** @brief Port line status */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PPWR_POS         = 12;   /** @brief Port power */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PTCTL_POS        = 13;   /** @brief Port test control */
  static const int32_t OTGx_HS_HOST_OTG_HS_HPRT_PSPD_POS         = 17;   /** @brief Port speed */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MPSIZ_POS     = 0;    /** @brief Maximum packet size */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPNUM_POS     = 11;   /** @brief Endpoint number */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPDIR_POS     = 15;   /** @brief Endpoint direction */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_LSDEV_POS     = 17;   /** @brief Low-speed device */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_EPTYP_POS     = 18;   /** @brief Endpoint type */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_MC_POS        = 20;   /** @brief Multi count (MC) / error count (EC) */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_DAD_POS       = 22;   /** @brief Device address */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_ODDFRM_POS    = 29;   /** @brief Odd frame */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHDIS_POS     = 30;   /** @brief Channel disable */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCCHARx_CHENA_POS     = 31;   /** @brief Channel enable */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_PRTADDR_POS   = 0;    /** @brief Port address */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_HUBADDR_POS   = 7;    /** @brief Hub address */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_XACTPOS_POS   = 14;   /** @brief XACTPOS */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_COMPLSPLT_POS = 16;   /** @brief Do complete split */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCSPLTx_SPLITEN_POS   = 31;   /** @brief Split enable */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_XFRC_POS       = 0;    /** @brief Transfer completed */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_CHH_POS        = 1;    /** @brief Channel halted */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_AHBERR_POS     = 2;    /** @brief AHB error */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_STALL_POS      = 3;    /** @brief STALL response received interrupt */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_NAK_POS        = 4;    /** @brief NAK response received interrupt */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_ACK_POS        = 5;    /** @brief ACK response received/transmitted interrupt */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_NYET_POS       = 6;    /** @brief Response received interrupt */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_TXERR_POS      = 7;    /** @brief Transaction error */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_BBERR_POS      = 8;    /** @brief Babble error */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_FRMOR_POS      = 9;    /** @brief Frame overrun */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTx_DTERR_POS      = 10;   /** @brief Data toggle error */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_XFRCM_POS   = 0;    /** @brief Transfer completed mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_CHHM_POS    = 1;    /** @brief Channel halted mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_AHBERR_POS  = 2;    /** @brief AHB error */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_STALLM_POS  = 3;    /** @brief STALL response received interrupt mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NAKM_POS    = 4;    /** @brief NAK response received interrupt mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_ACKM_POS    = 5;    /** @brief ACK response received/transmitted interrupt mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_NYET_POS    = 6;    /** @brief Response received interrupt mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_TXERRM_POS  = 7;    /** @brief Transaction error mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_BBERRM_POS  = 8;    /** @brief Babble error mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_FRMORM_POS  = 9;    /** @brief Frame overrun mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCINTMSKx_DTERRM_POS  = 10;   /** @brief Data toggle error mask */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_XFRSIZ_POS    = 0;    /** @brief Transfer size */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_PKTCNT_POS    = 19;   /** @brief Packet count */
  static const int32_t OTGx_HS_HOST_OTG_HS_HCTSIZx_DPID_POS      = 29;   /** @brief Data PID */

  /**********************************************************************************************
   * @section OTGx_HS_DEVICE Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated OTGx_HS_DEVICE Register Pointers ****/

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DCFG_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040800U,   /** @brief OTG_HS device configuration register */
    [2] = (RW_ uint32_t* const)0x40080800U,   /** @brief OTG_HS device configuration register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DCTL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040804U,   /** @brief OTG_HS device control register */
    [2] = (RW_ uint32_t* const)0x40080804U,   /** @brief OTG_HS device control register */
  };

  static RO_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DSTS_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040808U,   /** @brief OTG_HS device status register */
    [2] = (RO_ uint32_t* const)0x40080808U,   /** @brief OTG_HS device status register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040810U,   /** @brief OTG_HS device IN endpoint common interrupt mask register */
    [2] = (RW_ uint32_t* const)0x40080810U,   /** @brief OTG_HS device IN endpoint common interrupt mask register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DOEPMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040814U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
    [2] = (RW_ uint32_t* const)0x40080814U,   /** @brief OTG_HS device OUT endpoint common interrupt mask register */
  };

  static RO_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DAINT_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40040818U,   /** @brief OTG_HS device all endpoints interrupt register */
    [2] = (RO_ uint32_t* const)0x40080818U,   /** @brief OTG_HS device all endpoints interrupt register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DAINTMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4004081CU,   /** @brief OTG_HS all endpoints interrupt mask register */
    [2] = (RW_ uint32_t* const)0x4008081CU,   /** @brief OTG_HS all endpoints interrupt mask register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040828U,   /** @brief OTG_HS device VBUS discharge time register */
    [2] = (RW_ uint32_t* const)0x40080828U,   /** @brief OTG_HS device VBUS discharge time register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4004082CU,   /** @brief OTG_HS device VBUS pulsing time register */
    [2] = (RW_ uint32_t* const)0x4008082CU,   /** @brief OTG_HS device VBUS pulsing time register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DTHRCTL_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040830U,   /** @brief OTG_HS device threshold control register */
    [2] = (RW_ uint32_t* const)0x40080830U,   /** @brief OTG_HS device threshold control register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040834U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
    [2] = (RW_ uint32_t* const)0x40080834U,   /** @brief OTG_HS device IN endpoint FIFO empty interrupt mask register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DEACHINT_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040838U,   /** @brief OTG_HS device each endpoint interrupt register */
    [2] = (RW_ uint32_t* const)0x40080838U,   /** @brief OTG_HS device each endpoint interrupt register */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4004083CU,   /** @brief OTG_HS device each endpoint interrupt register mask */
    [2] = (RW_ uint32_t* const)0x4008083CU,   /** @brief OTG_HS device each endpoint interrupt register mask */
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040900U,   /** @brief OTG device endpoint-0 control register */
      [1] = (RW_ uint32_t* const)0x40040920U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40040940U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40040960U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40040980U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x400409A0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x400409C0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x400409E0U,   /** @brief OTG device endpoint-7 control register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080900U,   /** @brief OTG device endpoint-0 control register */
      [1] = (RW_ uint32_t* const)0x40080920U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40080940U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40080960U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40080980U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x400809A0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x400809C0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x400809E0U,   /** @brief OTG device endpoint-7 control register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPINTx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040908U,   /** @brief OTG device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40040928U,   /** @brief OTG device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40040948U,   /** @brief OTG device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40040968U,   /** @brief OTG device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40040988U,   /** @brief OTG device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x400409A8U,   /** @brief OTG device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x400409C8U,   /** @brief OTG device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x400409E8U,   /** @brief OTG device endpoint-7 interrupt register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080908U,   /** @brief OTG device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40080928U,   /** @brief OTG device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40080948U,   /** @brief OTG device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40080968U,   /** @brief OTG device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40080988U,   /** @brief OTG device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x400809A8U,   /** @brief OTG device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x400809C8U,   /** @brief OTG device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x400809E8U,   /** @brief OTG device endpoint-7 interrupt register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040910U,   /** @brief OTG_HS device IN endpoint 0 transfer size register */
      [1] = (RW_ uint32_t* const)0x40040930U,   /** @brief OTG_HS device endpoint transfer size register */
      [2] = (RW_ uint32_t* const)0x40040950U,   /** @brief OTG_HS device endpoint transfer size register */
      [3] = (RW_ uint32_t* const)0x40040970U,   /** @brief OTG_HS device endpoint transfer size register */
      [4] = (RW_ uint32_t* const)0x40040990U,   /** @brief OTG_HS device endpoint transfer size register */
      [5] = (RW_ uint32_t* const)0x400409B0U,   /** @brief OTG_HS device endpoint transfer size register */
      [6] = (RW_ uint32_t* const)0x400409A0U,   /** @brief OTG_HS device endpoint transfer size register */
      [7] = (RW_ uint32_t* const)0x400409A8U,   /** @brief OTG_HS device endpoint transfer size register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080910U,   /** @brief OTG_HS device IN endpoint 0 transfer size register */
      [1] = (RW_ uint32_t* const)0x40080930U,   /** @brief OTG_HS device endpoint transfer size register */
      [2] = (RW_ uint32_t* const)0x40080950U,   /** @brief OTG_HS device endpoint transfer size register */
      [3] = (RW_ uint32_t* const)0x40080970U,   /** @brief OTG_HS device endpoint transfer size register */
      [4] = (RW_ uint32_t* const)0x40080990U,   /** @brief OTG_HS device endpoint transfer size register */
      [5] = (RW_ uint32_t* const)0x400809B0U,   /** @brief OTG_HS device endpoint transfer size register */
      [6] = (RW_ uint32_t* const)0x400809A0U,   /** @brief OTG_HS device endpoint transfer size register */
      [7] = (RW_ uint32_t* const)0x400809A8U,   /** @brief OTG_HS device endpoint transfer size register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DIEPDMAx_PTR[3][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40040914U,   /** @brief OTG_HS device endpoint-1 DMA address register */
      [2] = (RW_ uint32_t* const)0x40040934U,   /** @brief OTG_HS device endpoint-2 DMA address register */
      [3] = (RW_ uint32_t* const)0x40040954U,   /** @brief OTG_HS device endpoint-3 DMA address register */
      [4] = (RW_ uint32_t* const)0x40040974U,   /** @brief OTG_HS device endpoint-4 DMA address register */
      [5] = (RW_ uint32_t* const)0x40040994U,   /** @brief OTG_HS device endpoint-5 DMA address register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40080914U,   /** @brief OTG_HS device endpoint-1 DMA address register */
      [2] = (RW_ uint32_t* const)0x40080934U,   /** @brief OTG_HS device endpoint-2 DMA address register */
      [3] = (RW_ uint32_t* const)0x40080954U,   /** @brief OTG_HS device endpoint-3 DMA address register */
      [4] = (RW_ uint32_t* const)0x40080974U,   /** @brief OTG_HS device endpoint-4 DMA address register */
      [5] = (RW_ uint32_t* const)0x40080994U,   /** @brief OTG_HS device endpoint-5 DMA address register */
    },
  };

  static RO_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_PTR[3][8] = {
    [0] = {
      [0] = (RO_ uint32_t* const)0x40040918U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [1] = (RO_ uint32_t* const)0x40040938U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [2] = (RO_ uint32_t* const)0x40040958U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [3] = (RO_ uint32_t* const)0x40040978U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [4] = (RO_ uint32_t* const)0x40040998U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [5] = (RO_ uint32_t* const)0x400409B8U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [6] = (RO_ uint32_t* const)0x400409A4U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [7] = (RO_ uint32_t* const)0x400409ACU,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    },
    [1] = {
      [0] = (RO_ uint32_t* const)0x40080918U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [1] = (RO_ uint32_t* const)0x40080938U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [2] = (RO_ uint32_t* const)0x40080958U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [3] = (RO_ uint32_t* const)0x40080978U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [4] = (RO_ uint32_t* const)0x40080998U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [5] = (RO_ uint32_t* const)0x400809B8U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [6] = (RO_ uint32_t* const)0x400809A4U,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
      [7] = (RO_ uint32_t* const)0x400809ACU,   /** @brief OTG_HS device IN endpoint transmit FIFO status register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040B00U,   /** @brief OTG_HS device control OUT endpoint 0 control register */
      [1] = (RW_ uint32_t* const)0x40040B20U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40040B40U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40040B60U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40040B80U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x40040BA0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x40040BC0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x40040BE0U,   /** @brief OTG device endpoint-7 control register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080B00U,   /** @brief OTG_HS device control OUT endpoint 0 control register */
      [1] = (RW_ uint32_t* const)0x40080B20U,   /** @brief OTG device endpoint-1 control register */
      [2] = (RW_ uint32_t* const)0x40080B40U,   /** @brief OTG device endpoint-2 control register */
      [3] = (RW_ uint32_t* const)0x40080B60U,   /** @brief OTG device endpoint-3 control register */
      [4] = (RW_ uint32_t* const)0x40080B80U,   /** @brief OTG device endpoint-4 control register */
      [5] = (RW_ uint32_t* const)0x40080BA0U,   /** @brief OTG device endpoint-5 control register */
      [6] = (RW_ uint32_t* const)0x40080BC0U,   /** @brief OTG device endpoint-6 control register */
      [7] = (RW_ uint32_t* const)0x40080BE0U,   /** @brief OTG device endpoint-7 control register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DOEPINTx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040B08U,   /** @brief OTG_HS device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40040B28U,   /** @brief OTG_HS device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40040B48U,   /** @brief OTG_HS device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40040B68U,   /** @brief OTG_HS device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40040B88U,   /** @brief OTG_HS device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x40040BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x40040BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x40040BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080B08U,   /** @brief OTG_HS device endpoint-0 interrupt register */
      [1] = (RW_ uint32_t* const)0x40080B28U,   /** @brief OTG_HS device endpoint-1 interrupt register */
      [2] = (RW_ uint32_t* const)0x40080B48U,   /** @brief OTG_HS device endpoint-2 interrupt register */
      [3] = (RW_ uint32_t* const)0x40080B68U,   /** @brief OTG_HS device endpoint-3 interrupt register */
      [4] = (RW_ uint32_t* const)0x40080B88U,   /** @brief OTG_HS device endpoint-4 interrupt register */
      [5] = (RW_ uint32_t* const)0x40080BA8U,   /** @brief OTG_HS device endpoint-5 interrupt register */
      [6] = (RW_ uint32_t* const)0x40080BC8U,   /** @brief OTG_HS device endpoint-6 interrupt register */
      [7] = (RW_ uint32_t* const)0x40080BE8U,   /** @brief OTG_HS device endpoint-7 interrupt register */
    },
  };

  static RW_ uint32_t* const OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40040B10U,   /** @brief OTG_HS device endpoint-0 transfer size register */
      [1] = (RW_ uint32_t* const)0x40040B30U,   /** @brief OTG_HS device endpoint-1 transfer size register */
      [2] = (RW_ uint32_t* const)0x40040B50U,   /** @brief OTG_HS device endpoint-2 transfer size register */
      [3] = (RW_ uint32_t* const)0x40040B70U,   /** @brief OTG_HS device endpoint-3 transfer size register */
      [4] = (RW_ uint32_t* const)0x40040B90U,   /** @brief OTG_HS device endpoint-4 transfer size register */
      [5] = (RW_ uint32_t* const)0x40040BB0U,   /** @brief OTG_HS device endpoint-5 transfer size register */
      [6] = (RW_ uint32_t* const)0x40040BD0U,   /** @brief OTG_HS device endpoint-6 transfer size register */
      [7] = (RW_ uint32_t* const)0x40040BF0U,   /** @brief OTG_HS device endpoint-7 transfer size register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40080B10U,   /** @brief OTG_HS device endpoint-0 transfer size register */
      [1] = (RW_ uint32_t* const)0x40080B30U,   /** @brief OTG_HS device endpoint-1 transfer size register */
      [2] = (RW_ uint32_t* const)0x40080B50U,   /** @brief OTG_HS device endpoint-2 transfer size register */
      [3] = (RW_ uint32_t* const)0x40080B70U,   /** @brief OTG_HS device endpoint-3 transfer size register */
      [4] = (RW_ uint32_t* const)0x40080B90U,   /** @brief OTG_HS device endpoint-4 transfer size register */
      [5] = (RW_ uint32_t* const)0x40080BB0U,   /** @brief OTG_HS device endpoint-5 transfer size register */
      [6] = (RW_ uint32_t* const)0x40080BD0U,   /** @brief OTG_HS device endpoint-6 transfer size register */
      [7] = (RW_ uint32_t* const)0x40080BF0U,   /** @brief OTG_HS device endpoint-7 transfer size register */
    },
  };

  /**** @subsection OTGx_HS_DEVICE Register Field Masks ****/

  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DSPD_MSK               = 0x00000003U;   /** @brief Device speed */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_MSK           = 0x00000004U;   /** @brief Nonzero-length status OUT handshake */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DAD_MSK                = 0x000007F0U;   /** @brief Device address */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PFIVL_MSK              = 0x00001800U;   /** @brief Periodic (micro)frame interval */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_MSK          = 0x03000000U;   /** @brief Periodic scheduling interval */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_RWUSIG_MSK             = 0x00000001U;   /** @brief Remote wakeup signaling */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SDIS_MSK               = 0x00000002U;   /** @brief Soft disconnect */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GINSTS_MSK             = 0x00000004U;   /** @brief Global IN NAK status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GONSTS_MSK             = 0x00000008U;   /** @brief Global OUT NAK status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_TCTL_MSK               = 0x00000070U;   /** @brief Test control */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGINAK_MSK             = 0x00000080U;   /** @brief Set global IN NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGINAK_MSK             = 0x00000100U;   /** @brief Clear global IN NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGONAK_MSK             = 0x00000200U;   /** @brief Set global OUT NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGONAK_MSK             = 0x00000400U;   /** @brief Clear global OUT NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_MSK           = 0x00000800U;   /** @brief Power-on programming done */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_MSK            = 0x00000001U;   /** @brief Suspend status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_MSK            = 0x00000006U;   /** @brief Enumerated speed */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_EERR_MSK               = 0x00000008U;   /** @brief Erratic error */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DSTS_FNSOF_MSK              = 0x003FFF00U;   /** @brief Frame number of the received SOF */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_MSK           = 0x00000001U;   /** @brief Transfer completed interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_MSK            = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TOM_MSK             = 0x00000008U;   /** @brief Timeout condition mask (nonisochronous endpoints) */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_MSK       = 0x00000010U;   /** @brief IN token received when txfifo empty mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_MSK         = 0x00000020U;   /** @brief IN token received with EP mismatch mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_MSK         = 0x00000040U;   /** @brief IN endpoint NAK effective mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_MSK          = 0x00000100U;   /** @brief FIFO underrun mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_BIM_MSK             = 0x00000200U;   /** @brief BNA interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_MSK           = 0x00000001U;   /** @brief Transfer completed interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_MSK            = 0x00000002U;   /** @brief Endpoint disabled interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_MSK           = 0x00000008U;   /** @brief SETUP phase done mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_MSK          = 0x00000010U;   /** @brief OUT token received when endpoint disabled mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_MSK         = 0x00000040U;   /** @brief Back-to-back SETUP packets received mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_MSK            = 0x00000100U;   /** @brief OUT packet error mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_MSK            = 0x00000200U;   /** @brief BNA interrupt mask */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINT_IEPINT_MSK            = 0x0000FFFFU;   /** @brief IN endpoint interrupt bits */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINT_OEPINT_MSK            = 0xFFFF0000U;   /** @brief OUT endpoint interrupt bits */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_MSK           = 0x0000FFFFU;   /** @brief IN EP interrupt mask bits */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_MSK           = 0xFFFF0000U;   /** @brief OUT EP interrupt mask bits */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_MSK         = 0x0000FFFFU;   /** @brief Device VBUS discharge time */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_MSK       = 0x00000FFFU;   /** @brief Device VBUS pulsing time */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_MSK     = 0x00000001U;   /** @brief Nonisochronous IN endpoints threshold enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_MSK        = 0x00000002U;   /** @brief ISO IN endpoint threshold enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_MSK        = 0x000007FCU;   /** @brief Transmit threshold length */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_MSK         = 0x00010000U;   /** @brief Receive threshold enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_MSK        = 0x03FE0000U;   /** @brief Receive threshold length */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_MSK           = 0x08000000U;   /** @brief Arbiter parking enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_MSK    = 0x0000FFFFU;   /** @brief IN EP tx FIFO empty interrupt mask bits */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_MSK        = 0x00000002U;   /** @brief IN endpoint 1interrupt bit */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_MSK        = 0x00020000U;   /** @brief OUT endpoint 1 interrupt bit */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_MSK    = 0x00000002U;   /** @brief IN endpoint 1 interrupt mask bit */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_MSK    = 0x00020000U;   /** @brief OUT endpoint 1 interrupt mask bit */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_MSK          = 0x000007FFU;   /** @brief Maximum packet size */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_MSK         = 0x00008000U;   /** @brief USB active endpoint */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_MSK     = 0x00010000U;   /** @brief Even/odd frame */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_MSK         = 0x00020000U;   /** @brief NAK status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_MSK          = 0x000C0000U;   /** @brief Endpoint type */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_MSK          = 0x00200000U;   /** @brief STALL handshake */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_MSK         = 0x03C00000U;   /** @brief TxFIFO number */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_MSK           = 0x04000000U;   /** @brief Clear NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_MSK           = 0x08000000U;   /** @brief Set NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_MSK = 0x10000000U;   /** @brief Set DATA0 PID */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_MSK        = 0x20000000U;   /** @brief Set odd frame */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_MSK          = 0x40000000U;   /** @brief Endpoint disable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_MSK          = 0x80000000U;   /** @brief Endpoint enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_MSK           = 0x00000001U;   /** @brief Transfer completed interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_MSK         = 0x00000002U;   /** @brief Endpoint disabled interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TOC_MSK            = 0x00000008U;   /** @brief Timeout condition */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_MSK         = 0x00000010U;   /** @brief IN token received when txfifo is empty */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_MSK         = 0x00000040U;   /** @brief IN endpoint NAK effective */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_MSK           = 0x00000080U;   /** @brief Transmit FIFO empty */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_MSK     = 0x00000100U;   /** @brief Transmit fifo underrun */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BNA_MSK            = 0x00000200U;   /** @brief Buffer not available interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_MSK      = 0x00000800U;   /** @brief Packet dropped status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BERR_MSK           = 0x00001000U;   /** @brief Babble error interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_NAK_MSK            = 0x00002000U;   /** @brief NAK interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_XFRSIZ_MSK        = 0x0000007FU;   /** @brief Transfer size */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_PKTCNT_MSK        = 0x00180000U;   /** @brief Packet count */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_INEPTFSAV_MSK      = 0x0000FFFFU;   /** @brief IN endpoint txfifo space avail */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_MPSIZ_MSK          = 0x00000003U;   /** @brief Maximum packet size */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_USBAEP_MSK         = 0x00008000U;   /** @brief USB active endpoint */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_NAKSTS_MSK         = 0x00020000U;   /** @brief NAK status */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPTYP_MSK          = 0x000C0000U;   /** @brief Endpoint type */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNPM_MSK           = 0x00100000U;   /** @brief Snoop mode */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_STALL_MSK          = 0x00200000U;   /** @brief STALL handshake */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_CNAK_MSK           = 0x04000000U;   /** @brief Clear NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNAK_MSK           = 0x08000000U;   /** @brief Set NAK */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPDIS_MSK          = 0x40000000U;   /** @brief Endpoint disable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPENA_MSK          = 0x80000000U;   /** @brief Endpoint enable */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_MSK           = 0x00000001U;   /** @brief Transfer completed interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_MSK         = 0x00000002U;   /** @brief Endpoint disabled interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_STUP_MSK           = 0x00000008U;   /** @brief SETUP phase done */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_MSK        = 0x00000010U;   /** @brief OUT token received when endpoint disabled */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_MSK        = 0x00000040U;   /** @brief Back-to-back SETUP packets received */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_NYET_MSK           = 0x00004000U;   /** @brief NYET interrupt */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_XFRSIZ_MSK        = 0x0000007FU;   /** @brief Transfer size */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_PKTCNT_MSK        = 0x00080000U;   /** @brief Packet count */
  static const uint32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_STUPCNT_MSK       = 0x60000000U;   /** @brief SETUP packet count */

  /**** @subsection OTGx_HS_DEVICE Register Field Positions ****/

  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DSPD_POS               = 0;    /** @brief Device speed */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK_POS           = 2;    /** @brief Nonzero-length status OUT handshake */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCFG_DAD_POS                = 4;    /** @brief Device address */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PFIVL_POS              = 11;   /** @brief Periodic (micro)frame interval */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL_POS          = 24;   /** @brief Periodic scheduling interval */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_RWUSIG_POS             = 0;    /** @brief Remote wakeup signaling */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SDIS_POS               = 1;    /** @brief Soft disconnect */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GINSTS_POS             = 2;    /** @brief Global IN NAK status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_GONSTS_POS             = 3;    /** @brief Global OUT NAK status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_TCTL_POS               = 4;    /** @brief Test control */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGINAK_POS             = 7;    /** @brief Set global IN NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGINAK_POS             = 8;    /** @brief Clear global IN NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_SGONAK_POS             = 9;    /** @brief Set global OUT NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_CGONAK_POS             = 10;   /** @brief Clear global OUT NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DCTL_POPRGDNE_POS           = 11;   /** @brief Power-on programming done */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DSTS_SUSPSTS_POS            = 0;    /** @brief Suspend status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DSTS_ENUMSPD_POS            = 1;    /** @brief Enumerated speed */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DSTS_EERR_POS               = 3;    /** @brief Erratic error */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DSTS_FNSOF_POS              = 8;    /** @brief Frame number of the received SOF */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM_POS           = 0;    /** @brief Transfer completed interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_EPDM_POS            = 1;    /** @brief Endpoint disabled interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TOM_POS             = 3;    /** @brief Timeout condition mask (nonisochronous endpoints) */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK_POS       = 4;    /** @brief IN token received when txfifo empty mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM_POS         = 5;    /** @brief IN token received with EP mismatch mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM_POS         = 6;    /** @brief IN endpoint NAK effective mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM_POS          = 8;    /** @brief FIFO underrun mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPMSK_BIM_POS             = 9;    /** @brief BNA interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM_POS           = 0;    /** @brief Transfer completed interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_EPDM_POS            = 1;    /** @brief Endpoint disabled interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_STUPM_POS           = 3;    /** @brief SETUP phase done mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM_POS          = 4;    /** @brief OUT token received when endpoint disabled mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP_POS         = 6;    /** @brief Back-to-back SETUP packets received mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_OPEM_POS            = 8;    /** @brief OUT packet error mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPMSK_BOIM_POS            = 9;    /** @brief BNA interrupt mask */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DAINT_IEPINT_POS            = 0;    /** @brief IN endpoint interrupt bits */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DAINT_OEPINT_POS            = 16;   /** @brief OUT endpoint interrupt bits */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_IEPM_POS           = 0;    /** @brief IN EP interrupt mask bits */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DAINTMSK_OEPM_POS           = 16;   /** @brief OUT EP interrupt mask bits */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT_POS         = 0;    /** @brief Device VBUS discharge time */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP_POS       = 0;    /** @brief Device VBUS pulsing time */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN_POS     = 0;    /** @brief Nonisochronous IN endpoints threshold enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN_POS        = 1;    /** @brief ISO IN endpoint threshold enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN_POS        = 2;    /** @brief Transmit threshold length */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN_POS         = 16;   /** @brief Receive threshold enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN_POS        = 17;   /** @brief Receive threshold length */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN_POS           = 27;   /** @brief Arbiter parking enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM_POS    = 0;    /** @brief IN EP tx FIFO empty interrupt mask bits */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT_POS        = 1;    /** @brief IN endpoint 1interrupt bit */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT_POS        = 17;   /** @brief OUT endpoint 1 interrupt bit */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM_POS    = 1;    /** @brief IN endpoint 1 interrupt mask bit */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM_POS    = 17;   /** @brief OUT endpoint 1 interrupt mask bit */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_MPSIZ_POS          = 0;    /** @brief Maximum packet size */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_USBAEP_POS         = 15;   /** @brief USB active endpoint */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EONUM_DPID_POS     = 16;   /** @brief Even/odd frame */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_NAKSTS_POS         = 17;   /** @brief NAK status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPTYP_POS          = 18;   /** @brief Endpoint type */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_STALL_POS          = 21;   /** @brief STALL handshake */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_TXFNUM_POS         = 22;   /** @brief TxFIFO number */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_CNAK_POS           = 26;   /** @brief Clear NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SNAK_POS           = 27;   /** @brief Set NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SD0PID_SEVNFRM_POS = 28;   /** @brief Set DATA0 PID */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_SODDFRM_POS        = 29;   /** @brief Set odd frame */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPDIS_POS          = 30;   /** @brief Endpoint disable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPCTLx_EPENA_POS          = 31;   /** @brief Endpoint enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_XFRC_POS           = 0;    /** @brief Transfer completed interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_EPDISD_POS         = 1;    /** @brief Endpoint disabled interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TOC_POS            = 3;    /** @brief Timeout condition */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_ITTXFE_POS         = 4;    /** @brief IN token received when txfifo is empty */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_INEPNE_POS         = 6;    /** @brief IN endpoint NAK effective */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFE_POS           = 7;    /** @brief Transmit FIFO empty */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_TXFIFOUDRN_POS     = 8;    /** @brief Transmit fifo underrun */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BNA_POS            = 9;    /** @brief Buffer not available interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_PKTDRPSTS_POS      = 11;   /** @brief Packet dropped status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_BERR_POS           = 12;   /** @brief Babble error interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPINTx_NAK_POS            = 13;   /** @brief NAK interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_XFRSIZ_POS        = 0;    /** @brief Transfer size */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DIEPTSIZx_PKTCNT_POS        = 19;   /** @brief Packet count */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DTXFSTSx_INEPTFSAV_POS      = 0;    /** @brief IN endpoint txfifo space avail */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_MPSIZ_POS          = 0;    /** @brief Maximum packet size */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_USBAEP_POS         = 15;   /** @brief USB active endpoint */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_NAKSTS_POS         = 17;   /** @brief NAK status */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPTYP_POS          = 18;   /** @brief Endpoint type */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNPM_POS           = 20;   /** @brief Snoop mode */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_STALL_POS          = 21;   /** @brief STALL handshake */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_CNAK_POS           = 26;   /** @brief Clear NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_SNAK_POS           = 27;   /** @brief Set NAK */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPDIS_POS          = 30;   /** @brief Endpoint disable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPCTLx_EPENA_POS          = 31;   /** @brief Endpoint enable */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_XFRC_POS           = 0;    /** @brief Transfer completed interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_EPDISD_POS         = 1;    /** @brief Endpoint disabled interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_STUP_POS           = 3;    /** @brief SETUP phase done */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_OTEPDIS_POS        = 4;    /** @brief OUT token received when endpoint disabled */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_B2BSTUP_POS        = 6;    /** @brief Back-to-back SETUP packets received */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPINTx_NYET_POS           = 14;   /** @brief NYET interrupt */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_XFRSIZ_POS        = 0;    /** @brief Transfer size */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_PKTCNT_POS        = 19;   /** @brief Packet count */
  static const int32_t OTGx_HS_DEVICE_OTG_HS_DOEPTSIZx_STUPCNT_POS       = 29;   /** @brief SETUP packet count */

  /**********************************************************************************************
   * @section OTGx_HS_PWRCLK Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated OTGx_HS_PWRCLK Register Pointers ****/

  static RW_ uint32_t* const OTGx_HS_PWRCLK_OTG_HS_PCGCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40040E00U,   /** @brief Power and clock gating control register */
    [2] = (RW_ uint32_t* const)0x40080E00U,   /** @brief Power and clock gating control register */
  };

  /**** @subsection OTGx_HS_PWRCLK Register Field Masks ****/

  static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK_MSK  = 0x00000001U;   /** @brief Stop PHY clock */
  static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK_MSK = 0x00000002U;   /** @brief Gate HCLK */
  static const uint32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP_MSK  = 0x00000010U;   /** @brief PHY suspended */

  /**** @subsection OTGx_HS_PWRCLK Register Field Positions ****/

  static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK_POS  = 0;   /** @brief Stop PHY clock */
  static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK_POS = 1;   /** @brief Gate HCLK */
  static const int32_t OTGx_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP_POS  = 4;   /** @brief PHY suspended */

  /**********************************************************************************************
   * @section ETHERNET_MAC Register Information
   **********************************************************************************************/

  /**** @subsection ETHERNET_MAC Register Pointers ****/

  static RW_ uint32_t* const ETHERNET_MAC_DMAMR_PTR                              = (RW_ uint32_t* const)0x40029000U;   /** @brief DMA mode register */
  static RW_ uint32_t* const ETHERNET_MAC_DMASBMR_PTR                            = (RW_ uint32_t* const)0x40029004U;   /** @brief System bus mode register */
  static RO_ uint32_t* const ETHERNET_MAC_DMAISR_PTR                             = (RO_ uint32_t* const)0x40029008U;   /** @brief Interrupt status register */
  static RO_ uint32_t* const ETHERNET_MAC_DMADSR_PTR                             = (RO_ uint32_t* const)0x4002900CU;   /** @brief Debug status register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACCR_PTR                             = (RW_ uint32_t* const)0x40029100U;   /** @brief Channel control register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACTXCR_PTR                           = (RW_ uint32_t* const)0x40029104U;   /** @brief Channel transmit control register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACRXCR_PTR                           = (RW_ uint32_t* const)0x40029108U;   /** @brief Channel receive control register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACTXDLAR_PTR                         = (RW_ uint32_t* const)0x40029114U;   /** @brief Channel tx descriptor list address register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACRXDLAR_PTR                         = (RW_ uint32_t* const)0x4002911CU;   /** @brief Channel rx descriptor list address register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACTXDTPR_PTR                         = (RW_ uint32_t* const)0x40029120U;   /** @brief Channel tx descriptor tail pointer register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACRXDTPR_PTR                         = (RW_ uint32_t* const)0x40029128U;   /** @brief Channel rx descriptor tail pointer register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACTXRLR_PTR                          = (RW_ uint32_t* const)0x4002912CU;   /** @brief Channel tx descriptor ring length register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACRXRLR_PTR                          = (RW_ uint32_t* const)0x40029130U;   /** @brief Channel rx descriptor ring length register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACIER_PTR                            = (RW_ uint32_t* const)0x40029134U;   /** @brief Channel interrupt enable register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACRXIWTR_PTR                         = (RW_ uint32_t* const)0x40029138U;   /** @brief Channel rx interrupt watchdog timer register */
  static RO_ uint32_t* const ETHERNET_MAC_DMACCATXDR_PTR                         = (RO_ uint32_t* const)0x40029144U;   /** @brief Channel current application transmit descriptor register */
  static RO_ uint32_t* const ETHERNET_MAC_DMACCARXDR_PTR                         = (RO_ uint32_t* const)0x4002914CU;   /** @brief Channel current application receive descriptor register */
  static RO_ uint32_t* const ETHERNET_MAC_DMACCATXBR_PTR                         = (RO_ uint32_t* const)0x40029154U;   /** @brief Channel current application transmit buffer register */
  static RO_ uint32_t* const ETHERNET_MAC_DMACCARXBR_PTR                         = (RO_ uint32_t* const)0x4002915CU;   /** @brief Channel current application receive buffer register */
  static RW_ uint32_t* const ETHERNET_MAC_DMACSR_PTR                             = (RW_ uint32_t* const)0x40029160U;   /** @brief Channel status register */
  static RO_ uint32_t* const ETHERNET_MAC_DMACMFCR_PTR                           = (RO_ uint32_t* const)0x4002916CU;   /** @brief Channel missed frame count register */
  static RW_ uint32_t* const ETHERNET_MAC_MTLOMR_PTR                             = (RW_ uint32_t* const)0x40028C00U;   /** @brief Operating mode register */
  static RO_ uint32_t* const ETHERNET_MAC_MTLISR_PTR                             = (RO_ uint32_t* const)0x40028C20U;   /** @brief Interrupt status register */
  static RW_ uint32_t* const ETHERNET_MAC_MTLTXQOMR_PTR                          = (RW_ uint32_t* const)0x40028D00U;   /** @brief Tx queue operating mode register */
  static RO_ uint32_t* const ETHERNET_MAC_MTLTXQUR_PTR                           = (RO_ uint32_t* const)0x40028D04U;   /** @brief Tx queue underflow register */
  static RO_ uint32_t* const ETHERNET_MAC_MTLTXQDR_PTR                           = (RO_ uint32_t* const)0x40028D08U;   /** @brief Tx queue debug register */
  static RW_ uint32_t* const ETHERNET_MAC_MTLQICSR_PTR                           = (RW_ uint32_t* const)0x40028D2CU;   /** @brief Queue interrupt control status register */
  static RW_ uint32_t* const ETHERNET_MAC_MTLRXQOMR_PTR                          = (RW_ uint32_t* const)0x40028D30U;   /** @brief Rx queue operating mode register */
  static RO_ uint32_t* const ETHERNET_MAC_MTLRXQMPOCR_PTR                        = (RO_ uint32_t* const)0x40028D34U;   /** @brief Rx queue missed packet and overflow counter register */
  static RO_ uint32_t* const ETHERNET_MAC_MTLRXQDR_PTR                           = (RO_ uint32_t* const)0x40028D38U;   /** @brief Rx queue debug register */
  static RW_ uint32_t* const ETHERNET_MAC_MACCR_PTR                              = (RW_ uint32_t* const)0x40028000U;   /** @brief Operating mode configuration register */
  static RW_ uint32_t* const ETHERNET_MAC_MACECR_PTR                             = (RW_ uint32_t* const)0x40028004U;   /** @brief Extended operating mode configuration register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPFR_PTR                             = (RW_ uint32_t* const)0x40028008U;   /** @brief Packet filtering control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACWTR_PTR                             = (RW_ uint32_t* const)0x4002800CU;   /** @brief Watchdog timeout register */
  static RW_ uint32_t* const ETHERNET_MAC_MACVTR_PTR                             = (RW_ uint32_t* const)0x40028050U;   /** @brief VLAN tag register */
  static RW_ uint32_t* const ETHERNET_MAC_MACVHTR_PTR                            = (RW_ uint32_t* const)0x40028058U;   /** @brief VLAN hash table register */
  static RW_ uint32_t* const ETHERNET_MAC_MACVIR_PTR                             = (RW_ uint32_t* const)0x40028060U;   /** @brief VLAN inclusion register */
  static RW_ uint32_t* const ETHERNET_MAC_MACIVIR_PTR                            = (RW_ uint32_t* const)0x40028064U;   /** @brief Inner VLAN inclusion register */
  static RW_ uint32_t* const ETHERNET_MAC_MACQTXFCR_PTR                          = (RW_ uint32_t* const)0x40028070U;   /** @brief Tx queue flow control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACRXFCR_PTR                           = (RW_ uint32_t* const)0x40028090U;   /** @brief Rx flow control register */
  static RO_ uint32_t* const ETHERNET_MAC_MACISR_PTR                             = (RO_ uint32_t* const)0x400280B0U;   /** @brief Interrupt status register */
  static RW_ uint32_t* const ETHERNET_MAC_MACIER_PTR                             = (RW_ uint32_t* const)0x400280B4U;   /** @brief Interrupt enable register */
  static RO_ uint32_t* const ETHERNET_MAC_MACRXTXSR_PTR                          = (RO_ uint32_t* const)0x400280B8U;   /** @brief Rx tx status register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPCSR_PTR                            = (RW_ uint32_t* const)0x400280C0U;   /** @brief PMT control status register */
  static RW_ uint32_t* const ETHERNET_MAC_MACRWKPFR_PTR                          = (RW_ uint32_t* const)0x400280C4U;   /** @brief Remove wakeup packet filter register */
  static RW_ uint32_t* const ETHERNET_MAC_MACLCSR_PTR                            = (RW_ uint32_t* const)0x400280D0U;   /** @brief LPI control status register */
  static RW_ uint32_t* const ETHERNET_MAC_MACLTCR_PTR                            = (RW_ uint32_t* const)0x400280D4U;   /** @brief LPI timers control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACLETR_PTR                            = (RW_ uint32_t* const)0x400280D8U;   /** @brief LPI entry timer register */
  static RW_ uint32_t* const ETHERNET_MAC_MAC1USTCR_PTR                          = (RW_ uint32_t* const)0x400280DCU;   /** @brief 1-microsecond-tick counter register */
  static RO_ uint32_t* const ETHERNET_MAC_MACVR_PTR                              = (RO_ uint32_t* const)0x40028110U;   /** @brief Version register */
  static RW_ uint32_t* const ETHERNET_MAC_MACMDIOAR_PTR                          = (RW_ uint32_t* const)0x40028200U;   /** @brief MDIO address register */
  static RW_ uint32_t* const ETHERNET_MAC_MACMDIODR_PTR                          = (RW_ uint32_t* const)0x40028204U;   /** @brief MDIO data register */
  static RW_ uint32_t* const ETHERNET_MAC_MACARPAR_PTR                           = (RW_ uint32_t* const)0x40028AE0U;   /** @brief ARP address register */
  static RW_ uint32_t* const ETHERNET_MAC_MMC_CONTROL_PTR                        = (RW_ uint32_t* const)0x40028700U;   /** @brief MMC control register */
  static RO_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_PTR                   = (RO_ uint32_t* const)0x40028704U;   /** @brief MMC rx interrupt register */
  static RO_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_PTR                   = (RO_ uint32_t* const)0x40028708U;   /** @brief MMC tx interrupt register */
  static RW_ uint32_t* const ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_PTR              = (RW_ uint32_t* const)0x4002870CU;   /** @brief MMC rx interrupt mask register */
  static RW_ uint32_t* const ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_PTR              = (RW_ uint32_t* const)0x40028710U;   /** @brief MMC tx interrupt mask register */
  static RO_ uint32_t* const ETHERNET_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_PTR   = (RO_ uint32_t* const)0x4002874CU;   /** @brief Tx single collision good packets register */
  static RO_ uint32_t* const ETHERNET_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_PTR = (RO_ uint32_t* const)0x40028750U;   /** @brief Tx multiple collision good packets register */
  static RO_ uint32_t* const ETHERNET_MAC_TX_PACKET_COUNT_GOOD_PTR               = (RO_ uint32_t* const)0x40028768U;   /** @brief Tx packet count good register */
  static RO_ uint32_t* const ETHERNET_MAC_RX_CRC_ERROR_PACKETS_PTR               = (RO_ uint32_t* const)0x40028794U;   /** @brief Rx CRC error packets register */
  static RO_ uint32_t* const ETHERNET_MAC_RX_ALIGNMENT_ERROR_PACKETS_PTR         = (RO_ uint32_t* const)0x40028798U;   /** @brief Rx alignment error packets register */
  static RO_ uint32_t* const ETHERNET_MAC_RX_UNICAST_PACKETS_GOOD_PTR            = (RO_ uint32_t* const)0x400287C4U;   /** @brief Rx unicast packets good register */
  static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_USEC_CNTR_PTR                   = (RO_ uint32_t* const)0x400287ECU;   /** @brief Tx LPI microsecond timer register */
  static RO_ uint32_t* const ETHERNET_MAC_TX_LPI_TRAN_CNTR_PTR                   = (RO_ uint32_t* const)0x400287F0U;   /** @brief Tx LPI transition counter register */
  static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_USEC_CNTR_PTR                   = (RO_ uint32_t* const)0x400287F4U;   /** @brief Rx LPI microsecond counter register */
  static RO_ uint32_t* const ETHERNET_MAC_RX_LPI_TRAN_CNTR_PTR                   = (RO_ uint32_t* const)0x400287F8U;   /** @brief Rx LPI transition counter register */
  static RO_ uint32_t* const ETHERNET_MAC_MACDR_PTR                              = (RO_ uint32_t* const)0x40028114U;   /** @brief Debug register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSCR_PTR                            = (RW_ uint32_t* const)0x40028B00U;   /** @brief Timestamp control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACSSIR_PTR                            = (RW_ uint32_t* const)0x40028B04U;   /** @brief Sub-second increment register */
  static RO_ uint32_t* const ETHERNET_MAC_MACSTSR_PTR                            = (RO_ uint32_t* const)0x40028B08U;   /** @brief System time seconds register */
  static RO_ uint32_t* const ETHERNET_MAC_MACSTNR_PTR                            = (RO_ uint32_t* const)0x40028B0CU;   /** @brief System time nanoseconds register */
  static RW_ uint32_t* const ETHERNET_MAC_MACSTSUR_PTR                           = (RW_ uint32_t* const)0x40028B10U;   /** @brief System time seconds update register */
  static RW_ uint32_t* const ETHERNET_MAC_MACSTNUR_PTR                           = (RW_ uint32_t* const)0x40028B14U;   /** @brief System time nanoseconds update register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSAR_PTR                            = (RW_ uint32_t* const)0x40028B18U;   /** @brief Timestamp addend register */
  static RO_ uint32_t* const ETHERNET_MAC_MACTSSR_PTR                            = (RO_ uint32_t* const)0x40028B20U;   /** @brief Timestamp status register */
  static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSNR_PTR                         = (RO_ uint32_t* const)0x40028B30U;   /** @brief Tx timestamp status nanoseconds register */
  static RO_ uint32_t* const ETHERNET_MAC_MACTXTSSSR_PTR                         = (RO_ uint32_t* const)0x40028B34U;   /** @brief Tx timestamp status seconds register */
  static RW_ uint32_t* const ETHERNET_MAC_MACACR_PTR                             = (RW_ uint32_t* const)0x40028B40U;   /** @brief Auxiliary control register */
  static RO_ uint32_t* const ETHERNET_MAC_MACATSNR_PTR                           = (RO_ uint32_t* const)0x40028B48U;   /** @brief Auxiliary timestamp nanoseconds register */
  static RO_ uint32_t* const ETHERNET_MAC_MACATSSR_PTR                           = (RO_ uint32_t* const)0x40028B4CU;   /** @brief Auxiliary timestamp seconds register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSIACR_PTR                          = (RW_ uint32_t* const)0x40028B50U;   /** @brief Timestamp ingress asymmetric correction register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSEACR_PTR                          = (RW_ uint32_t* const)0x40028B54U;   /** @brief Timestamp egress asymmetric correction register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSICNR_PTR                          = (RW_ uint32_t* const)0x40028B58U;   /** @brief Timestamp ingress correction nanosecond register */
  static RW_ uint32_t* const ETHERNET_MAC_MACTSECNR_PTR                          = (RW_ uint32_t* const)0x40028B5CU;   /** @brief Timestamp egress correction nanosecond register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPPSCR_PTR                           = (RW_ uint32_t* const)0x40028B70U;   /** @brief PPS control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTSR_PTR                         = (RW_ uint32_t* const)0x40028B80U;   /** @brief PPS target time seconds register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPPSTTNR_PTR                         = (RW_ uint32_t* const)0x40028B84U;   /** @brief PPS target time nanoseconds register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPPSIR_PTR                           = (RW_ uint32_t* const)0x40028B88U;   /** @brief PPS interval register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPPSWR_PTR                           = (RW_ uint32_t* const)0x40028B8CU;   /** @brief PPS width register */
  static RW_ uint32_t* const ETHERNET_MAC_MACPOCR_PTR                            = (RW_ uint32_t* const)0x40028BC0U;   /** @brief PTP offload control register */
  static RW_ uint32_t* const ETHERNET_MAC_MACLMIR_PTR                            = (RW_ uint32_t* const)0x40028BD0U;   /** @brief Log message interval register */

  /**** @subsection Enumerated ETHERNET_MAC Register Pointers ****/

  static RW_ uint32_t* const ETHERNET_MAC_MACHTxR_PTR[2] = {
    [0] = (RW_ uint32_t* const)0x40028010U,   /** @brief Hash table 0 register */
    [1] = (RW_ uint32_t* const)0x40028014U,   /** @brief Hash table 1 register */
  };

  static RO_ uint32_t* const ETHERNET_MAC_MACHWFxR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40028120U,   /** @brief HW feature 1 register */
    [2] = (RO_ uint32_t* const)0x40028124U,   /** @brief HW feature 2 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACAxHR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x40028300U,   /** @brief Address 0 high register */
    [1] = (RW_ uint32_t* const)0x40028308U,   /** @brief Address 1 high register */
    [2] = (RW_ uint32_t* const)0x40028310U,   /** @brief Address 2 high register */
    [3] = (RW_ uint32_t* const)0x40028318U,   /** @brief Address 3 high register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACAxLR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x40028304U,   /** @brief Address 0 low register */
    [1] = (RW_ uint32_t* const)0x4002830CU,   /** @brief Address 1 low register */
    [2] = (RW_ uint32_t* const)0x40028314U,   /** @brief Address 2 low register */
    [3] = (RW_ uint32_t* const)0x4002831CU,   /** @brief Address 3 low register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACL3L4CxR_PTR[2] = {
    [0] = (RW_ uint32_t* const)0x40028900U,   /** @brief L3 and L4 control 0 register */
    [1] = (RW_ uint32_t* const)0x40028930U,   /** @brief L3 and L4 control 1 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACL4AxR_PTR[2] = {
    [0] = (RW_ uint32_t* const)0x40028904U,   /** @brief Layer4 address filter 0 register */
    [1] = (RW_ uint32_t* const)0x40028934U,   /** @brief Layer 4 address filter 1 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACL3AxR_PTR[32] = {
    [0]  = (RW_ uint32_t* const)0x40028910U,   /** @brief MACL3A00R */
    [10] = (RW_ uint32_t* const)0x40028914U,   /** @brief Layer3 address 1 filter 0 register */
    [11] = (RW_ uint32_t* const)0x40028944U,   /** @brief Layer3 address 1 filter 1 register */
    [21] = (RW_ uint32_t* const)0x40028948U,   /** @brief Layer3 address 2 filter 1 register */
    [31] = (RW_ uint32_t* const)0x4002894CU,   /** @brief Layer3 address 3 filter 1 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACL3Ax_PTR[31] = {
    [20] = (RW_ uint32_t* const)0x40028918U,   /** @brief Layer3 address 2 filter 0 register */
    [30] = (RW_ uint32_t* const)0x4002891CU,   /** @brief Layer3 address 3 filter 0 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACL3A0xR_PTR[2] = {
    [1] = (RW_ uint32_t* const)0x40028940U,   /** @brief Layer3 address 0 filter 1 register */
  };

  static RW_ uint32_t* const ETHERNET_MAC_MACSPIxR_PTR[3] = {
    [0] = (RW_ uint32_t* const)0x40028BC4U,   /** @brief PTP source port identity 0 register */
    [1] = (RW_ uint32_t* const)0x40028BC8U,   /** @brief PTP source port identity 1 register */
    [2] = (RW_ uint32_t* const)0x40028BCCU,   /** @brief PTP source port identity 2 register */
  };

  /**** @subsection ETHERNET_MAC Register Field Masks ****/

  static const uint32_t ETHERNET_MAC_DMAMR_SWR_MSK                         = 0x00000001U;   /** @brief Software reset */
  static const uint32_t ETHERNET_MAC_DMAMR_DA_MSK                          = 0x00000002U;   /** @brief DMA tx or rx arbitration scheme */
  static const uint32_t ETHERNET_MAC_DMAMR_TXPR_MSK                        = 0x00000800U;   /** @brief Transmit priority */
  static const uint32_t ETHERNET_MAC_DMAMR_PR_MSK                          = 0x00007000U;   /** @brief Priority ratio */
  static const uint32_t ETHERNET_MAC_DMAMR_INTM_MSK                        = 0x00010000U;   /** @brief Interrupt mode */
  static const uint32_t ETHERNET_MAC_DMASBMR_FB_MSK                        = 0x00000001U;   /** @brief Fixed burst length */
  static const uint32_t ETHERNET_MAC_DMASBMR_AAL_MSK                       = 0x00001000U;   /** @brief Address-Aligned beats */
  static const uint32_t ETHERNET_MAC_DMASBMR_MB_MSK                        = 0x00004000U;   /** @brief Mixed burst */
  static const uint32_t ETHERNET_MAC_DMASBMR_RB_MSK                        = 0x00008000U;   /** @brief Rebuild incrx burst */
  static const uint32_t ETHERNET_MAC_DMAISR_DC0IS_MSK                      = 0x00000001U;   /** @brief DMA channel interrupt status */
  static const uint32_t ETHERNET_MAC_DMAISR_MTLIS_MSK                      = 0x00010000U;   /** @brief MTL interrupt status */
  static const uint32_t ETHERNET_MAC_DMAISR_MACIS_MSK                      = 0x00020000U;   /** @brief MAC interrupt status */
  static const uint32_t ETHERNET_MAC_DMADSR_AXWHSTS_MSK                    = 0x00000001U;   /** @brief AHB master write channel */
  static const uint32_t ETHERNET_MAC_DMADSR_RPS0_MSK                       = 0x00000F00U;   /** @brief DMA channel receive process state */
  static const uint32_t ETHERNET_MAC_DMADSR_TPS0_MSK                       = 0x0000F000U;   /** @brief DMA channel transmit process state */
  static const uint32_t ETHERNET_MAC_DMACCR_MSS_MSK                        = 0x00003FFFU;   /** @brief Maximum segment size */
  static const uint32_t ETHERNET_MAC_DMACCR_PBLX8_MSK                      = 0x00010000U;   /** @brief 8xPBL mode */
  static const uint32_t ETHERNET_MAC_DMACCR_DSL_MSK                        = 0x001C0000U;   /** @brief Descriptor skip length */
  static const uint32_t ETHERNET_MAC_DMACTXCR_ST_MSK                       = 0x00000001U;   /** @brief Start or stop transmission command */
  static const uint32_t ETHERNET_MAC_DMACTXCR_OSF_MSK                      = 0x00000010U;   /** @brief Operate on second packet */
  static const uint32_t ETHERNET_MAC_DMACTXCR_TSE_MSK                      = 0x00001000U;   /** @brief TCP segmentation enabled */
  static const uint32_t ETHERNET_MAC_DMACTXCR_TXPBL_MSK                    = 0x003F0000U;   /** @brief Transmit programmable burst length */
  static const uint32_t ETHERNET_MAC_DMACRXCR_SR_MSK                       = 0x00000001U;   /** @brief Start or stop receive command */
  static const uint32_t ETHERNET_MAC_DMACRXCR_RBSZ_MSK                     = 0x00007FFEU;   /** @brief Receive buffer size */
  static const uint32_t ETHERNET_MAC_DMACRXCR_RXPBL_MSK                    = 0x003F0000U;   /** @brief RXPBL */
  static const uint32_t ETHERNET_MAC_DMACRXCR_RPF_MSK                      = 0x80000000U;   /** @brief DMA rx channel packet flush */
  static const uint32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_MSK                 = 0xFFFFFFFCU;   /** @brief Start of transmit list */
  static const uint32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_MSK                 = 0xFFFFFFFCU;   /** @brief Start of receive list */
  static const uint32_t ETHERNET_MAC_DMACTXDTPR_TDT_MSK                    = 0xFFFFFFFCU;   /** @brief Transmit descriptor tail pointer */
  static const uint32_t ETHERNET_MAC_DMACRXDTPR_RDT_MSK                    = 0xFFFFFFFCU;   /** @brief Receive descriptor tail pointer */
  static const uint32_t ETHERNET_MAC_DMACTXRLR_TDRL_MSK                    = 0x000003FFU;   /** @brief Transmit descriptor ring length */
  static const uint32_t ETHERNET_MAC_DMACRXRLR_RDRL_MSK                    = 0x000003FFU;   /** @brief Receive descriptor ring length */
  static const uint32_t ETHERNET_MAC_DMACIER_TIE_MSK                       = 0x00000001U;   /** @brief Transmit interrupt enable */
  static const uint32_t ETHERNET_MAC_DMACIER_TXSE_MSK                      = 0x00000002U;   /** @brief Transmit stopped enable */
  static const uint32_t ETHERNET_MAC_DMACIER_TBUE_MSK                      = 0x00000004U;   /** @brief Transmit buffer unavailable enable */
  static const uint32_t ETHERNET_MAC_DMACIER_RIE_MSK                       = 0x00000040U;   /** @brief Receive interrupt enable */
  static const uint32_t ETHERNET_MAC_DMACIER_RBUE_MSK                      = 0x00000080U;   /** @brief Receive buffer unavailable enable */
  static const uint32_t ETHERNET_MAC_DMACIER_RSE_MSK                       = 0x00000100U;   /** @brief Receive stopped enable */
  static const uint32_t ETHERNET_MAC_DMACIER_RWTE_MSK                      = 0x00000200U;   /** @brief Receive watchdog timeout enable */
  static const uint32_t ETHERNET_MAC_DMACIER_ETIE_MSK                      = 0x00000400U;   /** @brief Early transmit interrupt enable */
  static const uint32_t ETHERNET_MAC_DMACIER_ERIE_MSK                      = 0x00000800U;   /** @brief Early receive interrupt enable */
  static const uint32_t ETHERNET_MAC_DMACIER_FBEE_MSK                      = 0x00001000U;   /** @brief Fatal bus error enable */
  static const uint32_t ETHERNET_MAC_DMACIER_CDEE_MSK                      = 0x00002000U;   /** @brief Context descriptor error enable */
  static const uint32_t ETHERNET_MAC_DMACIER_AIE_MSK                       = 0x00004000U;   /** @brief Abnormal interrupt summary enable */
  static const uint32_t ETHERNET_MAC_DMACIER_NIE_MSK                       = 0x00008000U;   /** @brief Normal interrupt summary enable */
  static const uint32_t ETHERNET_MAC_DMACRXIWTR_RWT_MSK                    = 0x000000FFU;   /** @brief Receive interrupt watchdog timer count */
  static const uint32_t ETHERNET_MAC_DMACSR_TI_MSK                         = 0x00000001U;   /** @brief Transmit interrupt */
  static const uint32_t ETHERNET_MAC_DMACSR_TPS_MSK                        = 0x00000002U;   /** @brief Transmit process stopped */
  static const uint32_t ETHERNET_MAC_DMACSR_TBU_MSK                        = 0x00000004U;   /** @brief Transmit buffer unavailable */
  static const uint32_t ETHERNET_MAC_DMACSR_RI_MSK                         = 0x00000040U;   /** @brief Receive interrupt */
  static const uint32_t ETHERNET_MAC_DMACSR_RBU_MSK                        = 0x00000080U;   /** @brief Receive buffer unavailable */
  static const uint32_t ETHERNET_MAC_DMACSR_RPS_MSK                        = 0x00000100U;   /** @brief Receive process stopped */
  static const uint32_t ETHERNET_MAC_DMACSR_RWT_MSK                        = 0x00000200U;   /** @brief Receive watchdog timeout */
  static const uint32_t ETHERNET_MAC_DMACSR_ET_MSK                         = 0x00000400U;   /** @brief Early transmit interrupt */
  static const uint32_t ETHERNET_MAC_DMACSR_ER_MSK                         = 0x00000800U;   /** @brief Early receive interrupt */
  static const uint32_t ETHERNET_MAC_DMACSR_FBE_MSK                        = 0x00001000U;   /** @brief Fatal bus error */
  static const uint32_t ETHERNET_MAC_DMACSR_CDE_MSK                        = 0x00002000U;   /** @brief Context descriptor error */
  static const uint32_t ETHERNET_MAC_DMACSR_AIS_MSK                        = 0x00004000U;   /** @brief Abnormal interrupt summary */
  static const uint32_t ETHERNET_MAC_DMACSR_NIS_MSK                        = 0x00008000U;   /** @brief Normal interrupt summary */
  static const uint32_t ETHERNET_MAC_DMACSR_TEB_MSK                        = 0x00070000U;   /** @brief Tx DMA error bits */
  static const uint32_t ETHERNET_MAC_DMACSR_REB_MSK                        = 0x00380000U;   /** @brief Rx DMA error bits */
  static const uint32_t ETHERNET_MAC_DMACMFCR_MFC_MSK                      = 0x000007FFU;   /** @brief Dropped packet counters */
  static const uint32_t ETHERNET_MAC_DMACMFCR_MFCO_MSK                     = 0x00008000U;   /** @brief Overflow status of the MFC counter */
  static const uint32_t ETHERNET_MAC_MTLOMR_DTXSTS_MSK                     = 0x00000002U;   /** @brief DTXSTS */
  static const uint32_t ETHERNET_MAC_MTLOMR_CNTPRST_MSK                    = 0x00000100U;   /** @brief CNTPRST */
  static const uint32_t ETHERNET_MAC_MTLOMR_CNTCLR_MSK                     = 0x00000200U;   /** @brief CNTCLR */
  static const uint32_t ETHERNET_MAC_MTLISR_Q0IS_MSK                       = 0x00000001U;   /** @brief Queue interrupt status */
  static const uint32_t ETHERNET_MAC_MTLTXQOMR_FTQ_MSK                     = 0x00000001U;   /** @brief Flush transmit queue */
  static const uint32_t ETHERNET_MAC_MTLTXQOMR_TSF_MSK                     = 0x00000002U;   /** @brief Transmit store and forward */
  static const uint32_t ETHERNET_MAC_MTLTXQOMR_TXQEN_MSK                   = 0x0000000CU;   /** @brief Transmit queue enable */
  static const uint32_t ETHERNET_MAC_MTLTXQOMR_TTC_MSK                     = 0x00000070U;   /** @brief Transmit threshold control */
  static const uint32_t ETHERNET_MAC_MTLTXQOMR_TQS_MSK                     = 0x01FF0000U;   /** @brief Transmit queue size */
  static const uint32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT_MSK                 = 0x000007FFU;   /** @brief Underflow packet counter */
  static const uint32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_MSK                 = 0x00000800U;   /** @brief UFCNTOVF */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED_MSK                = 0x00000001U;   /** @brief TXQPAUSED */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_TRCSTS_MSK                   = 0x00000006U;   /** @brief TRCSTS */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_TWCSTS_MSK                   = 0x00000008U;   /** @brief TWCSTS */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_TXQSTS_MSK                   = 0x00000010U;   /** @brief TXQSTS */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS_MSK                = 0x00000020U;   /** @brief TXSTSFSTS */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_PTXQ_MSK                     = 0x00070000U;   /** @brief PTXQ */
  static const uint32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_MSK                  = 0x00700000U;   /** @brief STXSTSF */
  static const uint32_t ETHERNET_MAC_MTLQICSR_TXUNFIS_MSK                  = 0x00000001U;   /** @brief TXUNFIS */
  static const uint32_t ETHERNET_MAC_MTLQICSR_TXUIE_MSK                    = 0x00000100U;   /** @brief TXUIE */
  static const uint32_t ETHERNET_MAC_MTLQICSR_RXOVFIS_MSK                  = 0x00010000U;   /** @brief RXOVFIS */
  static const uint32_t ETHERNET_MAC_MTLQICSR_RXOIE_MSK                    = 0x01000000U;   /** @brief RXOIE */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_RTC_MSK                     = 0x00000003U;   /** @brief RTC */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_FUP_MSK                     = 0x00000008U;   /** @brief FUP */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_FEP_MSK                     = 0x00000010U;   /** @brief FEP */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_RSF_MSK                     = 0x00000020U;   /** @brief RSF */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF_MSK              = 0x00000040U;   /** @brief DIS_TCP_EF */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_EHFC_MSK                    = 0x00000080U;   /** @brief EHFC */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFA_MSK                     = 0x00000700U;   /** @brief RFA */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_RFD_MSK                     = 0x0001C000U;   /** @brief RFD */
  static const uint32_t ETHERNET_MAC_MTLRXQOMR_RQS_MSK                     = 0x00700000U;   /** @brief RQS */
  static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT_MSK             = 0x000007FFU;   /** @brief OVFPKTCNT */
  static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF_MSK             = 0x00000800U;   /** @brief OVFCNTOVF */
  static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT_MSK             = 0x07FF0000U;   /** @brief MISPKTCNT */
  static const uint32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_MSK             = 0x08000000U;   /** @brief MISCNTOVF */
  static const uint32_t ETHERNET_MAC_MTLRXQDR_RWCSTS_MSK                   = 0x00000001U;   /** @brief RWCSTS */
  static const uint32_t ETHERNET_MAC_MTLRXQDR_RRCSTS_MSK                   = 0x00000006U;   /** @brief RRCSTS */
  static const uint32_t ETHERNET_MAC_MTLRXQDR_RXQSTS_MSK                   = 0x00000030U;   /** @brief RXQSTS */
  static const uint32_t ETHERNET_MAC_MTLRXQDR_PRXQ_MSK                     = 0x3FFF0000U;   /** @brief PRXQ */
  static const uint32_t ETHERNET_MAC_MACCR_RE_MSK                          = 0x00000001U;   /** @brief Receiver enable */
  static const uint32_t ETHERNET_MAC_MACCR_TE_MSK                          = 0x00000002U;   /** @brief TE */
  static const uint32_t ETHERNET_MAC_MACCR_PRELEN_MSK                      = 0x0000000CU;   /** @brief PRELEN */
  static const uint32_t ETHERNET_MAC_MACCR_DC_MSK                          = 0x00000010U;   /** @brief DC */
  static const uint32_t ETHERNET_MAC_MACCR_BL_MSK                          = 0x00000060U;   /** @brief BL */
  static const uint32_t ETHERNET_MAC_MACCR_DR_MSK                          = 0x00000100U;   /** @brief DR */
  static const uint32_t ETHERNET_MAC_MACCR_DCRS_MSK                        = 0x00000200U;   /** @brief DCRS */
  static const uint32_t ETHERNET_MAC_MACCR_DO_MSK                          = 0x00000400U;   /** @brief DO */
  static const uint32_t ETHERNET_MAC_MACCR_ECRSFD_MSK                      = 0x00000800U;   /** @brief ECRSFD */
  static const uint32_t ETHERNET_MAC_MACCR_LM_MSK                          = 0x00001000U;   /** @brief LM */
  static const uint32_t ETHERNET_MAC_MACCR_DM_MSK                          = 0x00002000U;   /** @brief DM */
  static const uint32_t ETHERNET_MAC_MACCR_FES_MSK                         = 0x00004000U;   /** @brief FES */
  static const uint32_t ETHERNET_MAC_MACCR_JE_MSK                          = 0x00010000U;   /** @brief JE */
  static const uint32_t ETHERNET_MAC_MACCR_JD_MSK                          = 0x00020000U;   /** @brief JD */
  static const uint32_t ETHERNET_MAC_MACCR_WD_MSK                          = 0x00080000U;   /** @brief WD */
  static const uint32_t ETHERNET_MAC_MACCR_ACS_MSK                         = 0x00100000U;   /** @brief ACS */
  static const uint32_t ETHERNET_MAC_MACCR_CST_MSK                         = 0x00200000U;   /** @brief CST */
  static const uint32_t ETHERNET_MAC_MACCR_S2KP_MSK                        = 0x00400000U;   /** @brief S2KP */
  static const uint32_t ETHERNET_MAC_MACCR_GPSLCE_MSK                      = 0x00800000U;   /** @brief GPSLCE */
  static const uint32_t ETHERNET_MAC_MACCR_IPG_MSK                         = 0x07000000U;   /** @brief IPG */
  static const uint32_t ETHERNET_MAC_MACCR_IPC_MSK                         = 0x08000000U;   /** @brief IPC */
  static const uint32_t ETHERNET_MAC_MACCR_SARC_MSK                        = 0x70000000U;   /** @brief SARC */
  static const uint32_t ETHERNET_MAC_MACCR_ARPEN_MSK                       = 0x80000000U;   /** @brief ARPEN */
  static const uint32_t ETHERNET_MAC_MACECR_GPSL_MSK                       = 0x00003FFFU;   /** @brief GPSL */
  static const uint32_t ETHERNET_MAC_MACECR_DCRCC_MSK                      = 0x00010000U;   /** @brief DCRCC */
  static const uint32_t ETHERNET_MAC_MACECR_SPEN_MSK                       = 0x00020000U;   /** @brief SPEN */
  static const uint32_t ETHERNET_MAC_MACECR_USP_MSK                        = 0x00040000U;   /** @brief USP */
  static const uint32_t ETHERNET_MAC_MACECR_EIPGEN_MSK                     = 0x01000000U;   /** @brief EIPGEN */
  static const uint32_t ETHERNET_MAC_MACECR_EIPG_MSK                       = 0x3E000000U;   /** @brief EIPG */
  static const uint32_t ETHERNET_MAC_MACPFR_PR_MSK                         = 0x00000001U;   /** @brief PR */
  static const uint32_t ETHERNET_MAC_MACPFR_HUC_MSK                        = 0x00000002U;   /** @brief HUC */
  static const uint32_t ETHERNET_MAC_MACPFR_HMC_MSK                        = 0x00000004U;   /** @brief HMC */
  static const uint32_t ETHERNET_MAC_MACPFR_DAIF_MSK                       = 0x00000008U;   /** @brief DAIF */
  static const uint32_t ETHERNET_MAC_MACPFR_PM_MSK                         = 0x00000010U;   /** @brief PM */
  static const uint32_t ETHERNET_MAC_MACPFR_DBF_MSK                        = 0x00000020U;   /** @brief DBF */
  static const uint32_t ETHERNET_MAC_MACPFR_PCF_MSK                        = 0x000000C0U;   /** @brief PCF */
  static const uint32_t ETHERNET_MAC_MACPFR_SAIF_MSK                       = 0x00000100U;   /** @brief SAIF */
  static const uint32_t ETHERNET_MAC_MACPFR_SAF_MSK                        = 0x00000200U;   /** @brief SAF */
  static const uint32_t ETHERNET_MAC_MACPFR_HPF_MSK                        = 0x00000400U;   /** @brief HPF */
  static const uint32_t ETHERNET_MAC_MACPFR_VTFE_MSK                       = 0x00010000U;   /** @brief VTFE */
  static const uint32_t ETHERNET_MAC_MACPFR_IPFE_MSK                       = 0x00100000U;   /** @brief IPFE */
  static const uint32_t ETHERNET_MAC_MACPFR_DNTU_MSK                       = 0x00200000U;   /** @brief DNTU */
  static const uint32_t ETHERNET_MAC_MACPFR_RA_MSK                         = 0x80000000U;   /** @brief RA */
  static const uint32_t ETHERNET_MAC_MACWTR_WTO_MSK                        = 0x0000000FU;   /** @brief WTO */
  static const uint32_t ETHERNET_MAC_MACWTR_PWE_MSK                        = 0x00000100U;   /** @brief PWE */
  static const uint32_t ETHERNET_MAC_MACVTR_VL_MSK                         = 0x0000FFFFU;   /** @brief VL */
  static const uint32_t ETHERNET_MAC_MACVTR_ETV_MSK                        = 0x00010000U;   /** @brief ETV */
  static const uint32_t ETHERNET_MAC_MACVTR_VTIM_MSK                       = 0x00020000U;   /** @brief VTIM */
  static const uint32_t ETHERNET_MAC_MACVTR_ESVL_MSK                       = 0x00040000U;   /** @brief ESVL */
  static const uint32_t ETHERNET_MAC_MACVTR_ERSVLM_MSK                     = 0x00080000U;   /** @brief ERSVLM */
  static const uint32_t ETHERNET_MAC_MACVTR_DOVLTC_MSK                     = 0x00100000U;   /** @brief DOVLTC */
  static const uint32_t ETHERNET_MAC_MACVTR_EVLS_MSK                       = 0x00600000U;   /** @brief EVLS */
  static const uint32_t ETHERNET_MAC_MACVTR_EVLRXS_MSK                     = 0x01000000U;   /** @brief EVLRXS */
  static const uint32_t ETHERNET_MAC_MACVTR_VTHM_MSK                       = 0x02000000U;   /** @brief VTHM */
  static const uint32_t ETHERNET_MAC_MACVTR_EDVLP_MSK                      = 0x04000000U;   /** @brief EDVLP */
  static const uint32_t ETHERNET_MAC_MACVTR_ERIVLT_MSK                     = 0x08000000U;   /** @brief ERIVLT */
  static const uint32_t ETHERNET_MAC_MACVTR_EIVLS_MSK                      = 0x30000000U;   /** @brief EIVLS */
  static const uint32_t ETHERNET_MAC_MACVTR_EIVLRXS_MSK                    = 0x80000000U;   /** @brief EIVLRXS */
  static const uint32_t ETHERNET_MAC_MACVHTR_VLHT_MSK                      = 0x0000FFFFU;   /** @brief VLHT */
  static const uint32_t ETHERNET_MAC_MACVIR_VLT_MSK                        = 0x0000FFFFU;   /** @brief VLT */
  static const uint32_t ETHERNET_MAC_MACVIR_VLC_MSK                        = 0x00030000U;   /** @brief VLC */
  static const uint32_t ETHERNET_MAC_MACVIR_VLP_MSK                        = 0x00040000U;   /** @brief VLP */
  static const uint32_t ETHERNET_MAC_MACVIR_CSVL_MSK                       = 0x00080000U;   /** @brief CSVL */
  static const uint32_t ETHERNET_MAC_MACVIR_VLTI_MSK                       = 0x00100000U;   /** @brief VLTI */
  static const uint32_t ETHERNET_MAC_MACIVIR_VLT_MSK                       = 0x0000FFFFU;   /** @brief VLT */
  static const uint32_t ETHERNET_MAC_MACIVIR_VLC_MSK                       = 0x00030000U;   /** @brief VLC */
  static const uint32_t ETHERNET_MAC_MACIVIR_VLP_MSK                       = 0x00040000U;   /** @brief VLP */
  static const uint32_t ETHERNET_MAC_MACIVIR_CSVL_MSK                      = 0x00080000U;   /** @brief CSVL */
  static const uint32_t ETHERNET_MAC_MACIVIR_VLTI_MSK                      = 0x00100000U;   /** @brief VLTI */
  static const uint32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA_MSK                 = 0x00000001U;   /** @brief FCB_BPA */
  static const uint32_t ETHERNET_MAC_MACQTXFCR_TFE_MSK                     = 0x00000002U;   /** @brief TFE */
  static const uint32_t ETHERNET_MAC_MACQTXFCR_PLT_MSK                     = 0x00000070U;   /** @brief PLT */
  static const uint32_t ETHERNET_MAC_MACQTXFCR_DZPQ_MSK                    = 0x00000080U;   /** @brief DZPQ */
  static const uint32_t ETHERNET_MAC_MACQTXFCR_PT_MSK                      = 0xFFFF0000U;   /** @brief PT */
  static const uint32_t ETHERNET_MAC_MACRXFCR_RFE_MSK                      = 0x00000001U;   /** @brief RFE */
  static const uint32_t ETHERNET_MAC_MACRXFCR_UP_MSK                       = 0x00000002U;   /** @brief UP */
  static const uint32_t ETHERNET_MAC_MACISR_PHYIS_MSK                      = 0x00000008U;   /** @brief PHYIS */
  static const uint32_t ETHERNET_MAC_MACISR_PMTIS_MSK                      = 0x00000010U;   /** @brief PMTIS */
  static const uint32_t ETHERNET_MAC_MACISR_LPIIS_MSK                      = 0x00000020U;   /** @brief LPIIS */
  static const uint32_t ETHERNET_MAC_MACISR_MMCIS_MSK                      = 0x00000100U;   /** @brief MMCIS */
  static const uint32_t ETHERNET_MAC_MACISR_MMCRXIS_MSK                    = 0x00000200U;   /** @brief MMCRXIS */
  static const uint32_t ETHERNET_MAC_MACISR_MMCTXIS_MSK                    = 0x00000400U;   /** @brief MMCTXIS */
  static const uint32_t ETHERNET_MAC_MACISR_TSIS_MSK                       = 0x00001000U;   /** @brief TSIS */
  static const uint32_t ETHERNET_MAC_MACISR_TXSTSIS_MSK                    = 0x00002000U;   /** @brief TXSTSIS */
  static const uint32_t ETHERNET_MAC_MACISR_RXSTSIS_MSK                    = 0x00004000U;   /** @brief RXSTSIS */
  static const uint32_t ETHERNET_MAC_MACIER_PHYIE_MSK                      = 0x00000008U;   /** @brief PHYIE */
  static const uint32_t ETHERNET_MAC_MACIER_PMTIE_MSK                      = 0x00000010U;   /** @brief PMTIE */
  static const uint32_t ETHERNET_MAC_MACIER_LPIIE_MSK                      = 0x00000020U;   /** @brief LPIIE */
  static const uint32_t ETHERNET_MAC_MACIER_TSIE_MSK                       = 0x00001000U;   /** @brief TSIE */
  static const uint32_t ETHERNET_MAC_MACIER_TXSTSIE_MSK                    = 0x00002000U;   /** @brief TXSTSIE */
  static const uint32_t ETHERNET_MAC_MACIER_RXSTSIE_MSK                    = 0x00004000U;   /** @brief RXSTSIE */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_TJT_MSK                     = 0x00000001U;   /** @brief TJT */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_NCARR_MSK                   = 0x00000002U;   /** @brief NCARR */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_LCARR_MSK                   = 0x00000004U;   /** @brief LCARR */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_EXDEF_MSK                   = 0x00000008U;   /** @brief EXDEF */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_LCOL_MSK                    = 0x00000010U;   /** @brief LCOL */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_EXCOL_MSK                   = 0x00000020U;   /** @brief LCOL */
  static const uint32_t ETHERNET_MAC_MACRXTXSR_RWT_MSK                     = 0x00000100U;   /** @brief RWT */
  static const uint32_t ETHERNET_MAC_MACPCSR_PWRDWN_MSK                    = 0x00000001U;   /** @brief PWRDWN */
  static const uint32_t ETHERNET_MAC_MACPCSR_MGKPKTEN_MSK                  = 0x00000002U;   /** @brief MGKPKTEN */
  static const uint32_t ETHERNET_MAC_MACPCSR_RWKPKTEN_MSK                  = 0x00000004U;   /** @brief RWKPKTEN */
  static const uint32_t ETHERNET_MAC_MACPCSR_MGKPRCVD_MSK                  = 0x00000020U;   /** @brief MGKPRCVD */
  static const uint32_t ETHERNET_MAC_MACPCSR_RWKPRCVD_MSK                  = 0x00000040U;   /** @brief RWKPRCVD */
  static const uint32_t ETHERNET_MAC_MACPCSR_GLBLUCAST_MSK                 = 0x00000200U;   /** @brief GLBLUCAST */
  static const uint32_t ETHERNET_MAC_MACPCSR_RWKPFE_MSK                    = 0x00000400U;   /** @brief RWKPFE */
  static const uint32_t ETHERNET_MAC_MACPCSR_RWKPTR_MSK                    = 0x1F000000U;   /** @brief RWKPTR */
  static const uint32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_MSK                = 0x80000000U;   /** @brief RWKFILTRST */
  static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEN_MSK                    = 0x00000001U;   /** @brief TLPIEN */
  static const uint32_t ETHERNET_MAC_MACLCSR_TLPIEX_MSK                    = 0x00000002U;   /** @brief TLPIEX */
  static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEN_MSK                    = 0x00000004U;   /** @brief RLPIEN */
  static const uint32_t ETHERNET_MAC_MACLCSR_RLPIEX_MSK                    = 0x00000008U;   /** @brief RLPIEX */
  static const uint32_t ETHERNET_MAC_MACLCSR_TLPIST_MSK                    = 0x00000100U;   /** @brief TLPIST */
  static const uint32_t ETHERNET_MAC_MACLCSR_RLPIST_MSK                    = 0x00000200U;   /** @brief RLPIST */
  static const uint32_t ETHERNET_MAC_MACLCSR_LPIEN_MSK                     = 0x00010000U;   /** @brief LPIEN */
  static const uint32_t ETHERNET_MAC_MACLCSR_PLS_MSK                       = 0x00020000U;   /** @brief PLS */
  static const uint32_t ETHERNET_MAC_MACLCSR_PLSEN_MSK                     = 0x00040000U;   /** @brief PLSEN */
  static const uint32_t ETHERNET_MAC_MACLCSR_LPITXA_MSK                    = 0x00080000U;   /** @brief LPITXA */
  static const uint32_t ETHERNET_MAC_MACLCSR_LPITE_MSK                     = 0x00100000U;   /** @brief LPITE */
  static const uint32_t ETHERNET_MAC_MACLCSR_LPITCSE_MSK                   = 0x00200000U;   /** @brief LPITCSE */
  static const uint32_t ETHERNET_MAC_MACLTCR_TWT_MSK                       = 0x0000FFFFU;   /** @brief TWT */
  static const uint32_t ETHERNET_MAC_MACLTCR_LST_MSK                       = 0x03FF0000U;   /** @brief LST */
  static const uint32_t ETHERNET_MAC_MACLETR_LPIET_MSK                     = 0x0001FFFFU;   /** @brief LPIET */
  static const uint32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_MSK            = 0x00000FFFU;   /** @brief TIC_1US_CNTR */
  static const uint32_t ETHERNET_MAC_MACVR_SNPSVER_MSK                     = 0x000000FFU;   /** @brief SNPSVER */
  static const uint32_t ETHERNET_MAC_MACVR_USERVER_MSK                     = 0x0000FF00U;   /** @brief USERVER */
  static const uint32_t ETHERNET_MAC_MACHWFxR_RXFIFOSIZE_MSK               = 0x0000001FU;   /** @brief RXFIFOSIZE */
  static const uint32_t ETHERNET_MAC_MACHWFxR_TXFIFOSIZE_MSK               = 0x000007C0U;   /** @brief TXFIFOSIZE */
  static const uint32_t ETHERNET_MAC_MACHWFxR_OSTEN_MSK                    = 0x00000800U;   /** @brief OSTEN */
  static const uint32_t ETHERNET_MAC_MACHWFxR_PTOEN_MSK                    = 0x00001000U;   /** @brief PTOEN */
  static const uint32_t ETHERNET_MAC_MACHWFxR_ADVTHWORD_MSK                = 0x00002000U;   /** @brief ADVTHWORD */
  static const uint32_t ETHERNET_MAC_MACHWFxR_DCBEN_MSK                    = 0x00010000U;   /** @brief DCBEN */
  static const uint32_t ETHERNET_MAC_MACHWFxR_SPHEN_MSK                    = 0x00020000U;   /** @brief SPHEN */
  static const uint32_t ETHERNET_MAC_MACHWFxR_TSOEN_MSK                    = 0x00040000U;   /** @brief TSOEN */
  static const uint32_t ETHERNET_MAC_MACHWFxR_DBGMEMA_MSK                  = 0x00080000U;   /** @brief DBGMEMA */
  static const uint32_t ETHERNET_MAC_MACHWFxR_AVSEL_MSK                    = 0x00100000U;   /** @brief AVSEL */
  static const uint32_t ETHERNET_MAC_MACHWFxR_HASHTBLSZ_MSK                = 0x03000000U;   /** @brief HASHTBLSZ */
  static const uint32_t ETHERNET_MAC_MACHWFxR_L3L4FNUM_MSK                 = 0x78000000U;   /** @brief L3L4FNUM */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_MB_MSK                      = 0x00000001U;   /** @brief MB */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_C45E_MSK                    = 0x00000002U;   /** @brief C45E */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_GOC_MSK                     = 0x0000000CU;   /** @brief GOC */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_SKAP_MSK                    = 0x00000010U;   /** @brief SKAP */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_CR_MSK                      = 0x00000F00U;   /** @brief CR */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_NTC_MSK                     = 0x00007000U;   /** @brief NTC */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_RDA_MSK                     = 0x001F0000U;   /** @brief RDA */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_PA_MSK                      = 0x03E00000U;   /** @brief PA */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_BTB_MSK                     = 0x04000000U;   /** @brief BTB */
  static const uint32_t ETHERNET_MAC_MACMDIOAR_PSE_MSK                     = 0x08000000U;   /** @brief PSE */
  static const uint32_t ETHERNET_MAC_MACMDIODR_MD_MSK                      = 0x0000FFFFU;   /** @brief MD */
  static const uint32_t ETHERNET_MAC_MACMDIODR_RA_MSK                      = 0xFFFF0000U;   /** @brief RA */
  static const uint32_t ETHERNET_MAC_MACAxHR_ADDRHI_MSK                    = 0x0000FFFFU;   /** @brief ADDRHI */
  static const uint32_t ETHERNET_MAC_MACAxHR_AE_MSK                        = 0x80000000U;   /** @brief AE */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTRST_MSK                = 0x00000001U;   /** @brief CNTRST */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO_MSK             = 0x00000002U;   /** @brief CNTSTOPRO */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD_MSK               = 0x00000004U;   /** @brief RSTONRD */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ_MSK              = 0x00000008U;   /** @brief CNTFREEZ */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST_MSK               = 0x00000010U;   /** @brief CNTPRST */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL_MSK            = 0x00000020U;   /** @brief CNTPRSTLVL */
  static const uint32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_MSK                 = 0x00000100U;   /** @brief UCDBC */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS_MSK       = 0x00000020U;   /** @brief RXCRCERPIS */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS_MSK      = 0x00000040U;   /** @brief RXALGNERPIS */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS_MSK         = 0x00020000U;   /** @brief RXUCGPIS */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS_MSK       = 0x04000000U;   /** @brief RXLPIUSCIS */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_MSK       = 0x08000000U;   /** @brief RXLPITRCIS */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS_MSK       = 0x00004000U;   /** @brief TXSCOLGPIS */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS_MSK       = 0x00008000U;   /** @brief TXMCOLGPIS */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS_MSK         = 0x00200000U;   /** @brief TXGPKTIS */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS_MSK       = 0x04000000U;   /** @brief TXLPIUSCIS */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_MSK       = 0x08000000U;   /** @brief TXLPITRCIS */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_MSK  = 0x00000020U;   /** @brief RXCRCERPIM */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_MSK = 0x00000040U;   /** @brief RXALGNERPIM */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM_MSK    = 0x00020000U;   /** @brief RXUCGPIM */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_MSK  = 0x04000000U;   /** @brief RXLPIUSCIM */
  static const uint32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_MSK  = 0x08000000U;   /** @brief RXLPITRCIM */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_MSK  = 0x00004000U;   /** @brief TXSCOLGPIM */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_MSK  = 0x00008000U;   /** @brief TXMCOLGPIM */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM_MSK    = 0x00200000U;   /** @brief TXGPKTIM */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_MSK  = 0x04000000U;   /** @brief TXLPIUSCIM */
  static const uint32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_MSK  = 0x08000000U;   /** @brief TXLPITRCIM */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3SAM0_MSK                 = 0x00000004U;   /** @brief L3SAM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3SAIM0_MSK                = 0x00000008U;   /** @brief L3SAIM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3DAM0_MSK                 = 0x00000010U;   /** @brief L3DAM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3DAIM0_MSK                = 0x00000020U;   /** @brief L3DAIM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3HSBM0_MSK                = 0x000007C0U;   /** @brief L3HSBM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L3HDBM0_MSK                = 0x0000F800U;   /** @brief L3HDBM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4SPM0_MSK                 = 0x00040000U;   /** @brief L4SPM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4SPIM0_MSK                = 0x00080000U;   /** @brief L4SPIM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4DPM0_MSK                 = 0x00100000U;   /** @brief L4DPM0 */
  static const uint32_t ETHERNET_MAC_MACL3L4CxR_L4DPIM0_MSK                = 0x00200000U;   /** @brief L4DPIM0 */
  static const uint32_t ETHERNET_MAC_MACL4AxR_L4SP0_MSK                    = 0x0000FFFFU;   /** @brief L4SP0 */
  static const uint32_t ETHERNET_MAC_MACL4AxR_L4DP0_MSK                    = 0xFFFF0000U;   /** @brief L4DP0 */
  static const uint32_t ETHERNET_MAC_MACDR_RPESTS_MSK                      = 0x00000001U;   /** @brief RPESTS */
  static const uint32_t ETHERNET_MAC_MACDR_RFCFCSTS_MSK                    = 0x00000006U;   /** @brief RFCFCSTS */
  static const uint32_t ETHERNET_MAC_MACDR_TPESTS_MSK                      = 0x00010000U;   /** @brief TPESTS */
  static const uint32_t ETHERNET_MAC_MACDR_TFCSTS_MSK                      = 0x00060000U;   /** @brief TFCSTS */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSENA_MSK                     = 0x00000001U;   /** @brief TSENA */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSCFUPDT_MSK                  = 0x00000002U;   /** @brief TSCFUPDT */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSINIT_MSK                    = 0x00000004U;   /** @brief TSINIT */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSUPDT_MSK                    = 0x00000008U;   /** @brief TSUPDT */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSADDREG_MSK                  = 0x00000020U;   /** @brief TSADDREG */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSENALL_MSK                   = 0x00000100U;   /** @brief TSENALL */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR_MSK                 = 0x00000200U;   /** @brief TSCTRLSSR */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSVER2ENA_MSK                 = 0x00000400U;   /** @brief TSVER2ENA */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSIPENA_MSK                   = 0x00000800U;   /** @brief TSIPENA */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSEVNTENA_MSK                 = 0x00004000U;   /** @brief TSEVNTENA */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSMSTRENA_MSK                 = 0x00008000U;   /** @brief TSMSTRENA */
  static const uint32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL_MSK                = 0x00030000U;   /** @brief SNAPTYPSEL */
  static const uint32_t ETHERNET_MAC_MACTSCR_TSENMACADDR_MSK               = 0x00040000U;   /** @brief TSENMACADDR */
  static const uint32_t ETHERNET_MAC_MACTSCR_CSC_MSK                       = 0x00080000U;   /** @brief CSC */
  static const uint32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_MSK                  = 0x01000000U;   /** @brief TXTSSTSM */
  static const uint32_t ETHERNET_MAC_MACSSIR_SNSINC_MSK                    = 0x0000FF00U;   /** @brief SNSINC */
  static const uint32_t ETHERNET_MAC_MACSSIR_SSINC_MSK                     = 0x00FF0000U;   /** @brief SSINC */
  static const uint32_t ETHERNET_MAC_MACSTNR_TSSS_MSK                      = 0x7FFFFFFFU;   /** @brief TSSS */
  static const uint32_t ETHERNET_MAC_MACSTNUR_TSSS_MSK                     = 0x7FFFFFFFU;   /** @brief TSSS */
  static const uint32_t ETHERNET_MAC_MACSTNUR_ADDSUB_MSK                   = 0x80000000U;   /** @brief ADDSUB */
  static const uint32_t ETHERNET_MAC_MACTSSR_TSSOVF_MSK                    = 0x00000001U;   /** @brief TSSOVF */
  static const uint32_t ETHERNET_MAC_MACTSSR_TSTARGT0_MSK                  = 0x00000002U;   /** @brief TSTARGT0 */
  static const uint32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG_MSK                 = 0x00000004U;   /** @brief AUXTSTRIG */
  static const uint32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0_MSK                = 0x00000008U;   /** @brief TSTRGTERR0 */
  static const uint32_t ETHERNET_MAC_MACTSSR_TXTSSIS_MSK                   = 0x00008000U;   /** @brief TXTSSIS */
  static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTN_MSK                    = 0x000F0000U;   /** @brief ATSSTN */
  static const uint32_t ETHERNET_MAC_MACTSSR_ATSSTM_MSK                    = 0x01000000U;   /** @brief ATSSTM */
  static const uint32_t ETHERNET_MAC_MACTSSR_ATSNS_MSK                     = 0x3E000000U;   /** @brief ATSNS */
  static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO_MSK                = 0x7FFFFFFFU;   /** @brief TXTSSLO */
  static const uint32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_MSK               = 0x80000000U;   /** @brief TXTSSMIS */
  static const uint32_t ETHERNET_MAC_MACACR_ATSFC_MSK                      = 0x00000001U;   /** @brief ATSFC */
  static const uint32_t ETHERNET_MAC_MACATSNR_AUXTSLO_MSK                  = 0x7FFFFFFFU;   /** @brief AUXTSLO */
  static const uint32_t ETHERNET_MAC_MACPPSCR_PPSCTRL_MSK                  = 0x0000000FU;   /** @brief PPSCTRL */
  static const uint32_t ETHERNET_MAC_MACPPSCR_PPSEN0_MSK                   = 0x00000010U;   /** @brief PPSEN0 */
  static const uint32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_MSK              = 0x00000060U;   /** @brief TRGTMODSEL0 */
  static const uint32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_MSK                 = 0x7FFFFFFFU;   /** @brief TSTRH0 */
  static const uint32_t ETHERNET_MAC_MACPPSTTNR_TTSL0_MSK                  = 0x7FFFFFFFU;   /** @brief TTSL0 */
  static const uint32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_MSK              = 0x80000000U;   /** @brief TRGTBUSY0 */
  static const uint32_t ETHERNET_MAC_MACPOCR_PTOEN_MSK                     = 0x00000001U;   /** @brief PTOEN */
  static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCEN_MSK                   = 0x00000002U;   /** @brief ASYNCEN */
  static const uint32_t ETHERNET_MAC_MACPOCR_APDREQEN_MSK                  = 0x00000004U;   /** @brief APDREQEN */
  static const uint32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG_MSK                 = 0x00000010U;   /** @brief ASYNCTRIG */
  static const uint32_t ETHERNET_MAC_MACPOCR_APDREQTRIG_MSK                = 0x00000020U;   /** @brief APDREQTRIG */
  static const uint32_t ETHERNET_MAC_MACPOCR_DRRDIS_MSK                    = 0x00000040U;   /** @brief DRRDIS */
  static const uint32_t ETHERNET_MAC_MACPOCR_DN_MSK                        = 0x0000FF00U;   /** @brief DN */
  static const uint32_t ETHERNET_MAC_MACLMIR_LSI_MSK                       = 0x000000FFU;   /** @brief LSI */
  static const uint32_t ETHERNET_MAC_MACLMIR_DRSYNCR_MSK                   = 0x00000700U;   /** @brief DRSYNCR */
  static const uint32_t ETHERNET_MAC_MACLMIR_LMPDRI_MSK                    = 0xFF000000U;   /** @brief LMPDRI */

  /**** @subsection Enumerated ETHERNET_MAC Register Field Masks ****/

  static const uint32_t ETHERNET_MAC_MACL3L4CxR_LxPEN0_MSK[5] = {
    [3] = 0x00000001U,   /** @brief L3PEN0 */
    [4] = 0x00010000U,   /** @brief L4PEN0 */
  };

  static const uint32_t ETHERNET_MAC_MACTSCR_TSIPVxENA_MSK[7] = {
    [4] = 0x00002000U,   /** @brief TSIPV4ENA */
    [6] = 0x00001000U,   /** @brief TSIPV6ENA */
  };

  static const uint32_t ETHERNET_MAC_MACACR_ATSENx_MSK[4] = {
    [0] = 0x00000010U,   /** @brief ATSEN0 */
    [1] = 0x00000020U,   /** @brief ATSEN1 */
    [2] = 0x00000040U,   /** @brief ATSEN2 */
    [3] = 0x00000080U,   /** @brief ATSEN3 */
  };

  /**** @subsection ETHERNET_MAC Register Field Positions ****/

  static const int32_t ETHERNET_MAC_DMAMR_SWR_POS                         = 0;    /** @brief Software reset */
  static const int32_t ETHERNET_MAC_DMAMR_DA_POS                          = 1;    /** @brief DMA tx or rx arbitration scheme */
  static const int32_t ETHERNET_MAC_DMAMR_TXPR_POS                        = 11;   /** @brief Transmit priority */
  static const int32_t ETHERNET_MAC_DMAMR_PR_POS                          = 12;   /** @brief Priority ratio */
  static const int32_t ETHERNET_MAC_DMAMR_INTM_POS                        = 16;   /** @brief Interrupt mode */
  static const int32_t ETHERNET_MAC_DMASBMR_FB_POS                        = 0;    /** @brief Fixed burst length */
  static const int32_t ETHERNET_MAC_DMASBMR_AAL_POS                       = 12;   /** @brief Address-Aligned beats */
  static const int32_t ETHERNET_MAC_DMASBMR_MB_POS                        = 14;   /** @brief Mixed burst */
  static const int32_t ETHERNET_MAC_DMASBMR_RB_POS                        = 15;   /** @brief Rebuild incrx burst */
  static const int32_t ETHERNET_MAC_DMAISR_DC0IS_POS                      = 0;    /** @brief DMA channel interrupt status */
  static const int32_t ETHERNET_MAC_DMAISR_MTLIS_POS                      = 16;   /** @brief MTL interrupt status */
  static const int32_t ETHERNET_MAC_DMAISR_MACIS_POS                      = 17;   /** @brief MAC interrupt status */
  static const int32_t ETHERNET_MAC_DMADSR_AXWHSTS_POS                    = 0;    /** @brief AHB master write channel */
  static const int32_t ETHERNET_MAC_DMADSR_RPS0_POS                       = 8;    /** @brief DMA channel receive process state */
  static const int32_t ETHERNET_MAC_DMADSR_TPS0_POS                       = 12;   /** @brief DMA channel transmit process state */
  static const int32_t ETHERNET_MAC_DMACCR_MSS_POS                        = 0;    /** @brief Maximum segment size */
  static const int32_t ETHERNET_MAC_DMACCR_PBLX8_POS                      = 16;   /** @brief 8xPBL mode */
  static const int32_t ETHERNET_MAC_DMACCR_DSL_POS                        = 18;   /** @brief Descriptor skip length */
  static const int32_t ETHERNET_MAC_DMACTXCR_ST_POS                       = 0;    /** @brief Start or stop transmission command */
  static const int32_t ETHERNET_MAC_DMACTXCR_OSF_POS                      = 4;    /** @brief Operate on second packet */
  static const int32_t ETHERNET_MAC_DMACTXCR_TSE_POS                      = 12;   /** @brief TCP segmentation enabled */
  static const int32_t ETHERNET_MAC_DMACTXCR_TXPBL_POS                    = 16;   /** @brief Transmit programmable burst length */
  static const int32_t ETHERNET_MAC_DMACRXCR_SR_POS                       = 0;    /** @brief Start or stop receive command */
  static const int32_t ETHERNET_MAC_DMACRXCR_RBSZ_POS                     = 1;    /** @brief Receive buffer size */
  static const int32_t ETHERNET_MAC_DMACRXCR_RXPBL_POS                    = 16;   /** @brief RXPBL */
  static const int32_t ETHERNET_MAC_DMACRXCR_RPF_POS                      = 31;   /** @brief DMA rx channel packet flush */
  static const int32_t ETHERNET_MAC_DMACTXDLAR_TDESLA_POS                 = 2;    /** @brief Start of transmit list */
  static const int32_t ETHERNET_MAC_DMACRXDLAR_RDESLA_POS                 = 2;    /** @brief Start of receive list */
  static const int32_t ETHERNET_MAC_DMACTXDTPR_TDT_POS                    = 2;    /** @brief Transmit descriptor tail pointer */
  static const int32_t ETHERNET_MAC_DMACRXDTPR_RDT_POS                    = 2;    /** @brief Receive descriptor tail pointer */
  static const int32_t ETHERNET_MAC_DMACTXRLR_TDRL_POS                    = 0;    /** @brief Transmit descriptor ring length */
  static const int32_t ETHERNET_MAC_DMACRXRLR_RDRL_POS                    = 0;    /** @brief Receive descriptor ring length */
  static const int32_t ETHERNET_MAC_DMACIER_TIE_POS                       = 0;    /** @brief Transmit interrupt enable */
  static const int32_t ETHERNET_MAC_DMACIER_TXSE_POS                      = 1;    /** @brief Transmit stopped enable */
  static const int32_t ETHERNET_MAC_DMACIER_TBUE_POS                      = 2;    /** @brief Transmit buffer unavailable enable */
  static const int32_t ETHERNET_MAC_DMACIER_RIE_POS                       = 6;    /** @brief Receive interrupt enable */
  static const int32_t ETHERNET_MAC_DMACIER_RBUE_POS                      = 7;    /** @brief Receive buffer unavailable enable */
  static const int32_t ETHERNET_MAC_DMACIER_RSE_POS                       = 8;    /** @brief Receive stopped enable */
  static const int32_t ETHERNET_MAC_DMACIER_RWTE_POS                      = 9;    /** @brief Receive watchdog timeout enable */
  static const int32_t ETHERNET_MAC_DMACIER_ETIE_POS                      = 10;   /** @brief Early transmit interrupt enable */
  static const int32_t ETHERNET_MAC_DMACIER_ERIE_POS                      = 11;   /** @brief Early receive interrupt enable */
  static const int32_t ETHERNET_MAC_DMACIER_FBEE_POS                      = 12;   /** @brief Fatal bus error enable */
  static const int32_t ETHERNET_MAC_DMACIER_CDEE_POS                      = 13;   /** @brief Context descriptor error enable */
  static const int32_t ETHERNET_MAC_DMACIER_AIE_POS                       = 14;   /** @brief Abnormal interrupt summary enable */
  static const int32_t ETHERNET_MAC_DMACIER_NIE_POS                       = 15;   /** @brief Normal interrupt summary enable */
  static const int32_t ETHERNET_MAC_DMACRXIWTR_RWT_POS                    = 0;    /** @brief Receive interrupt watchdog timer count */
  static const int32_t ETHERNET_MAC_DMACSR_TI_POS                         = 0;    /** @brief Transmit interrupt */
  static const int32_t ETHERNET_MAC_DMACSR_TPS_POS                        = 1;    /** @brief Transmit process stopped */
  static const int32_t ETHERNET_MAC_DMACSR_TBU_POS                        = 2;    /** @brief Transmit buffer unavailable */
  static const int32_t ETHERNET_MAC_DMACSR_RI_POS                         = 6;    /** @brief Receive interrupt */
  static const int32_t ETHERNET_MAC_DMACSR_RBU_POS                        = 7;    /** @brief Receive buffer unavailable */
  static const int32_t ETHERNET_MAC_DMACSR_RPS_POS                        = 8;    /** @brief Receive process stopped */
  static const int32_t ETHERNET_MAC_DMACSR_RWT_POS                        = 9;    /** @brief Receive watchdog timeout */
  static const int32_t ETHERNET_MAC_DMACSR_ET_POS                         = 10;   /** @brief Early transmit interrupt */
  static const int32_t ETHERNET_MAC_DMACSR_ER_POS                         = 11;   /** @brief Early receive interrupt */
  static const int32_t ETHERNET_MAC_DMACSR_FBE_POS                        = 12;   /** @brief Fatal bus error */
  static const int32_t ETHERNET_MAC_DMACSR_CDE_POS                        = 13;   /** @brief Context descriptor error */
  static const int32_t ETHERNET_MAC_DMACSR_AIS_POS                        = 14;   /** @brief Abnormal interrupt summary */
  static const int32_t ETHERNET_MAC_DMACSR_NIS_POS                        = 15;   /** @brief Normal interrupt summary */
  static const int32_t ETHERNET_MAC_DMACSR_TEB_POS                        = 16;   /** @brief Tx DMA error bits */
  static const int32_t ETHERNET_MAC_DMACSR_REB_POS                        = 19;   /** @brief Rx DMA error bits */
  static const int32_t ETHERNET_MAC_DMACMFCR_MFC_POS                      = 0;    /** @brief Dropped packet counters */
  static const int32_t ETHERNET_MAC_DMACMFCR_MFCO_POS                     = 15;   /** @brief Overflow status of the MFC counter */
  static const int32_t ETHERNET_MAC_MTLOMR_DTXSTS_POS                     = 1;    /** @brief DTXSTS */
  static const int32_t ETHERNET_MAC_MTLOMR_CNTPRST_POS                    = 8;    /** @brief CNTPRST */
  static const int32_t ETHERNET_MAC_MTLOMR_CNTCLR_POS                     = 9;    /** @brief CNTCLR */
  static const int32_t ETHERNET_MAC_MTLISR_Q0IS_POS                       = 0;    /** @brief Queue interrupt status */
  static const int32_t ETHERNET_MAC_MTLTXQOMR_FTQ_POS                     = 0;    /** @brief Flush transmit queue */
  static const int32_t ETHERNET_MAC_MTLTXQOMR_TSF_POS                     = 1;    /** @brief Transmit store and forward */
  static const int32_t ETHERNET_MAC_MTLTXQOMR_TXQEN_POS                   = 2;    /** @brief Transmit queue enable */
  static const int32_t ETHERNET_MAC_MTLTXQOMR_TTC_POS                     = 4;    /** @brief Transmit threshold control */
  static const int32_t ETHERNET_MAC_MTLTXQOMR_TQS_POS                     = 16;   /** @brief Transmit queue size */
  static const int32_t ETHERNET_MAC_MTLTXQUR_UFFRMCNT_POS                 = 0;    /** @brief Underflow packet counter */
  static const int32_t ETHERNET_MAC_MTLTXQUR_UFCNTOVF_POS                 = 11;   /** @brief UFCNTOVF */
  static const int32_t ETHERNET_MAC_MTLTXQDR_TXQPAUSED_POS                = 0;    /** @brief TXQPAUSED */
  static const int32_t ETHERNET_MAC_MTLTXQDR_TRCSTS_POS                   = 1;    /** @brief TRCSTS */
  static const int32_t ETHERNET_MAC_MTLTXQDR_TWCSTS_POS                   = 3;    /** @brief TWCSTS */
  static const int32_t ETHERNET_MAC_MTLTXQDR_TXQSTS_POS                   = 4;    /** @brief TXQSTS */
  static const int32_t ETHERNET_MAC_MTLTXQDR_TXSTSFSTS_POS                = 5;    /** @brief TXSTSFSTS */
  static const int32_t ETHERNET_MAC_MTLTXQDR_PTXQ_POS                     = 16;   /** @brief PTXQ */
  static const int32_t ETHERNET_MAC_MTLTXQDR_STXSTSF_POS                  = 20;   /** @brief STXSTSF */
  static const int32_t ETHERNET_MAC_MTLQICSR_TXUNFIS_POS                  = 0;    /** @brief TXUNFIS */
  static const int32_t ETHERNET_MAC_MTLQICSR_TXUIE_POS                    = 8;    /** @brief TXUIE */
  static const int32_t ETHERNET_MAC_MTLQICSR_RXOVFIS_POS                  = 16;   /** @brief RXOVFIS */
  static const int32_t ETHERNET_MAC_MTLQICSR_RXOIE_POS                    = 24;   /** @brief RXOIE */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_RTC_POS                     = 0;    /** @brief RTC */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_FUP_POS                     = 3;    /** @brief FUP */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_FEP_POS                     = 4;    /** @brief FEP */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_RSF_POS                     = 5;    /** @brief RSF */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_DIS_TCP_EF_POS              = 6;    /** @brief DIS_TCP_EF */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_EHFC_POS                    = 7;    /** @brief EHFC */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_RFA_POS                     = 8;    /** @brief RFA */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_RFD_POS                     = 14;   /** @brief RFD */
  static const int32_t ETHERNET_MAC_MTLRXQOMR_RQS_POS                     = 20;   /** @brief RQS */
  static const int32_t ETHERNET_MAC_MTLRXQMPOCR_OVFPKTCNT_POS             = 0;    /** @brief OVFPKTCNT */
  static const int32_t ETHERNET_MAC_MTLRXQMPOCR_OVFCNTOVF_POS             = 11;   /** @brief OVFCNTOVF */
  static const int32_t ETHERNET_MAC_MTLRXQMPOCR_MISPKTCNT_POS             = 16;   /** @brief MISPKTCNT */
  static const int32_t ETHERNET_MAC_MTLRXQMPOCR_MISCNTOVF_POS             = 27;   /** @brief MISCNTOVF */
  static const int32_t ETHERNET_MAC_MTLRXQDR_RWCSTS_POS                   = 0;    /** @brief RWCSTS */
  static const int32_t ETHERNET_MAC_MTLRXQDR_RRCSTS_POS                   = 1;    /** @brief RRCSTS */
  static const int32_t ETHERNET_MAC_MTLRXQDR_RXQSTS_POS                   = 4;    /** @brief RXQSTS */
  static const int32_t ETHERNET_MAC_MTLRXQDR_PRXQ_POS                     = 16;   /** @brief PRXQ */
  static const int32_t ETHERNET_MAC_MACCR_RE_POS                          = 0;    /** @brief Receiver enable */
  static const int32_t ETHERNET_MAC_MACCR_TE_POS                          = 1;    /** @brief TE */
  static const int32_t ETHERNET_MAC_MACCR_PRELEN_POS                      = 2;    /** @brief PRELEN */
  static const int32_t ETHERNET_MAC_MACCR_DC_POS                          = 4;    /** @brief DC */
  static const int32_t ETHERNET_MAC_MACCR_BL_POS                          = 5;    /** @brief BL */
  static const int32_t ETHERNET_MAC_MACCR_DR_POS                          = 8;    /** @brief DR */
  static const int32_t ETHERNET_MAC_MACCR_DCRS_POS                        = 9;    /** @brief DCRS */
  static const int32_t ETHERNET_MAC_MACCR_DO_POS                          = 10;   /** @brief DO */
  static const int32_t ETHERNET_MAC_MACCR_ECRSFD_POS                      = 11;   /** @brief ECRSFD */
  static const int32_t ETHERNET_MAC_MACCR_LM_POS                          = 12;   /** @brief LM */
  static const int32_t ETHERNET_MAC_MACCR_DM_POS                          = 13;   /** @brief DM */
  static const int32_t ETHERNET_MAC_MACCR_FES_POS                         = 14;   /** @brief FES */
  static const int32_t ETHERNET_MAC_MACCR_JE_POS                          = 16;   /** @brief JE */
  static const int32_t ETHERNET_MAC_MACCR_JD_POS                          = 17;   /** @brief JD */
  static const int32_t ETHERNET_MAC_MACCR_WD_POS                          = 19;   /** @brief WD */
  static const int32_t ETHERNET_MAC_MACCR_ACS_POS                         = 20;   /** @brief ACS */
  static const int32_t ETHERNET_MAC_MACCR_CST_POS                         = 21;   /** @brief CST */
  static const int32_t ETHERNET_MAC_MACCR_S2KP_POS                        = 22;   /** @brief S2KP */
  static const int32_t ETHERNET_MAC_MACCR_GPSLCE_POS                      = 23;   /** @brief GPSLCE */
  static const int32_t ETHERNET_MAC_MACCR_IPG_POS                         = 24;   /** @brief IPG */
  static const int32_t ETHERNET_MAC_MACCR_IPC_POS                         = 27;   /** @brief IPC */
  static const int32_t ETHERNET_MAC_MACCR_SARC_POS                        = 28;   /** @brief SARC */
  static const int32_t ETHERNET_MAC_MACCR_ARPEN_POS                       = 31;   /** @brief ARPEN */
  static const int32_t ETHERNET_MAC_MACECR_GPSL_POS                       = 0;    /** @brief GPSL */
  static const int32_t ETHERNET_MAC_MACECR_DCRCC_POS                      = 16;   /** @brief DCRCC */
  static const int32_t ETHERNET_MAC_MACECR_SPEN_POS                       = 17;   /** @brief SPEN */
  static const int32_t ETHERNET_MAC_MACECR_USP_POS                        = 18;   /** @brief USP */
  static const int32_t ETHERNET_MAC_MACECR_EIPGEN_POS                     = 24;   /** @brief EIPGEN */
  static const int32_t ETHERNET_MAC_MACECR_EIPG_POS                       = 25;   /** @brief EIPG */
  static const int32_t ETHERNET_MAC_MACPFR_PR_POS                         = 0;    /** @brief PR */
  static const int32_t ETHERNET_MAC_MACPFR_HUC_POS                        = 1;    /** @brief HUC */
  static const int32_t ETHERNET_MAC_MACPFR_HMC_POS                        = 2;    /** @brief HMC */
  static const int32_t ETHERNET_MAC_MACPFR_DAIF_POS                       = 3;    /** @brief DAIF */
  static const int32_t ETHERNET_MAC_MACPFR_PM_POS                         = 4;    /** @brief PM */
  static const int32_t ETHERNET_MAC_MACPFR_DBF_POS                        = 5;    /** @brief DBF */
  static const int32_t ETHERNET_MAC_MACPFR_PCF_POS                        = 6;    /** @brief PCF */
  static const int32_t ETHERNET_MAC_MACPFR_SAIF_POS                       = 8;    /** @brief SAIF */
  static const int32_t ETHERNET_MAC_MACPFR_SAF_POS                        = 9;    /** @brief SAF */
  static const int32_t ETHERNET_MAC_MACPFR_HPF_POS                        = 10;   /** @brief HPF */
  static const int32_t ETHERNET_MAC_MACPFR_VTFE_POS                       = 16;   /** @brief VTFE */
  static const int32_t ETHERNET_MAC_MACPFR_IPFE_POS                       = 20;   /** @brief IPFE */
  static const int32_t ETHERNET_MAC_MACPFR_DNTU_POS                       = 21;   /** @brief DNTU */
  static const int32_t ETHERNET_MAC_MACPFR_RA_POS                         = 31;   /** @brief RA */
  static const int32_t ETHERNET_MAC_MACWTR_WTO_POS                        = 0;    /** @brief WTO */
  static const int32_t ETHERNET_MAC_MACWTR_PWE_POS                        = 8;    /** @brief PWE */
  static const int32_t ETHERNET_MAC_MACVTR_VL_POS                         = 0;    /** @brief VL */
  static const int32_t ETHERNET_MAC_MACVTR_ETV_POS                        = 16;   /** @brief ETV */
  static const int32_t ETHERNET_MAC_MACVTR_VTIM_POS                       = 17;   /** @brief VTIM */
  static const int32_t ETHERNET_MAC_MACVTR_ESVL_POS                       = 18;   /** @brief ESVL */
  static const int32_t ETHERNET_MAC_MACVTR_ERSVLM_POS                     = 19;   /** @brief ERSVLM */
  static const int32_t ETHERNET_MAC_MACVTR_DOVLTC_POS                     = 20;   /** @brief DOVLTC */
  static const int32_t ETHERNET_MAC_MACVTR_EVLS_POS                       = 21;   /** @brief EVLS */
  static const int32_t ETHERNET_MAC_MACVTR_EVLRXS_POS                     = 24;   /** @brief EVLRXS */
  static const int32_t ETHERNET_MAC_MACVTR_VTHM_POS                       = 25;   /** @brief VTHM */
  static const int32_t ETHERNET_MAC_MACVTR_EDVLP_POS                      = 26;   /** @brief EDVLP */
  static const int32_t ETHERNET_MAC_MACVTR_ERIVLT_POS                     = 27;   /** @brief ERIVLT */
  static const int32_t ETHERNET_MAC_MACVTR_EIVLS_POS                      = 28;   /** @brief EIVLS */
  static const int32_t ETHERNET_MAC_MACVTR_EIVLRXS_POS                    = 31;   /** @brief EIVLRXS */
  static const int32_t ETHERNET_MAC_MACVHTR_VLHT_POS                      = 0;    /** @brief VLHT */
  static const int32_t ETHERNET_MAC_MACVIR_VLT_POS                        = 0;    /** @brief VLT */
  static const int32_t ETHERNET_MAC_MACVIR_VLC_POS                        = 16;   /** @brief VLC */
  static const int32_t ETHERNET_MAC_MACVIR_VLP_POS                        = 18;   /** @brief VLP */
  static const int32_t ETHERNET_MAC_MACVIR_CSVL_POS                       = 19;   /** @brief CSVL */
  static const int32_t ETHERNET_MAC_MACVIR_VLTI_POS                       = 20;   /** @brief VLTI */
  static const int32_t ETHERNET_MAC_MACIVIR_VLT_POS                       = 0;    /** @brief VLT */
  static const int32_t ETHERNET_MAC_MACIVIR_VLC_POS                       = 16;   /** @brief VLC */
  static const int32_t ETHERNET_MAC_MACIVIR_VLP_POS                       = 18;   /** @brief VLP */
  static const int32_t ETHERNET_MAC_MACIVIR_CSVL_POS                      = 19;   /** @brief CSVL */
  static const int32_t ETHERNET_MAC_MACIVIR_VLTI_POS                      = 20;   /** @brief VLTI */
  static const int32_t ETHERNET_MAC_MACQTXFCR_FCB_BPA_POS                 = 0;    /** @brief FCB_BPA */
  static const int32_t ETHERNET_MAC_MACQTXFCR_TFE_POS                     = 1;    /** @brief TFE */
  static const int32_t ETHERNET_MAC_MACQTXFCR_PLT_POS                     = 4;    /** @brief PLT */
  static const int32_t ETHERNET_MAC_MACQTXFCR_DZPQ_POS                    = 7;    /** @brief DZPQ */
  static const int32_t ETHERNET_MAC_MACQTXFCR_PT_POS                      = 16;   /** @brief PT */
  static const int32_t ETHERNET_MAC_MACRXFCR_RFE_POS                      = 0;    /** @brief RFE */
  static const int32_t ETHERNET_MAC_MACRXFCR_UP_POS                       = 1;    /** @brief UP */
  static const int32_t ETHERNET_MAC_MACISR_PHYIS_POS                      = 3;    /** @brief PHYIS */
  static const int32_t ETHERNET_MAC_MACISR_PMTIS_POS                      = 4;    /** @brief PMTIS */
  static const int32_t ETHERNET_MAC_MACISR_LPIIS_POS                      = 5;    /** @brief LPIIS */
  static const int32_t ETHERNET_MAC_MACISR_MMCIS_POS                      = 8;    /** @brief MMCIS */
  static const int32_t ETHERNET_MAC_MACISR_MMCRXIS_POS                    = 9;    /** @brief MMCRXIS */
  static const int32_t ETHERNET_MAC_MACISR_MMCTXIS_POS                    = 10;   /** @brief MMCTXIS */
  static const int32_t ETHERNET_MAC_MACISR_TSIS_POS                       = 12;   /** @brief TSIS */
  static const int32_t ETHERNET_MAC_MACISR_TXSTSIS_POS                    = 13;   /** @brief TXSTSIS */
  static const int32_t ETHERNET_MAC_MACISR_RXSTSIS_POS                    = 14;   /** @brief RXSTSIS */
  static const int32_t ETHERNET_MAC_MACIER_PHYIE_POS                      = 3;    /** @brief PHYIE */
  static const int32_t ETHERNET_MAC_MACIER_PMTIE_POS                      = 4;    /** @brief PMTIE */
  static const int32_t ETHERNET_MAC_MACIER_LPIIE_POS                      = 5;    /** @brief LPIIE */
  static const int32_t ETHERNET_MAC_MACIER_TSIE_POS                       = 12;   /** @brief TSIE */
  static const int32_t ETHERNET_MAC_MACIER_TXSTSIE_POS                    = 13;   /** @brief TXSTSIE */
  static const int32_t ETHERNET_MAC_MACIER_RXSTSIE_POS                    = 14;   /** @brief RXSTSIE */
  static const int32_t ETHERNET_MAC_MACRXTXSR_TJT_POS                     = 0;    /** @brief TJT */
  static const int32_t ETHERNET_MAC_MACRXTXSR_NCARR_POS                   = 1;    /** @brief NCARR */
  static const int32_t ETHERNET_MAC_MACRXTXSR_LCARR_POS                   = 2;    /** @brief LCARR */
  static const int32_t ETHERNET_MAC_MACRXTXSR_EXDEF_POS                   = 3;    /** @brief EXDEF */
  static const int32_t ETHERNET_MAC_MACRXTXSR_LCOL_POS                    = 4;    /** @brief LCOL */
  static const int32_t ETHERNET_MAC_MACRXTXSR_EXCOL_POS                   = 5;    /** @brief LCOL */
  static const int32_t ETHERNET_MAC_MACRXTXSR_RWT_POS                     = 8;    /** @brief RWT */
  static const int32_t ETHERNET_MAC_MACPCSR_PWRDWN_POS                    = 0;    /** @brief PWRDWN */
  static const int32_t ETHERNET_MAC_MACPCSR_MGKPKTEN_POS                  = 1;    /** @brief MGKPKTEN */
  static const int32_t ETHERNET_MAC_MACPCSR_RWKPKTEN_POS                  = 2;    /** @brief RWKPKTEN */
  static const int32_t ETHERNET_MAC_MACPCSR_MGKPRCVD_POS                  = 5;    /** @brief MGKPRCVD */
  static const int32_t ETHERNET_MAC_MACPCSR_RWKPRCVD_POS                  = 6;    /** @brief RWKPRCVD */
  static const int32_t ETHERNET_MAC_MACPCSR_GLBLUCAST_POS                 = 9;    /** @brief GLBLUCAST */
  static const int32_t ETHERNET_MAC_MACPCSR_RWKPFE_POS                    = 10;   /** @brief RWKPFE */
  static const int32_t ETHERNET_MAC_MACPCSR_RWKPTR_POS                    = 24;   /** @brief RWKPTR */
  static const int32_t ETHERNET_MAC_MACPCSR_RWKFILTRST_POS                = 31;   /** @brief RWKFILTRST */
  static const int32_t ETHERNET_MAC_MACLCSR_TLPIEN_POS                    = 0;    /** @brief TLPIEN */
  static const int32_t ETHERNET_MAC_MACLCSR_TLPIEX_POS                    = 1;    /** @brief TLPIEX */
  static const int32_t ETHERNET_MAC_MACLCSR_RLPIEN_POS                    = 2;    /** @brief RLPIEN */
  static const int32_t ETHERNET_MAC_MACLCSR_RLPIEX_POS                    = 3;    /** @brief RLPIEX */
  static const int32_t ETHERNET_MAC_MACLCSR_TLPIST_POS                    = 8;    /** @brief TLPIST */
  static const int32_t ETHERNET_MAC_MACLCSR_RLPIST_POS                    = 9;    /** @brief RLPIST */
  static const int32_t ETHERNET_MAC_MACLCSR_LPIEN_POS                     = 16;   /** @brief LPIEN */
  static const int32_t ETHERNET_MAC_MACLCSR_PLS_POS                       = 17;   /** @brief PLS */
  static const int32_t ETHERNET_MAC_MACLCSR_PLSEN_POS                     = 18;   /** @brief PLSEN */
  static const int32_t ETHERNET_MAC_MACLCSR_LPITXA_POS                    = 19;   /** @brief LPITXA */
  static const int32_t ETHERNET_MAC_MACLCSR_LPITE_POS                     = 20;   /** @brief LPITE */
  static const int32_t ETHERNET_MAC_MACLCSR_LPITCSE_POS                   = 21;   /** @brief LPITCSE */
  static const int32_t ETHERNET_MAC_MACLTCR_TWT_POS                       = 0;    /** @brief TWT */
  static const int32_t ETHERNET_MAC_MACLTCR_LST_POS                       = 16;   /** @brief LST */
  static const int32_t ETHERNET_MAC_MACLETR_LPIET_POS                     = 0;    /** @brief LPIET */
  static const int32_t ETHERNET_MAC_MAC1USTCR_TIC_1US_CNTR_POS            = 0;    /** @brief TIC_1US_CNTR */
  static const int32_t ETHERNET_MAC_MACVR_SNPSVER_POS                     = 0;    /** @brief SNPSVER */
  static const int32_t ETHERNET_MAC_MACVR_USERVER_POS                     = 8;    /** @brief USERVER */
  static const int32_t ETHERNET_MAC_MACHWFxR_RXFIFOSIZE_POS               = 0;    /** @brief RXFIFOSIZE */
  static const int32_t ETHERNET_MAC_MACHWFxR_TXFIFOSIZE_POS               = 6;    /** @brief TXFIFOSIZE */
  static const int32_t ETHERNET_MAC_MACHWFxR_OSTEN_POS                    = 11;   /** @brief OSTEN */
  static const int32_t ETHERNET_MAC_MACHWFxR_PTOEN_POS                    = 12;   /** @brief PTOEN */
  static const int32_t ETHERNET_MAC_MACHWFxR_ADVTHWORD_POS                = 13;   /** @brief ADVTHWORD */
  static const int32_t ETHERNET_MAC_MACHWFxR_DCBEN_POS                    = 16;   /** @brief DCBEN */
  static const int32_t ETHERNET_MAC_MACHWFxR_SPHEN_POS                    = 17;   /** @brief SPHEN */
  static const int32_t ETHERNET_MAC_MACHWFxR_TSOEN_POS                    = 18;   /** @brief TSOEN */
  static const int32_t ETHERNET_MAC_MACHWFxR_DBGMEMA_POS                  = 19;   /** @brief DBGMEMA */
  static const int32_t ETHERNET_MAC_MACHWFxR_AVSEL_POS                    = 20;   /** @brief AVSEL */
  static const int32_t ETHERNET_MAC_MACHWFxR_HASHTBLSZ_POS                = 24;   /** @brief HASHTBLSZ */
  static const int32_t ETHERNET_MAC_MACHWFxR_L3L4FNUM_POS                 = 27;   /** @brief L3L4FNUM */
  static const int32_t ETHERNET_MAC_MACMDIOAR_MB_POS                      = 0;    /** @brief MB */
  static const int32_t ETHERNET_MAC_MACMDIOAR_C45E_POS                    = 1;    /** @brief C45E */
  static const int32_t ETHERNET_MAC_MACMDIOAR_GOC_POS                     = 2;    /** @brief GOC */
  static const int32_t ETHERNET_MAC_MACMDIOAR_SKAP_POS                    = 4;    /** @brief SKAP */
  static const int32_t ETHERNET_MAC_MACMDIOAR_CR_POS                      = 8;    /** @brief CR */
  static const int32_t ETHERNET_MAC_MACMDIOAR_NTC_POS                     = 12;   /** @brief NTC */
  static const int32_t ETHERNET_MAC_MACMDIOAR_RDA_POS                     = 16;   /** @brief RDA */
  static const int32_t ETHERNET_MAC_MACMDIOAR_PA_POS                      = 21;   /** @brief PA */
  static const int32_t ETHERNET_MAC_MACMDIOAR_BTB_POS                     = 26;   /** @brief BTB */
  static const int32_t ETHERNET_MAC_MACMDIOAR_PSE_POS                     = 27;   /** @brief PSE */
  static const int32_t ETHERNET_MAC_MACMDIODR_MD_POS                      = 0;    /** @brief MD */
  static const int32_t ETHERNET_MAC_MACMDIODR_RA_POS                      = 16;   /** @brief RA */
  static const int32_t ETHERNET_MAC_MACAxHR_ADDRHI_POS                    = 0;    /** @brief ADDRHI */
  static const int32_t ETHERNET_MAC_MACAxHR_AE_POS                        = 31;   /** @brief AE */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTRST_POS                = 0;    /** @brief CNTRST */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTSTOPRO_POS             = 1;    /** @brief CNTSTOPRO */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_RSTONRD_POS               = 2;    /** @brief RSTONRD */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTFREEZ_POS              = 3;    /** @brief CNTFREEZ */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTPRST_POS               = 4;    /** @brief CNTPRST */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_CNTPRSTLVL_POS            = 5;    /** @brief CNTPRSTLVL */
  static const int32_t ETHERNET_MAC_MMC_CONTROL_UCDBC_POS                 = 8;    /** @brief UCDBC */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXCRCERPIS_POS       = 5;    /** @brief RXCRCERPIS */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXALGNERPIS_POS      = 6;    /** @brief RXALGNERPIS */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXUCGPIS_POS         = 17;   /** @brief RXUCGPIS */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS_POS       = 26;   /** @brief RXLPIUSCIS */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_RXLPITRCIS_POS       = 27;   /** @brief RXLPITRCIS */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS_POS       = 14;   /** @brief TXSCOLGPIS */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS_POS       = 15;   /** @brief TXMCOLGPIS */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXGPKTIS_POS         = 21;   /** @brief TXGPKTIS */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS_POS       = 26;   /** @brief TXLPIUSCIS */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_TXLPITRCIS_POS       = 27;   /** @brief TXLPITRCIS */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM_POS  = 5;    /** @brief RXCRCERPIM */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM_POS = 6;    /** @brief RXALGNERPIM */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM_POS    = 17;   /** @brief RXUCGPIM */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM_POS  = 26;   /** @brief RXLPIUSCIM */
  static const int32_t ETHERNET_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM_POS  = 27;   /** @brief RXLPITRCIM */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM_POS  = 14;   /** @brief TXSCOLGPIM */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM_POS  = 15;   /** @brief TXMCOLGPIM */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM_POS    = 21;   /** @brief TXGPKTIM */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM_POS  = 26;   /** @brief TXLPIUSCIM */
  static const int32_t ETHERNET_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM_POS  = 27;   /** @brief TXLPITRCIM */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3SAM0_POS                 = 2;    /** @brief L3SAM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3SAIM0_POS                = 3;    /** @brief L3SAIM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3DAM0_POS                 = 4;    /** @brief L3DAM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3DAIM0_POS                = 5;    /** @brief L3DAIM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3HSBM0_POS                = 6;    /** @brief L3HSBM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L3HDBM0_POS                = 11;   /** @brief L3HDBM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L4SPM0_POS                 = 18;   /** @brief L4SPM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L4SPIM0_POS                = 19;   /** @brief L4SPIM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L4DPM0_POS                 = 20;   /** @brief L4DPM0 */
  static const int32_t ETHERNET_MAC_MACL3L4CxR_L4DPIM0_POS                = 21;   /** @brief L4DPIM0 */
  static const int32_t ETHERNET_MAC_MACL4AxR_L4SP0_POS                    = 0;    /** @brief L4SP0 */
  static const int32_t ETHERNET_MAC_MACL4AxR_L4DP0_POS                    = 16;   /** @brief L4DP0 */
  static const int32_t ETHERNET_MAC_MACDR_RPESTS_POS                      = 0;    /** @brief RPESTS */
  static const int32_t ETHERNET_MAC_MACDR_RFCFCSTS_POS                    = 1;    /** @brief RFCFCSTS */
  static const int32_t ETHERNET_MAC_MACDR_TPESTS_POS                      = 16;   /** @brief TPESTS */
  static const int32_t ETHERNET_MAC_MACDR_TFCSTS_POS                      = 17;   /** @brief TFCSTS */
  static const int32_t ETHERNET_MAC_MACTSCR_TSENA_POS                     = 0;    /** @brief TSENA */
  static const int32_t ETHERNET_MAC_MACTSCR_TSCFUPDT_POS                  = 1;    /** @brief TSCFUPDT */
  static const int32_t ETHERNET_MAC_MACTSCR_TSINIT_POS                    = 2;    /** @brief TSINIT */
  static const int32_t ETHERNET_MAC_MACTSCR_TSUPDT_POS                    = 3;    /** @brief TSUPDT */
  static const int32_t ETHERNET_MAC_MACTSCR_TSADDREG_POS                  = 5;    /** @brief TSADDREG */
  static const int32_t ETHERNET_MAC_MACTSCR_TSENALL_POS                   = 8;    /** @brief TSENALL */
  static const int32_t ETHERNET_MAC_MACTSCR_TSCTRLSSR_POS                 = 9;    /** @brief TSCTRLSSR */
  static const int32_t ETHERNET_MAC_MACTSCR_TSVER2ENA_POS                 = 10;   /** @brief TSVER2ENA */
  static const int32_t ETHERNET_MAC_MACTSCR_TSIPENA_POS                   = 11;   /** @brief TSIPENA */
  static const int32_t ETHERNET_MAC_MACTSCR_TSEVNTENA_POS                 = 14;   /** @brief TSEVNTENA */
  static const int32_t ETHERNET_MAC_MACTSCR_TSMSTRENA_POS                 = 15;   /** @brief TSMSTRENA */
  static const int32_t ETHERNET_MAC_MACTSCR_SNAPTYPSEL_POS                = 16;   /** @brief SNAPTYPSEL */
  static const int32_t ETHERNET_MAC_MACTSCR_TSENMACADDR_POS               = 18;   /** @brief TSENMACADDR */
  static const int32_t ETHERNET_MAC_MACTSCR_CSC_POS                       = 19;   /** @brief CSC */
  static const int32_t ETHERNET_MAC_MACTSCR_TXTSSTSM_POS                  = 24;   /** @brief TXTSSTSM */
  static const int32_t ETHERNET_MAC_MACSSIR_SNSINC_POS                    = 8;    /** @brief SNSINC */
  static const int32_t ETHERNET_MAC_MACSSIR_SSINC_POS                     = 16;   /** @brief SSINC */
  static const int32_t ETHERNET_MAC_MACSTNR_TSSS_POS                      = 0;    /** @brief TSSS */
  static const int32_t ETHERNET_MAC_MACSTNUR_TSSS_POS                     = 0;    /** @brief TSSS */
  static const int32_t ETHERNET_MAC_MACSTNUR_ADDSUB_POS                   = 31;   /** @brief ADDSUB */
  static const int32_t ETHERNET_MAC_MACTSSR_TSSOVF_POS                    = 0;    /** @brief TSSOVF */
  static const int32_t ETHERNET_MAC_MACTSSR_TSTARGT0_POS                  = 1;    /** @brief TSTARGT0 */
  static const int32_t ETHERNET_MAC_MACTSSR_AUXTSTRIG_POS                 = 2;    /** @brief AUXTSTRIG */
  static const int32_t ETHERNET_MAC_MACTSSR_TSTRGTERR0_POS                = 3;    /** @brief TSTRGTERR0 */
  static const int32_t ETHERNET_MAC_MACTSSR_TXTSSIS_POS                   = 15;   /** @brief TXTSSIS */
  static const int32_t ETHERNET_MAC_MACTSSR_ATSSTN_POS                    = 16;   /** @brief ATSSTN */
  static const int32_t ETHERNET_MAC_MACTSSR_ATSSTM_POS                    = 24;   /** @brief ATSSTM */
  static const int32_t ETHERNET_MAC_MACTSSR_ATSNS_POS                     = 25;   /** @brief ATSNS */
  static const int32_t ETHERNET_MAC_MACTXTSSNR_TXTSSLO_POS                = 0;    /** @brief TXTSSLO */
  static const int32_t ETHERNET_MAC_MACTXTSSNR_TXTSSMIS_POS               = 31;   /** @brief TXTSSMIS */
  static const int32_t ETHERNET_MAC_MACACR_ATSFC_POS                      = 0;    /** @brief ATSFC */
  static const int32_t ETHERNET_MAC_MACATSNR_AUXTSLO_POS                  = 0;    /** @brief AUXTSLO */
  static const int32_t ETHERNET_MAC_MACPPSCR_PPSCTRL_POS                  = 0;    /** @brief PPSCTRL */
  static const int32_t ETHERNET_MAC_MACPPSCR_PPSEN0_POS                   = 4;    /** @brief PPSEN0 */
  static const int32_t ETHERNET_MAC_MACPPSCR_TRGTMODSEL0_POS              = 5;    /** @brief TRGTMODSEL0 */
  static const int32_t ETHERNET_MAC_MACPPSTTSR_TSTRH0_POS                 = 0;    /** @brief TSTRH0 */
  static const int32_t ETHERNET_MAC_MACPPSTTNR_TTSL0_POS                  = 0;    /** @brief TTSL0 */
  static const int32_t ETHERNET_MAC_MACPPSTTNR_TRGTBUSY0_POS              = 31;   /** @brief TRGTBUSY0 */
  static const int32_t ETHERNET_MAC_MACPOCR_PTOEN_POS                     = 0;    /** @brief PTOEN */
  static const int32_t ETHERNET_MAC_MACPOCR_ASYNCEN_POS                   = 1;    /** @brief ASYNCEN */
  static const int32_t ETHERNET_MAC_MACPOCR_APDREQEN_POS                  = 2;    /** @brief APDREQEN */
  static const int32_t ETHERNET_MAC_MACPOCR_ASYNCTRIG_POS                 = 4;    /** @brief ASYNCTRIG */
  static const int32_t ETHERNET_MAC_MACPOCR_APDREQTRIG_POS                = 5;    /** @brief APDREQTRIG */
  static const int32_t ETHERNET_MAC_MACPOCR_DRRDIS_POS                    = 6;    /** @brief DRRDIS */
  static const int32_t ETHERNET_MAC_MACPOCR_DN_POS                        = 8;    /** @brief DN */
  static const int32_t ETHERNET_MAC_MACLMIR_LSI_POS                       = 0;    /** @brief LSI */
  static const int32_t ETHERNET_MAC_MACLMIR_DRSYNCR_POS                   = 8;    /** @brief DRSYNCR */
  static const int32_t ETHERNET_MAC_MACLMIR_LMPDRI_POS                    = 24;   /** @brief LMPDRI */

  /**** @subsection Enumerated ETHERNET_MAC Register Field Positions ****/

  static const int32_t ETHERNET_MAC_MACL3L4CxR_LxPEN0_POS[5] = {
    [3] = 0,    /** @brief L3PEN0 */
    [4] = 16,   /** @brief L4PEN0 */
  };

  static const int32_t ETHERNET_MAC_MACTSCR_TSIPVxENA_POS[7] = {
    [4] = 13,   /** @brief TSIPV4ENA */
    [6] = 12,   /** @brief TSIPV6ENA */
  };

  static const int32_t ETHERNET_MAC_MACACR_ATSENx_POS[4] = {
    [0] = 4,   /** @brief ATSEN0 */
    [1] = 5,   /** @brief ATSEN1 */
    [2] = 6,   /** @brief ATSEN2 */
    [3] = 7,   /** @brief ATSEN3 */
  };

  /**********************************************************************************************
   * @section DMAx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated DMAx Register Pointers ****/

  static RO_ uint32_t* const DMAx_LISR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40020000U,   /** @brief Low interrupt status register */
    [2] = (RO_ uint32_t* const)0x40020400U,   /** @brief Low interrupt status register */
  };

  static RO_ uint32_t* const DMAx_HISR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x40020004U,   /** @brief High interrupt status register */
    [2] = (RO_ uint32_t* const)0x40020404U,   /** @brief High interrupt status register */
  };

  static RW_ uint32_t* const DMAx_LIFCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40020008U,   /** @brief Low interrupt flag clear register */
    [2] = (RW_ uint32_t* const)0x40020408U,   /** @brief Low interrupt flag clear register */
  };

  static RW_ uint32_t* const DMAx_HIFCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4002000CU,   /** @brief High interrupt flag clear register */
    [2] = (RW_ uint32_t* const)0x4002040CU,   /** @brief High interrupt flag clear register */
  };

  static RW_ uint32_t* const DMAx_SxCR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020010U,   /** @brief Stream x configuration register */
      [1] = (RW_ uint32_t* const)0x40020028U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020040U,   /** @brief Stream x configuration register */
      [3] = (RW_ uint32_t* const)0x40020058U,   /** @brief Stream x configuration register */
      [4] = (RW_ uint32_t* const)0x40020070U,   /** @brief Stream x configuration register */
      [5] = (RW_ uint32_t* const)0x40020088U,   /** @brief Stream x configuration register */
      [6] = (RW_ uint32_t* const)0x400200A0U,   /** @brief Stream x configuration register */
      [7] = (RW_ uint32_t* const)0x400200B8U,   /** @brief Stream x configuration register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40020410U,   /** @brief Stream x configuration register */
      [1] = (RW_ uint32_t* const)0x40020428U,   /** @brief Stream x configuration register */
      [2] = (RW_ uint32_t* const)0x40020440U,   /** @brief Stream x configuration register */
      [3] = (RW_ uint32_t* const)0x40020458U,   /** @brief Stream x configuration register */
      [4] = (RW_ uint32_t* const)0x40020470U,   /** @brief Stream x configuration register */
      [5] = (RW_ uint32_t* const)0x40020488U,   /** @brief Stream x configuration register */
      [6] = (RW_ uint32_t* const)0x400204A0U,   /** @brief Stream x configuration register */
      [7] = (RW_ uint32_t* const)0x400204B8U,   /** @brief Stream x configuration register */
    },
  };

  static RW_ uint32_t* const DMAx_SxNDTR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020014U,   /** @brief Stream x number of data register */
      [1] = (RW_ uint32_t* const)0x4002002CU,   /** @brief Stream x number of data register */
      [2] = (RW_ uint32_t* const)0x40020044U,   /** @brief Stream x number of data register */
      [3] = (RW_ uint32_t* const)0x4002005CU,   /** @brief Stream x number of data register */
      [4] = (RW_ uint32_t* const)0x40020074U,   /** @brief Stream x number of data register */
      [5] = (RW_ uint32_t* const)0x4002008CU,   /** @brief Stream x number of data register */
      [6] = (RW_ uint32_t* const)0x400200A4U,   /** @brief Stream x number of data register */
      [7] = (RW_ uint32_t* const)0x400200BCU,   /** @brief Stream x number of data register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40020414U,   /** @brief Stream x number of data register */
      [1] = (RW_ uint32_t* const)0x4002042CU,   /** @brief Stream x number of data register */
      [2] = (RW_ uint32_t* const)0x40020444U,   /** @brief Stream x number of data register */
      [3] = (RW_ uint32_t* const)0x4002045CU,   /** @brief Stream x number of data register */
      [4] = (RW_ uint32_t* const)0x40020474U,   /** @brief Stream x number of data register */
      [5] = (RW_ uint32_t* const)0x4002048CU,   /** @brief Stream x number of data register */
      [6] = (RW_ uint32_t* const)0x400204A4U,   /** @brief Stream x number of data register */
      [7] = (RW_ uint32_t* const)0x400204BCU,   /** @brief Stream x number of data register */
    },
  };

  static RW_ uint32_t* const DMAx_SxPAR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020018U,   /** @brief Stream x peripheral address register */
      [1] = (RW_ uint32_t* const)0x40020030U,   /** @brief Stream x peripheral address register */
      [2] = (RW_ uint32_t* const)0x40020048U,   /** @brief Stream x peripheral address register */
      [3] = (RW_ uint32_t* const)0x40020060U,   /** @brief Stream x peripheral address register */
      [4] = (RW_ uint32_t* const)0x40020078U,   /** @brief Stream x peripheral address register */
      [5] = (RW_ uint32_t* const)0x40020090U,   /** @brief Stream x peripheral address register */
      [6] = (RW_ uint32_t* const)0x400200A8U,   /** @brief Stream x peripheral address register */
      [7] = (RW_ uint32_t* const)0x400200C0U,   /** @brief Stream x peripheral address register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40020418U,   /** @brief Stream x peripheral address register */
      [1] = (RW_ uint32_t* const)0x40020430U,   /** @brief Stream x peripheral address register */
      [2] = (RW_ uint32_t* const)0x40020448U,   /** @brief Stream x peripheral address register */
      [3] = (RW_ uint32_t* const)0x40020460U,   /** @brief Stream x peripheral address register */
      [4] = (RW_ uint32_t* const)0x40020478U,   /** @brief Stream x peripheral address register */
      [5] = (RW_ uint32_t* const)0x40020490U,   /** @brief Stream x peripheral address register */
      [6] = (RW_ uint32_t* const)0x400204A8U,   /** @brief Stream x peripheral address register */
      [7] = (RW_ uint32_t* const)0x400204C0U,   /** @brief Stream x peripheral address register */
    },
  };

  static RW_ uint32_t* const DMAx_SxM0AR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x4002001CU,   /** @brief Stream x memory 0 address register */
      [1] = (RW_ uint32_t* const)0x40020034U,   /** @brief Stream x memory 0 address register */
      [2] = (RW_ uint32_t* const)0x4002004CU,   /** @brief Stream x memory 0 address register */
      [3] = (RW_ uint32_t* const)0x40020064U,   /** @brief Stream x memory 0 address register */
      [4] = (RW_ uint32_t* const)0x4002007CU,   /** @brief Stream x memory 0 address register */
      [5] = (RW_ uint32_t* const)0x40020094U,   /** @brief Stream x memory 0 address register */
      [6] = (RW_ uint32_t* const)0x400200ACU,   /** @brief Stream x memory 0 address register */
      [7] = (RW_ uint32_t* const)0x400200C4U,   /** @brief Stream x memory 0 address register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x4002041CU,   /** @brief Stream x memory 0 address register */
      [1] = (RW_ uint32_t* const)0x40020434U,   /** @brief Stream x memory 0 address register */
      [2] = (RW_ uint32_t* const)0x4002044CU,   /** @brief Stream x memory 0 address register */
      [3] = (RW_ uint32_t* const)0x40020464U,   /** @brief Stream x memory 0 address register */
      [4] = (RW_ uint32_t* const)0x4002047CU,   /** @brief Stream x memory 0 address register */
      [5] = (RW_ uint32_t* const)0x40020494U,   /** @brief Stream x memory 0 address register */
      [6] = (RW_ uint32_t* const)0x400204ACU,   /** @brief Stream x memory 0 address register */
      [7] = (RW_ uint32_t* const)0x400204C4U,   /** @brief Stream x memory 0 address register */
    },
  };

  static RW_ uint32_t* const DMAx_SxFCR_PTR[3][8] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x40020024U,   /** @brief Stream x FIFO control register */
      [1] = (RW_ uint32_t* const)0x4002003CU,   /** @brief Stream x FIFO control register */
      [2] = (RW_ uint32_t* const)0x40020054U,   /** @brief Stream x FIFO control register */
      [3] = (RW_ uint32_t* const)0x4002006CU,   /** @brief Stream x FIFO control register */
      [4] = (RW_ uint32_t* const)0x40020084U,   /** @brief Stream x FIFO control register */
      [5] = (RW_ uint32_t* const)0x4002009CU,   /** @brief Stream x FIFO control register */
      [6] = (RW_ uint32_t* const)0x400200B4U,   /** @brief Stream x FIFO control register */
      [7] = (RW_ uint32_t* const)0x400200CCU,   /** @brief Stream x FIFO control register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x40020424U,   /** @brief Stream x FIFO control register */
      [1] = (RW_ uint32_t* const)0x4002043CU,   /** @brief Stream x FIFO control register */
      [2] = (RW_ uint32_t* const)0x40020454U,   /** @brief Stream x FIFO control register */
      [3] = (RW_ uint32_t* const)0x4002046CU,   /** @brief Stream x FIFO control register */
      [4] = (RW_ uint32_t* const)0x40020484U,   /** @brief Stream x FIFO control register */
      [5] = (RW_ uint32_t* const)0x4002049CU,   /** @brief Stream x FIFO control register */
      [6] = (RW_ uint32_t* const)0x400204B4U,   /** @brief Stream x FIFO control register */
      [7] = (RW_ uint32_t* const)0x400204CCU,   /** @brief Stream x FIFO control register */
    },
  };

  static RW_ uint32_t* const DMAx_SxM1AR_PTR[3][8] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40020038U,   /** @brief Stream x memory 1 address register */
      [2] = (RW_ uint32_t* const)0x40020050U,   /** @brief Stream x memory 1 address register */
      [3] = (RW_ uint32_t* const)0x40020068U,   /** @brief Stream x memory 1 address register */
      [4] = (RW_ uint32_t* const)0x40020080U,   /** @brief Stream x memory 1 address register */
      [5] = (RW_ uint32_t* const)0x40020098U,   /** @brief Stream x memory 1 address register */
      [6] = (RW_ uint32_t* const)0x400200B0U,   /** @brief Stream x memory 1 address register */
      [7] = (RW_ uint32_t* const)0x400200C8U,   /** @brief Stream x memory 1 address register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40020438U,   /** @brief Stream x memory 1 address register */
      [2] = (RW_ uint32_t* const)0x40020450U,   /** @brief Stream x memory 1 address register */
      [3] = (RW_ uint32_t* const)0x40020468U,   /** @brief Stream x memory 1 address register */
      [4] = (RW_ uint32_t* const)0x40020480U,   /** @brief Stream x memory 1 address register */
      [5] = (RW_ uint32_t* const)0x40020498U,   /** @brief Stream x memory 1 address register */
      [6] = (RW_ uint32_t* const)0x400204B0U,   /** @brief Stream x memory 1 address register */
      [7] = (RW_ uint32_t* const)0x400204C8U,   /** @brief Stream x memory 1 address register */
    },
  };

  /**** @subsection DMAx Register Field Masks ****/

  static const uint32_t DMAx_SxCR_MBURST_MSK = 0x01800000U;   /** @brief Memory burst transfer configuration */
  static const uint32_t DMAx_SxCR_PBURST_MSK = 0x00600000U;   /** @brief Peripheral burst transfer configuration */
  static const uint32_t DMAx_SxCR_CT_MSK     = 0x00080000U;   /** @brief Current target (only in double buffer mode) */
  static const uint32_t DMAx_SxCR_DBM_MSK    = 0x00040000U;   /** @brief Double buffer mode */
  static const uint32_t DMAx_SxCR_PL_MSK     = 0x00030000U;   /** @brief Priority level */
  static const uint32_t DMAx_SxCR_PINCOS_MSK = 0x00008000U;   /** @brief Peripheral increment offset size */
  static const uint32_t DMAx_SxCR_MSIZE_MSK  = 0x00006000U;   /** @brief Memory data size */
  static const uint32_t DMAx_SxCR_PSIZE_MSK  = 0x00001800U;   /** @brief Peripheral data size */
  static const uint32_t DMAx_SxCR_MINC_MSK   = 0x00000400U;   /** @brief Memory increment mode */
  static const uint32_t DMAx_SxCR_PINC_MSK   = 0x00000200U;   /** @brief Peripheral increment mode */
  static const uint32_t DMAx_SxCR_CIRC_MSK   = 0x00000100U;   /** @brief Circular mode */
  static const uint32_t DMAx_SxCR_DIR_MSK    = 0x000000C0U;   /** @brief Data transfer direction */
  static const uint32_t DMAx_SxCR_PFCTRL_MSK = 0x00000020U;   /** @brief Peripheral flow controller */
  static const uint32_t DMAx_SxCR_TCIE_MSK   = 0x00000010U;   /** @brief Transfer complete interrupt enable */
  static const uint32_t DMAx_SxCR_HTIE_MSK   = 0x00000008U;   /** @brief Half transfer interrupt enable */
  static const uint32_t DMAx_SxCR_TEIE_MSK   = 0x00000004U;   /** @brief Transfer error interrupt enable */
  static const uint32_t DMAx_SxCR_DMEIE_MSK  = 0x00000002U;   /** @brief Direct mode error interrupt enable */
  static const uint32_t DMAx_SxCR_EN_MSK     = 0x00000001U;   /** @brief Stream enable / flag stream ready when read low */
  static const uint32_t DMAx_SxNDTR_NDT_MSK  = 0x0000FFFFU;   /** @brief Number of data items to transfer */
  static const uint32_t DMAx_SxFCR_FEIE_MSK  = 0x00000080U;   /** @brief FIFO error interrupt enable */
  static const uint32_t DMAx_SxFCR_FS_MSK    = 0x00000038U;   /** @brief FIFO status */
  static const uint32_t DMAx_SxFCR_DMDIS_MSK = 0x00000004U;   /** @brief Direct mode disable */
  static const uint32_t DMAx_SxFCR_FTH_MSK   = 0x00000003U;   /** @brief FIFO threshold selection */

  /**** @subsection Enumerated DMAx Register Field Masks ****/

  static const uint32_t DMAx_LISR_TCIFx_MSK[4] = {
    [0] = 0x00000020U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [1] = 0x00000800U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [2] = 0x00200000U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [3] = 0x08000000U,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
  };

  static const uint32_t DMAx_LISR_HTIFx_MSK[4] = {
    [0] = 0x00000010U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [1] = 0x00000400U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [2] = 0x00100000U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [3] = 0x04000000U,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
  };

  static const uint32_t DMAx_LISR_TEIFx_MSK[4] = {
    [0] = 0x00000008U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [1] = 0x00000200U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [2] = 0x00080000U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [3] = 0x02000000U,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
  };

  static const uint32_t DMAx_LISR_DMEIFx_MSK[4] = {
    [0] = 0x00000004U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [1] = 0x00000100U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [2] = 0x00040000U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [3] = 0x01000000U,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
  };

  static const uint32_t DMAx_LISR_FEIFx_MSK[4] = {
    [0] = 0x00000001U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [1] = 0x00000040U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [2] = 0x00010000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [3] = 0x00400000U,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
  };

  static const uint32_t DMAx_LIFCR_CTCIFx_MSK[4] = {
    [0] = 0x00000020U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [1] = 0x00000800U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [2] = 0x00200000U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [3] = 0x08000000U,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
  };

  static const uint32_t DMAx_LIFCR_CHTIFx_MSK[4] = {
    [0] = 0x00000010U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [1] = 0x00000400U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [2] = 0x00100000U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [3] = 0x04000000U,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
  };

  static const uint32_t DMAx_LIFCR_CTEIFx_MSK[4] = {
    [0] = 0x00000008U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [1] = 0x00000200U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [2] = 0x00080000U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [3] = 0x02000000U,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
  };

  static const uint32_t DMAx_LIFCR_CDMEIFx_MSK[4] = {
    [0] = 0x00000004U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [1] = 0x00000100U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [2] = 0x00040000U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [3] = 0x01000000U,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
  };

  static const uint32_t DMAx_LIFCR_CFEIFx_MSK[4] = {
    [0] = 0x00000001U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [1] = 0x00000040U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [2] = 0x00010000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [3] = 0x00400000U,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
  };

  /**** @subsection DMAx Register Field Positions ****/

  static const int32_t DMAx_SxCR_MBURST_POS = 23;   /** @brief Memory burst transfer configuration */
  static const int32_t DMAx_SxCR_PBURST_POS = 21;   /** @brief Peripheral burst transfer configuration */
  static const int32_t DMAx_SxCR_CT_POS     = 19;   /** @brief Current target (only in double buffer mode) */
  static const int32_t DMAx_SxCR_DBM_POS    = 18;   /** @brief Double buffer mode */
  static const int32_t DMAx_SxCR_PL_POS     = 16;   /** @brief Priority level */
  static const int32_t DMAx_SxCR_PINCOS_POS = 15;   /** @brief Peripheral increment offset size */
  static const int32_t DMAx_SxCR_MSIZE_POS  = 13;   /** @brief Memory data size */
  static const int32_t DMAx_SxCR_PSIZE_POS  = 11;   /** @brief Peripheral data size */
  static const int32_t DMAx_SxCR_MINC_POS   = 10;   /** @brief Memory increment mode */
  static const int32_t DMAx_SxCR_PINC_POS   = 9;    /** @brief Peripheral increment mode */
  static const int32_t DMAx_SxCR_CIRC_POS   = 8;    /** @brief Circular mode */
  static const int32_t DMAx_SxCR_DIR_POS    = 6;    /** @brief Data transfer direction */
  static const int32_t DMAx_SxCR_PFCTRL_POS = 5;    /** @brief Peripheral flow controller */
  static const int32_t DMAx_SxCR_TCIE_POS   = 4;    /** @brief Transfer complete interrupt enable */
  static const int32_t DMAx_SxCR_HTIE_POS   = 3;    /** @brief Half transfer interrupt enable */
  static const int32_t DMAx_SxCR_TEIE_POS   = 2;    /** @brief Transfer error interrupt enable */
  static const int32_t DMAx_SxCR_DMEIE_POS  = 1;    /** @brief Direct mode error interrupt enable */
  static const int32_t DMAx_SxCR_EN_POS     = 0;    /** @brief Stream enable / flag stream ready when read low */
  static const int32_t DMAx_SxNDTR_NDT_POS  = 0;    /** @brief Number of data items to transfer */
  static const int32_t DMAx_SxFCR_FEIE_POS  = 7;    /** @brief FIFO error interrupt enable */
  static const int32_t DMAx_SxFCR_FS_POS    = 3;    /** @brief FIFO status */
  static const int32_t DMAx_SxFCR_DMDIS_POS = 2;    /** @brief Direct mode disable */
  static const int32_t DMAx_SxFCR_FTH_POS   = 0;    /** @brief FIFO threshold selection */

  /**** @subsection Enumerated DMAx Register Field Positions ****/

  static const int32_t DMAx_LISR_TCIFx_POS[4] = {
    [0] = 5,    /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [1] = 11,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [2] = 21,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
    [3] = 27,   /** @brief Stream x transfer complete interrupt flag (x = 3..0) */
  };

  static const int32_t DMAx_LISR_HTIFx_POS[4] = {
    [0] = 4,    /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [1] = 10,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [2] = 20,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
    [3] = 26,   /** @brief Stream x half transfer interrupt flag (x=3..0) */
  };

  static const int32_t DMAx_LISR_TEIFx_POS[4] = {
    [0] = 3,    /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [1] = 9,    /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [2] = 19,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
    [3] = 25,   /** @brief Stream x transfer error interrupt flag (x=3..0) */
  };

  static const int32_t DMAx_LISR_DMEIFx_POS[4] = {
    [0] = 2,    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [1] = 8,    /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [2] = 18,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
    [3] = 24,   /** @brief Stream x direct mode error interrupt flag (x=3..0) */
  };

  static const int32_t DMAx_LISR_FEIFx_POS[4] = {
    [0] = 0,    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [1] = 6,    /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [2] = 16,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
    [3] = 22,   /** @brief Stream x FIFO error interrupt flag (x=3..0) */
  };

  static const int32_t DMAx_LIFCR_CTCIFx_POS[4] = {
    [0] = 5,    /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [1] = 11,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [2] = 21,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
    [3] = 27,   /** @brief Stream x clear transfer complete interrupt flag (x = 3..0) */
  };

  static const int32_t DMAx_LIFCR_CHTIFx_POS[4] = {
    [0] = 4,    /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [1] = 10,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [2] = 20,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
    [3] = 26,   /** @brief Stream x clear half transfer interrupt flag (x = 3..0) */
  };

  static const int32_t DMAx_LIFCR_CTEIFx_POS[4] = {
    [0] = 3,    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [1] = 9,    /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [2] = 19,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
    [3] = 25,   /** @brief Stream x clear transfer error interrupt flag (x = 3..0) */
  };

  static const int32_t DMAx_LIFCR_CDMEIFx_POS[4] = {
    [0] = 2,    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [1] = 8,    /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [2] = 18,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
    [3] = 24,   /** @brief Stream x clear direct mode error interrupt flag (x = 3..0) */
  };

  static const int32_t DMAx_LIFCR_CFEIFx_POS[4] = {
    [0] = 0,    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [1] = 6,    /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [2] = 16,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
    [3] = 22,   /** @brief Stream x clear FIFO error interrupt flag (x = 3..0) */
  };

  /**********************************************************************************************
   * @section HRTIM_MASTER Register Information
   **********************************************************************************************/

  /**** @subsection HRTIM_MASTER Register Pointers ****/

  static RW_ uint32_t* const HRTIM_MASTER_MCR_PTR    = (RW_ uint32_t* const)0x40017400U;   /** @brief Master timer control register */
  static RO_ uint32_t* const HRTIM_MASTER_MISR_PTR   = (RO_ uint32_t* const)0x40017404U;   /** @brief Master timer interrupt status register */
  static WO_ uint32_t* const HRTIM_MASTER_MICR_PTR   = (WO_ uint32_t* const)0x40017408U;   /** @brief Master timer interrupt clear register */
  static RW_ uint32_t* const HRTIM_MASTER_MDIER4_PTR = (RW_ uint32_t* const)0x4001740CU;   /** @brief MDIER4 */
  static RW_ uint32_t* const HRTIM_MASTER_MCNTR_PTR  = (RW_ uint32_t* const)0x40017410U;   /** @brief Master timer counter register */
  static RW_ uint32_t* const HRTIM_MASTER_MPER_PTR   = (RW_ uint32_t* const)0x40017414U;   /** @brief Master timer period register */
  static RW_ uint32_t* const HRTIM_MASTER_MREP_PTR   = (RW_ uint32_t* const)0x40017418U;   /** @brief Master timer repetition register */

  /**** @subsection Enumerated HRTIM_MASTER Register Pointers ****/

  static RW_ uint32_t* const HRTIM_MASTER_MCMPxR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x4001741CU,   /** @brief Master timer compare 1 register */
    [2] = (RW_ uint32_t* const)0x40017424U,   /** @brief Master timer compare 2 register */
    [3] = (RW_ uint32_t* const)0x40017428U,   /** @brief Master timer compare 3 register */
    [4] = (RW_ uint32_t* const)0x4001742CU,   /** @brief Master timer compare 4 register */
  };

  /**** @subsection HRTIM_MASTER Register Field Masks ****/

  static const uint32_t HRTIM_MASTER_MCR_BRSTDMA_MSK   = 0xC0000000U;   /** @brief Burst DMA update */
  static const uint32_t HRTIM_MASTER_MCR_MREPU_MSK     = 0x20000000U;   /** @brief Master timer repetition update */
  static const uint32_t HRTIM_MASTER_MCR_PREEN_MSK     = 0x08000000U;   /** @brief Preload enable */
  static const uint32_t HRTIM_MASTER_MCR_DACSYNC_MSK   = 0x06000000U;   /** @brief AC synchronization */
  static const uint32_t HRTIM_MASTER_MCR_TECEN_MSK     = 0x00200000U;   /** @brief Timer E counter enable */
  static const uint32_t HRTIM_MASTER_MCR_TDCEN_MSK     = 0x00100000U;   /** @brief Timer D counter enable */
  static const uint32_t HRTIM_MASTER_MCR_TCCEN_MSK     = 0x00080000U;   /** @brief Timer C counter enable */
  static const uint32_t HRTIM_MASTER_MCR_TBCEN_MSK     = 0x00040000U;   /** @brief Timer B counter enable */
  static const uint32_t HRTIM_MASTER_MCR_TACEN_MSK     = 0x00020000U;   /** @brief Timer A counter enable */
  static const uint32_t HRTIM_MASTER_MCR_MCEN_MSK      = 0x00010000U;   /** @brief Master counter enable */
  static const uint32_t HRTIM_MASTER_MCR_SYNC_SRC_MSK  = 0x0000C000U;   /** @brief Synchronization source */
  static const uint32_t HRTIM_MASTER_MCR_SYNC_OUT_MSK  = 0x00003000U;   /** @brief Synchronization output */
  static const uint32_t HRTIM_MASTER_MCR_SYNCSTRTM_MSK = 0x00000800U;   /** @brief Synchronization starts master */
  static const uint32_t HRTIM_MASTER_MCR_SYNCRSTM_MSK  = 0x00000400U;   /** @brief Synchronization resets master */
  static const uint32_t HRTIM_MASTER_MCR_SYNC_IN_MSK   = 0x00000300U;   /** @brief Ynchronization input */
  static const uint32_t HRTIM_MASTER_MCR_HALF_MSK      = 0x00000020U;   /** @brief Half mode enable */
  static const uint32_t HRTIM_MASTER_MCR_RETRIG_MSK    = 0x00000010U;   /** @brief Master re-triggerable mode */
  static const uint32_t HRTIM_MASTER_MCR_CONT_MSK      = 0x00000008U;   /** @brief Master continuous mode */
  static const uint32_t HRTIM_MASTER_MCR_CK_PSC_MSK    = 0x00000007U;   /** @brief HRTIM master clock prescaler */
  static const uint32_t HRTIM_MASTER_MISR_MUPD_MSK     = 0x00000040U;   /** @brief Master update interrupt flag */
  static const uint32_t HRTIM_MASTER_MISR_SYNC_MSK     = 0x00000020U;   /** @brief Sync input interrupt flag */
  static const uint32_t HRTIM_MASTER_MISR_MREP_MSK     = 0x00000010U;   /** @brief Master repetition interrupt flag */
  static const uint32_t HRTIM_MASTER_MICR_MUPDC_MSK    = 0x00000040U;   /** @brief Master update interrupt flag clear */
  static const uint32_t HRTIM_MASTER_MICR_SYNCC_MSK    = 0x00000020U;   /** @brief Sync input interrupt flag clear */
  static const uint32_t HRTIM_MASTER_MICR_MREPC_MSK    = 0x00000010U;   /** @brief Repetition interrupt flag clear */
  static const uint32_t HRTIM_MASTER_MDIER4_MUPDDE_MSK = 0x00400000U;   /** @brief MUPDDE */
  static const uint32_t HRTIM_MASTER_MDIER4_SYNCDE_MSK = 0x00200000U;   /** @brief SYNCDE */
  static const uint32_t HRTIM_MASTER_MDIER4_MREPDE_MSK = 0x00100000U;   /** @brief MREPDE */
  static const uint32_t HRTIM_MASTER_MDIER4_MUPDIE_MSK = 0x00000040U;   /** @brief MUPDIE */
  static const uint32_t HRTIM_MASTER_MDIER4_SYNCIE_MSK = 0x00000020U;   /** @brief SYNCIE */
  static const uint32_t HRTIM_MASTER_MDIER4_MREPIE_MSK = 0x00000010U;   /** @brief MREPIE */
  static const uint32_t HRTIM_MASTER_MCNTR_MCNT_MSK    = 0x0000FFFFU;   /** @brief Counter value */
  static const uint32_t HRTIM_MASTER_MPER_MPER_MSK     = 0x0000FFFFU;   /** @brief Master timer period value */
  static const uint32_t HRTIM_MASTER_MREP_MREP_MSK     = 0x000000FFU;   /** @brief Master timer repetition counter value */
  static const uint32_t HRTIM_MASTER_MCMPxR_MCMP1_MSK  = 0x0000FFFFU;   /** @brief Master timer compare 1 value */

  /**** @subsection Enumerated HRTIM_MASTER Register Field Masks ****/

  static const uint32_t HRTIM_MASTER_MISR_MCMPx_MSK[5] = {
    [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag */
    [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag */
    [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag */
    [4] = 0x00000008U,   /** @brief Master compare 4 interrupt flag */
  };

  static const uint32_t HRTIM_MASTER_MICR_MCMPxC_MSK[5] = {
    [1] = 0x00000001U,   /** @brief Master compare 1 interrupt flag clear */
    [2] = 0x00000002U,   /** @brief Master compare 2 interrupt flag clear */
    [3] = 0x00000004U,   /** @brief Master compare 3 interrupt flag clear */
    [4] = 0x00000008U,   /** @brief Master compare 4 interrupt flag clear */
  };

  static const uint32_t HRTIM_MASTER_MDIER4_MCMPxDE_MSK[5] = {
    [1] = 0x00010000U,   /** @brief MCMP1DE */
    [2] = 0x00020000U,   /** @brief MCMP2DE */
    [3] = 0x00040000U,   /** @brief MCMP3DE */
    [4] = 0x00080000U,   /** @brief MCMP4DE */
  };

  static const uint32_t HRTIM_MASTER_MDIER4_MCMPxIE_MSK[5] = {
    [1] = 0x00000001U,   /** @brief MCMP1IE */
    [2] = 0x00000002U,   /** @brief MCMP2IE */
    [3] = 0x00000004U,   /** @brief MCMP3IE */
    [4] = 0x00000008U,   /** @brief MCMP4IE */
  };

  /**** @subsection HRTIM_MASTER Register Field Positions ****/

  static const int32_t HRTIM_MASTER_MCR_BRSTDMA_POS   = 30;   /** @brief Burst DMA update */
  static const int32_t HRTIM_MASTER_MCR_MREPU_POS     = 29;   /** @brief Master timer repetition update */
  static const int32_t HRTIM_MASTER_MCR_PREEN_POS     = 27;   /** @brief Preload enable */
  static const int32_t HRTIM_MASTER_MCR_DACSYNC_POS   = 25;   /** @brief AC synchronization */
  static const int32_t HRTIM_MASTER_MCR_TECEN_POS     = 21;   /** @brief Timer E counter enable */
  static const int32_t HRTIM_MASTER_MCR_TDCEN_POS     = 20;   /** @brief Timer D counter enable */
  static const int32_t HRTIM_MASTER_MCR_TCCEN_POS     = 19;   /** @brief Timer C counter enable */
  static const int32_t HRTIM_MASTER_MCR_TBCEN_POS     = 18;   /** @brief Timer B counter enable */
  static const int32_t HRTIM_MASTER_MCR_TACEN_POS     = 17;   /** @brief Timer A counter enable */
  static const int32_t HRTIM_MASTER_MCR_MCEN_POS      = 16;   /** @brief Master counter enable */
  static const int32_t HRTIM_MASTER_MCR_SYNC_SRC_POS  = 14;   /** @brief Synchronization source */
  static const int32_t HRTIM_MASTER_MCR_SYNC_OUT_POS  = 12;   /** @brief Synchronization output */
  static const int32_t HRTIM_MASTER_MCR_SYNCSTRTM_POS = 11;   /** @brief Synchronization starts master */
  static const int32_t HRTIM_MASTER_MCR_SYNCRSTM_POS  = 10;   /** @brief Synchronization resets master */
  static const int32_t HRTIM_MASTER_MCR_SYNC_IN_POS   = 8;    /** @brief Ynchronization input */
  static const int32_t HRTIM_MASTER_MCR_HALF_POS      = 5;    /** @brief Half mode enable */
  static const int32_t HRTIM_MASTER_MCR_RETRIG_POS    = 4;    /** @brief Master re-triggerable mode */
  static const int32_t HRTIM_MASTER_MCR_CONT_POS      = 3;    /** @brief Master continuous mode */
  static const int32_t HRTIM_MASTER_MCR_CK_PSC_POS    = 0;    /** @brief HRTIM master clock prescaler */
  static const int32_t HRTIM_MASTER_MISR_MUPD_POS     = 6;    /** @brief Master update interrupt flag */
  static const int32_t HRTIM_MASTER_MISR_SYNC_POS     = 5;    /** @brief Sync input interrupt flag */
  static const int32_t HRTIM_MASTER_MISR_MREP_POS     = 4;    /** @brief Master repetition interrupt flag */
  static const int32_t HRTIM_MASTER_MICR_MUPDC_POS    = 6;    /** @brief Master update interrupt flag clear */
  static const int32_t HRTIM_MASTER_MICR_SYNCC_POS    = 5;    /** @brief Sync input interrupt flag clear */
  static const int32_t HRTIM_MASTER_MICR_MREPC_POS    = 4;    /** @brief Repetition interrupt flag clear */
  static const int32_t HRTIM_MASTER_MDIER4_MUPDDE_POS = 22;   /** @brief MUPDDE */
  static const int32_t HRTIM_MASTER_MDIER4_SYNCDE_POS = 21;   /** @brief SYNCDE */
  static const int32_t HRTIM_MASTER_MDIER4_MREPDE_POS = 20;   /** @brief MREPDE */
  static const int32_t HRTIM_MASTER_MDIER4_MUPDIE_POS = 6;    /** @brief MUPDIE */
  static const int32_t HRTIM_MASTER_MDIER4_SYNCIE_POS = 5;    /** @brief SYNCIE */
  static const int32_t HRTIM_MASTER_MDIER4_MREPIE_POS = 4;    /** @brief MREPIE */
  static const int32_t HRTIM_MASTER_MCNTR_MCNT_POS    = 0;    /** @brief Counter value */
  static const int32_t HRTIM_MASTER_MPER_MPER_POS     = 0;    /** @brief Master timer period value */
  static const int32_t HRTIM_MASTER_MREP_MREP_POS     = 0;    /** @brief Master timer repetition counter value */
  static const int32_t HRTIM_MASTER_MCMPxR_MCMP1_POS  = 0;    /** @brief Master timer compare 1 value */

  /**** @subsection Enumerated HRTIM_MASTER Register Field Positions ****/

  static const int32_t HRTIM_MASTER_MISR_MCMPx_POS[5] = {
    [1] = 0,   /** @brief Master compare 1 interrupt flag */
    [2] = 1,   /** @brief Master compare 2 interrupt flag */
    [3] = 2,   /** @brief Master compare 3 interrupt flag */
    [4] = 3,   /** @brief Master compare 4 interrupt flag */
  };

  static const int32_t HRTIM_MASTER_MICR_MCMPxC_POS[5] = {
    [1] = 0,   /** @brief Master compare 1 interrupt flag clear */
    [2] = 1,   /** @brief Master compare 2 interrupt flag clear */
    [3] = 2,   /** @brief Master compare 3 interrupt flag clear */
    [4] = 3,   /** @brief Master compare 4 interrupt flag clear */
  };

  static const int32_t HRTIM_MASTER_MDIER4_MCMPxDE_POS[5] = {
    [1] = 16,   /** @brief MCMP1DE */
    [2] = 17,   /** @brief MCMP2DE */
    [3] = 18,   /** @brief MCMP3DE */
    [4] = 19,   /** @brief MCMP4DE */
  };

  static const int32_t HRTIM_MASTER_MDIER4_MCMPxIE_POS[5] = {
    [1] = 0,   /** @brief MCMP1IE */
    [2] = 1,   /** @brief MCMP2IE */
    [3] = 2,   /** @brief MCMP3IE */
    [4] = 3,   /** @brief MCMP4IE */
  };

  /**********************************************************************************************
   * @section HRTIM_TIMx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated HRTIM_TIMx Register Pointers ****/

  static RW_ uint32_t* const HRTIM_TIMx_TIMxCR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x40017480U,   /** @brief Timerx control register */
    [1] = (RW_ uint32_t* const)0x40017500U,   /** @brief Timerx control register */
    [2] = (RW_ uint32_t* const)0x40017580U,   /** @brief Timerx control register */
    [3] = (RW_ uint32_t* const)0x40017600U,   /** @brief Timerx control register */
    [4] = (RW_ uint32_t* const)0x40017680U,   /** @brief Timerx control register */
  };

  static RO_ uint32_t* const HRTIM_TIMx_TIMxISR_PTR[5] = {
    [0] = (RO_ uint32_t* const)0x40017484U,   /** @brief Timerx interrupt status register */
    [1] = (RO_ uint32_t* const)0x40017504U,   /** @brief Timerx interrupt status register */
    [2] = (RO_ uint32_t* const)0x40017584U,   /** @brief Timerx interrupt status register */
    [3] = (RO_ uint32_t* const)0x40017604U,   /** @brief Timerx interrupt status register */
    [4] = (RO_ uint32_t* const)0x40017684U,   /** @brief Timerx interrupt status register */
  };

  static WO_ uint32_t* const HRTIM_TIMx_TIMxICR_PTR[5] = {
    [0] = (WO_ uint32_t* const)0x40017488U,   /** @brief Timerx interrupt clear register */
    [1] = (WO_ uint32_t* const)0x40017508U,   /** @brief Timerx interrupt clear register */
    [2] = (WO_ uint32_t* const)0x40017588U,   /** @brief Timerx interrupt clear register */
    [3] = (WO_ uint32_t* const)0x40017608U,   /** @brief Timerx interrupt clear register */
    [4] = (WO_ uint32_t* const)0x40017688U,   /** @brief Timerx interrupt clear register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_TIMxDIER5_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x4001748CU,   /** @brief TIMxDIER5 */
    [1] = (RW_ uint32_t* const)0x4001750CU,   /** @brief TIMxDIER5 */
    [2] = (RW_ uint32_t* const)0x4001758CU,   /** @brief TIMxDIER5 */
    [3] = (RW_ uint32_t* const)0x4001760CU,   /** @brief TIMxDIER5 */
    [4] = (RW_ uint32_t* const)0x4001768CU,   /** @brief TIMxDIER5 */
  };

  static RW_ uint32_t* const HRTIM_TIMx_CNTxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x40017490U,   /** @brief Timerx counter register */
    [1] = (RW_ uint32_t* const)0x40017510U,   /** @brief Timerx counter register */
    [2] = (RW_ uint32_t* const)0x40017590U,   /** @brief Timerx counter register */
    [3] = (RW_ uint32_t* const)0x40017610U,   /** @brief Timerx counter register */
    [4] = (RW_ uint32_t* const)0x40017690U,   /** @brief Timerx counter register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_PERxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x40017494U,   /** @brief Timerx period register */
    [1] = (RW_ uint32_t* const)0x40017514U,   /** @brief Timerx period register */
    [2] = (RW_ uint32_t* const)0x40017594U,   /** @brief Timerx period register */
    [3] = (RW_ uint32_t* const)0x40017614U,   /** @brief Timerx period register */
    [4] = (RW_ uint32_t* const)0x40017694U,   /** @brief Timerx period register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_REPxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x40017498U,   /** @brief Timerx repetition register */
    [1] = (RW_ uint32_t* const)0x40017518U,   /** @brief Timerx repetition register */
    [2] = (RW_ uint32_t* const)0x40017598U,   /** @brief Timerx repetition register */
    [3] = (RW_ uint32_t* const)0x40017618U,   /** @brief Timerx repetition register */
    [4] = (RW_ uint32_t* const)0x40017698U,   /** @brief Timerx repetition register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_CMPxxR_PTR[5][5] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x4001749CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x400174A4U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x400174A8U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x400174ACU,   /** @brief Timerx compare 4 register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x4001751CU,   /** @brief Timerx compare 1 register */
      [2] = (RW_ uint32_t* const)0x40017524U,   /** @brief Timerx compare 2 register */
      [3] = (RW_ uint32_t* const)0x40017528U,   /** @brief Timerx compare 3 register */
      [4] = (RW_ uint32_t* const)0x4001752CU,   /** @brief Timerx compare 4 register */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_CMP1CxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174A0U,   /** @brief Timerx compare 1 compound register */
    [1] = (RW_ uint32_t* const)0x40017520U,   /** @brief Timerx compare 1 compound register */
    [2] = (RW_ uint32_t* const)0x400175A0U,   /** @brief Timerx compare 1 compound register */
    [3] = (RW_ uint32_t* const)0x40017620U,   /** @brief Timerx compare 1 compound register */
    [4] = (RW_ uint32_t* const)0x400176A0U,   /** @brief Timerx compare 1 compound register */
  };

  static RO_ uint32_t* const HRTIM_TIMx_CPTxxR_PTR[5][3] = {
    [0] = {
      [1] = (RO_ uint32_t* const)0x400174B0U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x400174B4U,   /** @brief Timerx capture 2 register */
    },
    [1] = {
      [1] = (RO_ uint32_t* const)0x40017530U,   /** @brief Timerx capture 1 register */
      [2] = (RO_ uint32_t* const)0x40017534U,   /** @brief Timerx capture 2 register */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_DTxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174B8U,   /** @brief Timerx deadtime register */
    [1] = (RW_ uint32_t* const)0x40017538U,   /** @brief Timerx deadtime register */
    [2] = (RW_ uint32_t* const)0x400175B8U,   /** @brief Timerx deadtime register */
    [3] = (RW_ uint32_t* const)0x40017638U,   /** @brief Timerx deadtime register */
    [4] = (RW_ uint32_t* const)0x400176B8U,   /** @brief Timerx deadtime register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_SETxxR_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x400174BCU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x400174C4U,   /** @brief Timerx output2 set register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x4001753CU,   /** @brief Timerx output1 set register */
      [2] = (RW_ uint32_t* const)0x40017544U,   /** @brief Timerx output2 set register */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_RSTxxR_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x400174C0U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x400174C8U,   /** @brief Timerx output2 reset register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40017540U,   /** @brief Timerx output1 reset register */
      [2] = (RW_ uint32_t* const)0x40017548U,   /** @brief Timerx output2 reset register */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_EEFxRx_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x400174CCU,   /** @brief Timerx external event filtering register 1 */
      [2] = (RW_ uint32_t* const)0x400174D0U,   /** @brief Timerx external event filtering register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x4001754CU,   /** @brief Timerx external event filtering register 1 */
      [2] = (RW_ uint32_t* const)0x40017550U,   /** @brief Timerx external event filtering register 2 */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_RSTxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174D4U,   /** @brief TimerA reset register */
    [1] = (RW_ uint32_t* const)0x40017554U,   /** @brief TimerA reset register */
    [2] = (RW_ uint32_t* const)0x400175D4U,   /** @brief TimerA reset register */
    [3] = (RW_ uint32_t* const)0x40017654U,   /** @brief TimerA reset register */
    [4] = (RW_ uint32_t* const)0x400176D4U,   /** @brief TimerA reset register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_CHPxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174D8U,   /** @brief Timerx chopper register */
    [1] = (RW_ uint32_t* const)0x40017558U,   /** @brief Timerx chopper register */
    [2] = (RW_ uint32_t* const)0x400175D8U,   /** @brief Timerx chopper register */
    [3] = (RW_ uint32_t* const)0x40017658U,   /** @brief Timerx chopper register */
    [4] = (RW_ uint32_t* const)0x400176D8U,   /** @brief Timerx chopper register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_CPTxxCR_PTR[5][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x400174DCU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x400174E0U,   /** @brief CPT2xCR */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x4001755CU,   /** @brief Timerx capture 2 control register */
      [2] = (RW_ uint32_t* const)0x40017560U,   /** @brief CPT2xCR */
    },
  };

  static RW_ uint32_t* const HRTIM_TIMx_OUTxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174E4U,   /** @brief Timerx output register */
    [1] = (RW_ uint32_t* const)0x40017564U,   /** @brief Timerx output register */
    [2] = (RW_ uint32_t* const)0x400175E4U,   /** @brief Timerx output register */
    [3] = (RW_ uint32_t* const)0x40017664U,   /** @brief Timerx output register */
    [4] = (RW_ uint32_t* const)0x400176E4U,   /** @brief Timerx output register */
  };

  static RW_ uint32_t* const HRTIM_TIMx_FLTxR_PTR[5] = {
    [0] = (RW_ uint32_t* const)0x400174E8U,   /** @brief Timerx fault register */
    [1] = (RW_ uint32_t* const)0x40017568U,   /** @brief Timerx fault register */
    [2] = (RW_ uint32_t* const)0x400175E8U,   /** @brief Timerx fault register */
    [3] = (RW_ uint32_t* const)0x40017668U,   /** @brief Timerx fault register */
    [4] = (RW_ uint32_t* const)0x400176E8U,   /** @brief Timerx fault register */
  };

  /**** @subsection HRTIM_TIMx Register Field Masks ****/

  static const uint32_t HRTIM_TIMx_TIMxCR_UPDGAT_MSK      = 0xF0000000U;   /** @brief Update gating */
  static const uint32_t HRTIM_TIMx_TIMxCR_PREEN_MSK       = 0x08000000U;   /** @brief Preload enable */
  static const uint32_t HRTIM_TIMx_TIMxCR_DACSYNC_MSK     = 0x06000000U;   /** @brief AC synchronization */
  static const uint32_t HRTIM_TIMx_TIMxCR_MSTU_MSK        = 0x01000000U;   /** @brief Master timer update */
  static const uint32_t HRTIM_TIMx_TIMxCR_TEU_MSK         = 0x00800000U;   /** @brief TEU */
  static const uint32_t HRTIM_TIMx_TIMxCR_TDU_MSK         = 0x00400000U;   /** @brief TDU */
  static const uint32_t HRTIM_TIMx_TIMxCR_TCU_MSK         = 0x00200000U;   /** @brief TCU */
  static const uint32_t HRTIM_TIMx_TIMxCR_TBU_MSK         = 0x00100000U;   /** @brief TBU */
  static const uint32_t HRTIM_TIMx_TIMxCR_TXRSTU_MSK      = 0x00040000U;   /** @brief Timerx reset update */
  static const uint32_t HRTIM_TIMx_TIMxCR_TXREPU_MSK      = 0x00020000U;   /** @brief Timer x repetition update */
  static const uint32_t HRTIM_TIMx_TIMxCR_SYNCSTRTX_MSK   = 0x00000800U;   /** @brief Synchronization starts timer x */
  static const uint32_t HRTIM_TIMx_TIMxCR_SYNCRSTX_MSK    = 0x00000400U;   /** @brief Synchronization resets timer x */
  static const uint32_t HRTIM_TIMx_TIMxCR_PSHPLL_MSK      = 0x00000040U;   /** @brief Push-Pull mode enable */
  static const uint32_t HRTIM_TIMx_TIMxCR_HALF_MSK        = 0x00000020U;   /** @brief Half mode enable */
  static const uint32_t HRTIM_TIMx_TIMxCR_RETRIG_MSK      = 0x00000010U;   /** @brief Re-triggerable mode */
  static const uint32_t HRTIM_TIMx_TIMxCR_CONT_MSK        = 0x00000008U;   /** @brief Continuous mode */
  static const uint32_t HRTIM_TIMx_TIMxCR_CK_PSCX_MSK     = 0x00000007U;   /** @brief HRTIM timer x clock prescaler */
  static const uint32_t HRTIM_TIMx_TIMxISR_IPPSTAT_MSK    = 0x00020000U;   /** @brief Idle push pull status */
  static const uint32_t HRTIM_TIMx_TIMxISR_CPPSTAT_MSK    = 0x00010000U;   /** @brief Current push pull status */
  static const uint32_t HRTIM_TIMx_TIMxISR_DLYPRT_MSK     = 0x00004000U;   /** @brief Delayed protection flag */
  static const uint32_t HRTIM_TIMx_TIMxISR_RST_MSK        = 0x00002000U;   /** @brief Reset interrupt flag */
  static const uint32_t HRTIM_TIMx_TIMxISR_UPD_MSK        = 0x00000040U;   /** @brief Update interrupt flag */
  static const uint32_t HRTIM_TIMx_TIMxISR_REP_MSK        = 0x00000010U;   /** @brief Repetition interrupt flag */
  static const uint32_t HRTIM_TIMx_TIMxICR_DLYPRTC_MSK    = 0x00004000U;   /** @brief Delayed protection flag clear */
  static const uint32_t HRTIM_TIMx_TIMxICR_RSTC_MSK       = 0x00002000U;   /** @brief Reset interrupt flag clear */
  static const uint32_t HRTIM_TIMx_TIMxICR_UPDC_MSK       = 0x00000040U;   /** @brief Update interrupt flag clear */
  static const uint32_t HRTIM_TIMx_TIMxICR_REPC_MSK       = 0x00000010U;   /** @brief Repetition interrupt flag clear */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_DLYPRTDE_MSK = 0x40000000U;   /** @brief DLYPRTDE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_RSTDE_MSK    = 0x20000000U;   /** @brief RSTDE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_SETX2DE_MSK  = 0x08000000U;   /** @brief SETx2DE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_SET1XDE_MSK  = 0x02000000U;   /** @brief SET1xDE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_UPDDE_MSK    = 0x00400000U;   /** @brief UPDDE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_REPDE_MSK    = 0x00100000U;   /** @brief REPDE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_DLYPRTIE_MSK = 0x00004000U;   /** @brief DLYPRTIE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_RSTIE_MSK    = 0x00002000U;   /** @brief RSTIE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_SETX2IE_MSK  = 0x00000800U;   /** @brief SETx2IE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_SET1XIE_MSK  = 0x00000200U;   /** @brief SET1xIE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_UPDIE_MSK    = 0x00000040U;   /** @brief UPDIE */
  static const uint32_t HRTIM_TIMx_TIMxDIER5_REPIE_MSK    = 0x00000010U;   /** @brief REPIE */
  static const uint32_t HRTIM_TIMx_CNTxR_CNTX_MSK         = 0x0000FFFFU;   /** @brief Timerx counter value */
  static const uint32_t HRTIM_TIMx_PERxR_PERX_MSK         = 0x0000FFFFU;   /** @brief Timerx period value */
  static const uint32_t HRTIM_TIMx_REPxR_REPX_MSK         = 0x000000FFU;   /** @brief Timerx repetition counter value */
  static const uint32_t HRTIM_TIMx_CMPxxR_CMP1X_MSK       = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
  static const uint32_t HRTIM_TIMx_CMP1CxR_REPX_MSK       = 0x00FF0000U;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
  static const uint32_t HRTIM_TIMx_CMP1CxR_CMP1X_MSK      = 0x0000FFFFU;   /** @brief Timerx compare 1 value */
  static const uint32_t HRTIM_TIMx_CPTxxR_CPT1X_MSK       = 0x0000FFFFU;   /** @brief Timerx capture 1 value */
  static const uint32_t HRTIM_TIMx_DTxR_DTFLKX_MSK        = 0x80000000U;   /** @brief Deadtime falling lock */
  static const uint32_t HRTIM_TIMx_DTxR_DTFSLKX_MSK       = 0x40000000U;   /** @brief Deadtime falling sign lock */
  static const uint32_t HRTIM_TIMx_DTxR_SDTFX_MSK         = 0x02000000U;   /** @brief Sign deadtime falling value */
  static const uint32_t HRTIM_TIMx_DTxR_DTFX_MSK          = 0x01FF0000U;   /** @brief Deadtime falling value */
  static const uint32_t HRTIM_TIMx_DTxR_DTRLKX_MSK        = 0x00008000U;   /** @brief Deadtime rising lock */
  static const uint32_t HRTIM_TIMx_DTxR_DTRSLKX_MSK       = 0x00004000U;   /** @brief Deadtime rising sign lock */
  static const uint32_t HRTIM_TIMx_DTxR_DTPRSC_MSK        = 0x00001C00U;   /** @brief Deadtime prescaler */
  static const uint32_t HRTIM_TIMx_DTxR_SDTRX_MSK         = 0x00000200U;   /** @brief Sign deadtime rising value */
  static const uint32_t HRTIM_TIMx_DTxR_DTRX_MSK          = 0x000001FFU;   /** @brief Deadtime rising value */
  static const uint32_t HRTIM_TIMx_SETxxR_UPDATE_MSK      = 0x80000000U;   /** @brief Registers update (transfer preload to active) */
  static const uint32_t HRTIM_TIMx_SETxxR_MSTPER_MSK      = 0x00000080U;   /** @brief Master period */
  static const uint32_t HRTIM_TIMx_SETxxR_PER_MSK         = 0x00000004U;   /** @brief Timer A period */
  static const uint32_t HRTIM_TIMx_SETxxR_RESYNC_MSK      = 0x00000002U;   /** @brief Timer A resynchronizaton */
  static const uint32_t HRTIM_TIMx_SETxxR_SST_MSK         = 0x00000001U;   /** @brief Software set trigger */
  static const uint32_t HRTIM_TIMx_RSTxxR_UPDATE_MSK      = 0x80000000U;   /** @brief UPDATE */
  static const uint32_t HRTIM_TIMx_RSTxxR_MSTPER_MSK      = 0x00000080U;   /** @brief MSTPER */
  static const uint32_t HRTIM_TIMx_RSTxxR_PER_MSK         = 0x00000004U;   /** @brief PER */
  static const uint32_t HRTIM_TIMx_RSTxxR_RESYNC_MSK      = 0x00000002U;   /** @brief RESYNC */
  static const uint32_t HRTIM_TIMx_RSTxxR_SRT_MSK         = 0x00000001U;   /** @brief SRT */
  static const uint32_t HRTIM_TIMx_RSTxR_MSTPER_MSK       = 0x00000010U;   /** @brief Master timer period */
  static const uint32_t HRTIM_TIMx_RSTxR_UPDT_MSK         = 0x00000002U;   /** @brief Timer A update reset */
  static const uint32_t HRTIM_TIMx_CHPxR_STRTPW_MSK       = 0x00000780U;   /** @brief STRTPW */
  static const uint32_t HRTIM_TIMx_CHPxR_CHPDTY_MSK       = 0x00000070U;   /** @brief Timerx chopper duty cycle value */
  static const uint32_t HRTIM_TIMx_CHPxR_CHPFRQ_MSK       = 0x0000000FU;   /** @brief Timerx carrier frequency value */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TE1RST_MSK     = 0x20000000U;   /** @brief Timer E output 1 reset */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TE1SET_MSK     = 0x10000000U;   /** @brief Timer E output 1 set */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TD1RST_MSK     = 0x02000000U;   /** @brief Timer D output 1 reset */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TD1SET_MSK     = 0x01000000U;   /** @brief Timer D output 1 set */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TC1RST_MSK     = 0x00200000U;   /** @brief Timer C output 1 reset */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TC1SET_MSK     = 0x00100000U;   /** @brief Timer C output 1 set */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TB1RST_MSK     = 0x00020000U;   /** @brief Timer B output 1 reset */
  static const uint32_t HRTIM_TIMx_CPTxxCR_TB1SET_MSK     = 0x00010000U;   /** @brief Timer B output 1 set */
  static const uint32_t HRTIM_TIMx_CPTxxCR_UDPCPT_MSK     = 0x00000002U;   /** @brief Update capture */
  static const uint32_t HRTIM_TIMx_CPTxxCR_SWCPT_MSK      = 0x00000001U;   /** @brief Software capture */
  static const uint32_t HRTIM_TIMx_OUTxR_DLYPRT_MSK       = 0x00001C00U;   /** @brief Delayed protection */
  static const uint32_t HRTIM_TIMx_OUTxR_DLYPRTEN_MSK     = 0x00000200U;   /** @brief Delayed protection enable */
  static const uint32_t HRTIM_TIMx_OUTxR_DTEN_MSK         = 0x00000100U;   /** @brief Deadtime enable */
  static const uint32_t HRTIM_TIMx_FLTxR_FLTLCK_MSK       = 0x80000000U;   /** @brief Fault sources lock */

  /**** @subsection Enumerated HRTIM_TIMx Register Field Masks ****/

  static const uint32_t HRTIM_TIMx_TIMxCR_DELCMPx_MSK[5] = {
    [2] = 0x00003000U,   /** @brief Delayed CMP2 mode */
    [4] = 0x0000C000U,   /** @brief Delayed CMP4 mode */
  };

  static const uint32_t HRTIM_TIMx_TIMxISR_OxSTAT_MSK[3] = {
    [1] = 0x00040000U,   /** @brief Output 1 state */
    [2] = 0x00080000U,   /** @brief Output 2 state */
  };

  static const uint32_t HRTIM_TIMx_TIMxISR_RSTXx_MSK[3] = {
    [1] = 0x00000400U,   /** @brief Output 1 reset interrupt flag */
    [2] = 0x00001000U,   /** @brief Output 2 reset interrupt flag */
  };

  static const uint32_t HRTIM_TIMx_TIMxISR_SETXx_MSK[3] = {
    [1] = 0x00000200U,   /** @brief Output 1 set interrupt flag */
    [2] = 0x00000800U,   /** @brief Output 2 set interrupt flag */
  };

  static const uint32_t HRTIM_TIMx_TIMxISR_CPTx_MSK[3] = {
    [1] = 0x00000080U,   /** @brief Capture1 interrupt flag */
    [2] = 0x00000100U,   /** @brief Capture2 interrupt flag */
  };

  static const uint32_t HRTIM_TIMx_TIMxISR_CMPx_MSK[5] = {
    [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag */
    [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag */
    [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag */
    [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag */
  };

  static const uint32_t HRTIM_TIMx_TIMxICR_RSTXxC_MSK[3] = {
    [1] = 0x00000400U,   /** @brief Output 1 reset flag clear */
    [2] = 0x00001000U,   /** @brief Output 2 reset flag clear */
  };

  static const uint32_t HRTIM_TIMx_TIMxICR_SETxXC_MSK[3] = {
    [1] = 0x00000200U,   /** @brief Output 1 set flag clear */
    [2] = 0x00000800U,   /** @brief Output 2 set flag clear */
  };

  static const uint32_t HRTIM_TIMx_TIMxICR_CPTxC_MSK[3] = {
    [1] = 0x00000080U,   /** @brief Capture1 interrupt flag clear */
    [2] = 0x00000100U,   /** @brief Capture2 interrupt flag clear */
  };

  static const uint32_t HRTIM_TIMx_TIMxICR_CMPxC_MSK[5] = {
    [1] = 0x00000001U,   /** @brief Compare 1 interrupt flag clear */
    [2] = 0x00000002U,   /** @brief Compare 2 interrupt flag clear */
    [3] = 0x00000004U,   /** @brief Compare 3 interrupt flag clear */
    [4] = 0x00000008U,   /** @brief Compare 4 interrupt flag clear */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_RSTXxDE_MSK[3] = {
    [1] = 0x04000000U,   /** @brief RSTx1DE */
    [2] = 0x10000000U,   /** @brief RSTx2DE */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_CPTxDE_MSK[3] = {
    [1] = 0x00800000U,   /** @brief CPT1DE */
    [2] = 0x01000000U,   /** @brief CPT2DE */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_CMPxDE_MSK[5] = {
    [1] = 0x00010000U,   /** @brief CMP1DE */
    [2] = 0x00020000U,   /** @brief CMP2DE */
    [3] = 0x00040000U,   /** @brief CMP3DE */
    [4] = 0x00080000U,   /** @brief CMP4DE */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_RSTXxIE_MSK[3] = {
    [1] = 0x00000400U,   /** @brief RSTx1IE */
    [2] = 0x00001000U,   /** @brief RSTx2IE */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_CPTxIE_MSK[3] = {
    [1] = 0x00000080U,   /** @brief CPT1IE */
    [2] = 0x00000100U,   /** @brief CPT2IE */
  };

  static const uint32_t HRTIM_TIMx_TIMxDIER5_CMPxIE_MSK[5] = {
    [1] = 0x00000001U,   /** @brief CMP1IE */
    [2] = 0x00000002U,   /** @brief CMP2IE */
    [3] = 0x00000004U,   /** @brief CMP3IE */
    [4] = 0x00000008U,   /** @brief CMP4IE */
  };

  static const uint32_t HRTIM_TIMx_SETxxR_EXTEVNTx_MSK[11] = {
    [1]  = 0x00200000U,   /** @brief External event 1 */
    [2]  = 0x00400000U,   /** @brief External event 2 */
    [3]  = 0x00800000U,   /** @brief External event 3 */
    [4]  = 0x01000000U,   /** @brief External event 4 */
    [5]  = 0x02000000U,   /** @brief External event 5 */
    [6]  = 0x04000000U,   /** @brief External event 6 */
    [7]  = 0x08000000U,   /** @brief External event 7 */
    [8]  = 0x10000000U,   /** @brief External event 8 */
    [9]  = 0x20000000U,   /** @brief External event 9 */
    [10] = 0x40000000U,   /** @brief External event 10 */
  };

  static const uint32_t HRTIM_TIMx_SETxxR_TIMEVNTx_MSK[10] = {
    [1]  = 0x00001000U,   /** @brief Timer event 1 */
    [2]  = 0x00002000U,   /** @brief Timer event 2 */
    [3]  = 0x00004000U,   /** @brief Timer event 3 */
    [4]  = 0x00008000U,   /** @brief Timer event 4 */
    [5]  = 0x00010000U,   /** @brief Timer event 5 */
    [6]  = 0x00020000U,   /** @brief Timer event 6 */
    [7]  = 0x00040000U,   /** @brief Timer event 7 */
    [8]  = 0x00080000U,   /** @brief Timer event 8 */
    [9]  = 0x00100000U,   /** @brief Timer event 9 */
  };

  static const uint32_t HRTIM_TIMx_SETxxR_MSTCMPx_MSK[5] = {
    [1] = 0x00000100U,   /** @brief Master compare 1 */
    [2] = 0x00000200U,   /** @brief Master compare 2 */
    [3] = 0x00000400U,   /** @brief Master compare 3 */
    [4] = 0x00000800U,   /** @brief Master compare 4 */
  };

  static const uint32_t HRTIM_TIMx_EEFxRx_EExFLTR_MSK[6] = {
    [1] = 0x0000001EU,   /** @brief External event 1 filter */
    [2] = 0x00000780U,   /** @brief External event 2 filter */
    [3] = 0x0001E000U,   /** @brief External event 3 filter */
    [4] = 0x00780000U,   /** @brief External event 4 filter */
    [5] = 0x1E000000U,   /** @brief External event 5 filter */
  };

  static const uint32_t HRTIM_TIMx_EEFxRx_EExLTCH_MSK[6] = {
    [1] = 0x00000001U,   /** @brief External event 1 latch */
    [2] = 0x00000040U,   /** @brief External event 2 latch */
    [3] = 0x00001000U,   /** @brief External event 3 latch */
    [4] = 0x00040000U,   /** @brief External event 4 latch */
    [5] = 0x01000000U,   /** @brief External event 5 latch */
  };

  static const uint32_t HRTIM_TIMx_RSTxR_TIMECMPx_MSK[5] = {
    [1] = 0x10000000U,   /** @brief Timer E compare 1 */
    [2] = 0x20000000U,   /** @brief Timer E compare 2 */
    [4] = 0x40000000U,   /** @brief Timer E compare 4 */
  };

  static const uint32_t HRTIM_TIMx_RSTxR_TIMDCMPx_MSK[5] = {
    [1] = 0x02000000U,   /** @brief Timer D compare 1 */
    [2] = 0x04000000U,   /** @brief Timer D compare 2 */
    [4] = 0x08000000U,   /** @brief Timer D compare 4 */
  };

  static const uint32_t HRTIM_TIMx_RSTxR_TIMCCMPx_MSK[5] = {
    [1] = 0x00400000U,   /** @brief Timer C compare 1 */
    [2] = 0x00800000U,   /** @brief Timer C compare 2 */
    [4] = 0x01000000U,   /** @brief Timer C compare 4 */
  };

  static const uint32_t HRTIM_TIMx_RSTxR_TIMBCMPx_MSK[5] = {
    [1] = 0x00080000U,   /** @brief Timer B compare 1 */
    [2] = 0x00100000U,   /** @brief Timer B compare 2 */
    [4] = 0x00200000U,   /** @brief Timer B compare 4 */
  };

  static const uint32_t HRTIM_TIMx_CPTxxCR_TECMPx_MSK[3] = {
    [1] = 0x40000000U,   /** @brief Timer E compare 1 */
    [2] = 0x80000000U,   /** @brief Timer E compare 2 */
  };

  static const uint32_t HRTIM_TIMx_CPTxxCR_TDCMPx_MSK[3] = {
    [1] = 0x04000000U,   /** @brief Timer D compare 1 */
    [2] = 0x08000000U,   /** @brief Timer D compare 2 */
  };

  static const uint32_t HRTIM_TIMx_CPTxxCR_TCCMPx_MSK[3] = {
    [1] = 0x00400000U,   /** @brief Timer C compare 1 */
    [2] = 0x00800000U,   /** @brief Timer C compare 2 */
  };

  static const uint32_t HRTIM_TIMx_CPTxxCR_TBCMPx_MSK[3] = {
    [1] = 0x00040000U,   /** @brief Timer B compare 1 */
    [2] = 0x00080000U,   /** @brief Timer B compare 2 */
  };

  static const uint32_t HRTIM_TIMx_CPTxxCR_EXEVxCPT_MSK[11] = {
    [1]  = 0x00000004U,   /** @brief External event 1 capture */
    [2]  = 0x00000008U,   /** @brief External event 2 capture */
    [3]  = 0x00000010U,   /** @brief External event 3 capture */
    [4]  = 0x00000020U,   /** @brief External event 4 capture */
    [5]  = 0x00000040U,   /** @brief External event 5 capture */
    [6]  = 0x00000080U,   /** @brief External event 6 capture */
    [7]  = 0x00000100U,   /** @brief External event 7 capture */
    [8]  = 0x00000200U,   /** @brief External event 8 capture */
    [9]  = 0x00000400U,   /** @brief External event 9 capture */
    [10] = 0x00000800U,   /** @brief External event 10 capture */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_DIDLx_MSK[3] = {
    [1] = 0x00000080U,   /** @brief Output 1 deadtime upon burst mode idle entry */
    [2] = 0x00800000U,   /** @brief Output 2 deadtime upon burst mode idle entry */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_CHPx_MSK[3] = {
    [1] = 0x00000040U,   /** @brief Output 1 chopper enable */
    [2] = 0x00400000U,   /** @brief Output 2 chopper enable */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_FAULTx_MSK[3] = {
    [1] = 0x00000030U,   /** @brief Output 1 fault state */
    [2] = 0x00300000U,   /** @brief Output 2 fault state */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_IDLESx_MSK[3] = {
    [1] = 0x00000008U,   /** @brief Output 1 idle state */
    [2] = 0x00080000U,   /** @brief Output 2 idle state */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_IDLEMx_MSK[3] = {
    [1] = 0x00000004U,   /** @brief Output 1 idle mode */
    [2] = 0x00040000U,   /** @brief Output 2 idle mode */
  };

  static const uint32_t HRTIM_TIMx_OUTxR_POLx_MSK[3] = {
    [1] = 0x00000002U,   /** @brief Output 1 polarity */
    [2] = 0x00020000U,   /** @brief Output 2 polarity */
  };

  static const uint32_t HRTIM_TIMx_FLTxR_FLTxEN_MSK[6] = {
    [1] = 0x00000001U,   /** @brief Fault 1 enable */
    [2] = 0x00000002U,   /** @brief Fault 2 enable */
    [3] = 0x00000004U,   /** @brief Fault 3 enable */
    [4] = 0x00000008U,   /** @brief Fault 4 enable */
    [5] = 0x00000010U,   /** @brief Fault 5 enable */
  };

  /**** @subsection HRTIM_TIMx Register Field Positions ****/

  static const int32_t HRTIM_TIMx_TIMxCR_UPDGAT_POS      = 28;   /** @brief Update gating */
  static const int32_t HRTIM_TIMx_TIMxCR_PREEN_POS       = 27;   /** @brief Preload enable */
  static const int32_t HRTIM_TIMx_TIMxCR_DACSYNC_POS     = 25;   /** @brief AC synchronization */
  static const int32_t HRTIM_TIMx_TIMxCR_MSTU_POS        = 24;   /** @brief Master timer update */
  static const int32_t HRTIM_TIMx_TIMxCR_TEU_POS         = 23;   /** @brief TEU */
  static const int32_t HRTIM_TIMx_TIMxCR_TDU_POS         = 22;   /** @brief TDU */
  static const int32_t HRTIM_TIMx_TIMxCR_TCU_POS         = 21;   /** @brief TCU */
  static const int32_t HRTIM_TIMx_TIMxCR_TBU_POS         = 20;   /** @brief TBU */
  static const int32_t HRTIM_TIMx_TIMxCR_TXRSTU_POS      = 18;   /** @brief Timerx reset update */
  static const int32_t HRTIM_TIMx_TIMxCR_TXREPU_POS      = 17;   /** @brief Timer x repetition update */
  static const int32_t HRTIM_TIMx_TIMxCR_SYNCSTRTX_POS   = 11;   /** @brief Synchronization starts timer x */
  static const int32_t HRTIM_TIMx_TIMxCR_SYNCRSTX_POS    = 10;   /** @brief Synchronization resets timer x */
  static const int32_t HRTIM_TIMx_TIMxCR_PSHPLL_POS      = 6;    /** @brief Push-Pull mode enable */
  static const int32_t HRTIM_TIMx_TIMxCR_HALF_POS        = 5;    /** @brief Half mode enable */
  static const int32_t HRTIM_TIMx_TIMxCR_RETRIG_POS      = 4;    /** @brief Re-triggerable mode */
  static const int32_t HRTIM_TIMx_TIMxCR_CONT_POS        = 3;    /** @brief Continuous mode */
  static const int32_t HRTIM_TIMx_TIMxCR_CK_PSCX_POS     = 0;    /** @brief HRTIM timer x clock prescaler */
  static const int32_t HRTIM_TIMx_TIMxISR_IPPSTAT_POS    = 17;   /** @brief Idle push pull status */
  static const int32_t HRTIM_TIMx_TIMxISR_CPPSTAT_POS    = 16;   /** @brief Current push pull status */
  static const int32_t HRTIM_TIMx_TIMxISR_DLYPRT_POS     = 14;   /** @brief Delayed protection flag */
  static const int32_t HRTIM_TIMx_TIMxISR_RST_POS        = 13;   /** @brief Reset interrupt flag */
  static const int32_t HRTIM_TIMx_TIMxISR_UPD_POS        = 6;    /** @brief Update interrupt flag */
  static const int32_t HRTIM_TIMx_TIMxISR_REP_POS        = 4;    /** @brief Repetition interrupt flag */
  static const int32_t HRTIM_TIMx_TIMxICR_DLYPRTC_POS    = 14;   /** @brief Delayed protection flag clear */
  static const int32_t HRTIM_TIMx_TIMxICR_RSTC_POS       = 13;   /** @brief Reset interrupt flag clear */
  static const int32_t HRTIM_TIMx_TIMxICR_UPDC_POS       = 6;    /** @brief Update interrupt flag clear */
  static const int32_t HRTIM_TIMx_TIMxICR_REPC_POS       = 4;    /** @brief Repetition interrupt flag clear */
  static const int32_t HRTIM_TIMx_TIMxDIER5_DLYPRTDE_POS = 30;   /** @brief DLYPRTDE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_RSTDE_POS    = 29;   /** @brief RSTDE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_SETX2DE_POS  = 27;   /** @brief SETx2DE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_SET1XDE_POS  = 25;   /** @brief SET1xDE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_UPDDE_POS    = 22;   /** @brief UPDDE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_REPDE_POS    = 20;   /** @brief REPDE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_DLYPRTIE_POS = 14;   /** @brief DLYPRTIE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_RSTIE_POS    = 13;   /** @brief RSTIE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_SETX2IE_POS  = 11;   /** @brief SETx2IE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_SET1XIE_POS  = 9;    /** @brief SET1xIE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_UPDIE_POS    = 6;    /** @brief UPDIE */
  static const int32_t HRTIM_TIMx_TIMxDIER5_REPIE_POS    = 4;    /** @brief REPIE */
  static const int32_t HRTIM_TIMx_CNTxR_CNTX_POS         = 0;    /** @brief Timerx counter value */
  static const int32_t HRTIM_TIMx_PERxR_PERX_POS         = 0;    /** @brief Timerx period value */
  static const int32_t HRTIM_TIMx_REPxR_REPX_POS         = 0;    /** @brief Timerx repetition counter value */
  static const int32_t HRTIM_TIMx_CMPxxR_CMP1X_POS       = 0;    /** @brief Timerx compare 1 value */
  static const int32_t HRTIM_TIMx_CMP1CxR_REPX_POS       = 16;   /** @brief Timerx repetition value (aliased from hrtim_repx register) */
  static const int32_t HRTIM_TIMx_CMP1CxR_CMP1X_POS      = 0;    /** @brief Timerx compare 1 value */
  static const int32_t HRTIM_TIMx_CPTxxR_CPT1X_POS       = 0;    /** @brief Timerx capture 1 value */
  static const int32_t HRTIM_TIMx_DTxR_DTFLKX_POS        = 31;   /** @brief Deadtime falling lock */
  static const int32_t HRTIM_TIMx_DTxR_DTFSLKX_POS       = 30;   /** @brief Deadtime falling sign lock */
  static const int32_t HRTIM_TIMx_DTxR_SDTFX_POS         = 25;   /** @brief Sign deadtime falling value */
  static const int32_t HRTIM_TIMx_DTxR_DTFX_POS          = 16;   /** @brief Deadtime falling value */
  static const int32_t HRTIM_TIMx_DTxR_DTRLKX_POS        = 15;   /** @brief Deadtime rising lock */
  static const int32_t HRTIM_TIMx_DTxR_DTRSLKX_POS       = 14;   /** @brief Deadtime rising sign lock */
  static const int32_t HRTIM_TIMx_DTxR_DTPRSC_POS        = 10;   /** @brief Deadtime prescaler */
  static const int32_t HRTIM_TIMx_DTxR_SDTRX_POS         = 9;    /** @brief Sign deadtime rising value */
  static const int32_t HRTIM_TIMx_DTxR_DTRX_POS          = 0;    /** @brief Deadtime rising value */
  static const int32_t HRTIM_TIMx_SETxxR_UPDATE_POS      = 31;   /** @brief Registers update (transfer preload to active) */
  static const int32_t HRTIM_TIMx_SETxxR_MSTPER_POS      = 7;    /** @brief Master period */
  static const int32_t HRTIM_TIMx_SETxxR_PER_POS         = 2;    /** @brief Timer A period */
  static const int32_t HRTIM_TIMx_SETxxR_RESYNC_POS      = 1;    /** @brief Timer A resynchronizaton */
  static const int32_t HRTIM_TIMx_SETxxR_SST_POS         = 0;    /** @brief Software set trigger */
  static const int32_t HRTIM_TIMx_RSTxxR_UPDATE_POS      = 31;   /** @brief UPDATE */
  static const int32_t HRTIM_TIMx_RSTxxR_MSTPER_POS      = 7;    /** @brief MSTPER */
  static const int32_t HRTIM_TIMx_RSTxxR_PER_POS         = 2;    /** @brief PER */
  static const int32_t HRTIM_TIMx_RSTxxR_RESYNC_POS      = 1;    /** @brief RESYNC */
  static const int32_t HRTIM_TIMx_RSTxxR_SRT_POS         = 0;    /** @brief SRT */
  static const int32_t HRTIM_TIMx_RSTxR_MSTPER_POS       = 4;    /** @brief Master timer period */
  static const int32_t HRTIM_TIMx_RSTxR_UPDT_POS         = 1;    /** @brief Timer A update reset */
  static const int32_t HRTIM_TIMx_CHPxR_STRTPW_POS       = 7;    /** @brief STRTPW */
  static const int32_t HRTIM_TIMx_CHPxR_CHPDTY_POS       = 4;    /** @brief Timerx chopper duty cycle value */
  static const int32_t HRTIM_TIMx_CHPxR_CHPFRQ_POS       = 0;    /** @brief Timerx carrier frequency value */
  static const int32_t HRTIM_TIMx_CPTxxCR_TE1RST_POS     = 29;   /** @brief Timer E output 1 reset */
  static const int32_t HRTIM_TIMx_CPTxxCR_TE1SET_POS     = 28;   /** @brief Timer E output 1 set */
  static const int32_t HRTIM_TIMx_CPTxxCR_TD1RST_POS     = 25;   /** @brief Timer D output 1 reset */
  static const int32_t HRTIM_TIMx_CPTxxCR_TD1SET_POS     = 24;   /** @brief Timer D output 1 set */
  static const int32_t HRTIM_TIMx_CPTxxCR_TC1RST_POS     = 21;   /** @brief Timer C output 1 reset */
  static const int32_t HRTIM_TIMx_CPTxxCR_TC1SET_POS     = 20;   /** @brief Timer C output 1 set */
  static const int32_t HRTIM_TIMx_CPTxxCR_TB1RST_POS     = 17;   /** @brief Timer B output 1 reset */
  static const int32_t HRTIM_TIMx_CPTxxCR_TB1SET_POS     = 16;   /** @brief Timer B output 1 set */
  static const int32_t HRTIM_TIMx_CPTxxCR_UDPCPT_POS     = 1;    /** @brief Update capture */
  static const int32_t HRTIM_TIMx_CPTxxCR_SWCPT_POS      = 0;    /** @brief Software capture */
  static const int32_t HRTIM_TIMx_OUTxR_DLYPRT_POS       = 10;   /** @brief Delayed protection */
  static const int32_t HRTIM_TIMx_OUTxR_DLYPRTEN_POS     = 9;    /** @brief Delayed protection enable */
  static const int32_t HRTIM_TIMx_OUTxR_DTEN_POS         = 8;    /** @brief Deadtime enable */
  static const int32_t HRTIM_TIMx_FLTxR_FLTLCK_POS       = 31;   /** @brief Fault sources lock */

  /**** @subsection Enumerated HRTIM_TIMx Register Field Positions ****/

  static const int32_t HRTIM_TIMx_TIMxCR_DELCMPx_POS[5] = {
    [2] = 12,   /** @brief Delayed CMP2 mode */
    [4] = 14,   /** @brief Delayed CMP4 mode */
  };

  static const int32_t HRTIM_TIMx_TIMxISR_OxSTAT_POS[3] = {
    [1] = 18,   /** @brief Output 1 state */
    [2] = 19,   /** @brief Output 2 state */
  };

  static const int32_t HRTIM_TIMx_TIMxISR_RSTXx_POS[3] = {
    [1] = 10,   /** @brief Output 1 reset interrupt flag */
    [2] = 12,   /** @brief Output 2 reset interrupt flag */
  };

  static const int32_t HRTIM_TIMx_TIMxISR_SETXx_POS[3] = {
    [1] = 9,    /** @brief Output 1 set interrupt flag */
    [2] = 11,   /** @brief Output 2 set interrupt flag */
  };

  static const int32_t HRTIM_TIMx_TIMxISR_CPTx_POS[3] = {
    [1] = 7,   /** @brief Capture1 interrupt flag */
    [2] = 8,   /** @brief Capture2 interrupt flag */
  };

  static const int32_t HRTIM_TIMx_TIMxISR_CMPx_POS[5] = {
    [1] = 0,   /** @brief Compare 1 interrupt flag */
    [2] = 1,   /** @brief Compare 2 interrupt flag */
    [3] = 2,   /** @brief Compare 3 interrupt flag */
    [4] = 3,   /** @brief Compare 4 interrupt flag */
  };

  static const int32_t HRTIM_TIMx_TIMxICR_RSTXxC_POS[3] = {
    [1] = 10,   /** @brief Output 1 reset flag clear */
    [2] = 12,   /** @brief Output 2 reset flag clear */
  };

  static const int32_t HRTIM_TIMx_TIMxICR_SETxXC_POS[3] = {
    [1] = 9,    /** @brief Output 1 set flag clear */
    [2] = 11,   /** @brief Output 2 set flag clear */
  };

  static const int32_t HRTIM_TIMx_TIMxICR_CPTxC_POS[3] = {
    [1] = 7,   /** @brief Capture1 interrupt flag clear */
    [2] = 8,   /** @brief Capture2 interrupt flag clear */
  };

  static const int32_t HRTIM_TIMx_TIMxICR_CMPxC_POS[5] = {
    [1] = 0,   /** @brief Compare 1 interrupt flag clear */
    [2] = 1,   /** @brief Compare 2 interrupt flag clear */
    [3] = 2,   /** @brief Compare 3 interrupt flag clear */
    [4] = 3,   /** @brief Compare 4 interrupt flag clear */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_RSTXxDE_POS[3] = {
    [1] = 26,   /** @brief RSTx1DE */
    [2] = 28,   /** @brief RSTx2DE */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_CPTxDE_POS[3] = {
    [1] = 23,   /** @brief CPT1DE */
    [2] = 24,   /** @brief CPT2DE */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_CMPxDE_POS[5] = {
    [1] = 16,   /** @brief CMP1DE */
    [2] = 17,   /** @brief CMP2DE */
    [3] = 18,   /** @brief CMP3DE */
    [4] = 19,   /** @brief CMP4DE */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_RSTXxIE_POS[3] = {
    [1] = 10,   /** @brief RSTx1IE */
    [2] = 12,   /** @brief RSTx2IE */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_CPTxIE_POS[3] = {
    [1] = 7,   /** @brief CPT1IE */
    [2] = 8,   /** @brief CPT2IE */
  };

  static const int32_t HRTIM_TIMx_TIMxDIER5_CMPxIE_POS[5] = {
    [1] = 0,   /** @brief CMP1IE */
    [2] = 1,   /** @brief CMP2IE */
    [3] = 2,   /** @brief CMP3IE */
    [4] = 3,   /** @brief CMP4IE */
  };

  static const int32_t HRTIM_TIMx_SETxxR_EXTEVNTx_POS[11] = {
    [1]  = 21,   /** @brief External event 1 */
    [2]  = 22,   /** @brief External event 2 */
    [3]  = 23,   /** @brief External event 3 */
    [4]  = 24,   /** @brief External event 4 */
    [5]  = 25,   /** @brief External event 5 */
    [6]  = 26,   /** @brief External event 6 */
    [7]  = 27,   /** @brief External event 7 */
    [8]  = 28,   /** @brief External event 8 */
    [9]  = 29,   /** @brief External event 9 */
    [10] = 30,   /** @brief External event 10 */
  };

  static const int32_t HRTIM_TIMx_SETxxR_TIMEVNTx_POS[10] = {
    [1]  = 12,   /** @brief Timer event 1 */
    [2]  = 13,   /** @brief Timer event 2 */
    [3]  = 14,   /** @brief Timer event 3 */
    [4]  = 15,   /** @brief Timer event 4 */
    [5]  = 16,   /** @brief Timer event 5 */
    [6]  = 17,   /** @brief Timer event 6 */
    [7]  = 18,   /** @brief Timer event 7 */
    [8]  = 19,   /** @brief Timer event 8 */
    [9]  = 20,   /** @brief Timer event 9 */
  };

  static const int32_t HRTIM_TIMx_SETxxR_MSTCMPx_POS[5] = {
    [1] = 8,    /** @brief Master compare 1 */
    [2] = 9,    /** @brief Master compare 2 */
    [3] = 10,   /** @brief Master compare 3 */
    [4] = 11,   /** @brief Master compare 4 */
  };

  static const int32_t HRTIM_TIMx_EEFxRx_EExFLTR_POS[6] = {
    [1] = 1,    /** @brief External event 1 filter */
    [2] = 7,    /** @brief External event 2 filter */
    [3] = 13,   /** @brief External event 3 filter */
    [4] = 19,   /** @brief External event 4 filter */
    [5] = 25,   /** @brief External event 5 filter */
  };

  static const int32_t HRTIM_TIMx_EEFxRx_EExLTCH_POS[6] = {
    [1] = 0,    /** @brief External event 1 latch */
    [2] = 6,    /** @brief External event 2 latch */
    [3] = 12,   /** @brief External event 3 latch */
    [4] = 18,   /** @brief External event 4 latch */
    [5] = 24,   /** @brief External event 5 latch */
  };

  static const int32_t HRTIM_TIMx_RSTxR_TIMECMPx_POS[5] = {
    [1] = 28,   /** @brief Timer E compare 1 */
    [2] = 29,   /** @brief Timer E compare 2 */
    [4] = 30,   /** @brief Timer E compare 4 */
  };

  static const int32_t HRTIM_TIMx_RSTxR_TIMDCMPx_POS[5] = {
    [1] = 25,   /** @brief Timer D compare 1 */
    [2] = 26,   /** @brief Timer D compare 2 */
    [4] = 27,   /** @brief Timer D compare 4 */
  };

  static const int32_t HRTIM_TIMx_RSTxR_TIMCCMPx_POS[5] = {
    [1] = 22,   /** @brief Timer C compare 1 */
    [2] = 23,   /** @brief Timer C compare 2 */
    [4] = 24,   /** @brief Timer C compare 4 */
  };

  static const int32_t HRTIM_TIMx_RSTxR_TIMBCMPx_POS[5] = {
    [1] = 19,   /** @brief Timer B compare 1 */
    [2] = 20,   /** @brief Timer B compare 2 */
    [4] = 21,   /** @brief Timer B compare 4 */
  };

  static const int32_t HRTIM_TIMx_CPTxxCR_TECMPx_POS[3] = {
    [1] = 30,   /** @brief Timer E compare 1 */
    [2] = 31,   /** @brief Timer E compare 2 */
  };

  static const int32_t HRTIM_TIMx_CPTxxCR_TDCMPx_POS[3] = {
    [1] = 26,   /** @brief Timer D compare 1 */
    [2] = 27,   /** @brief Timer D compare 2 */
  };

  static const int32_t HRTIM_TIMx_CPTxxCR_TCCMPx_POS[3] = {
    [1] = 22,   /** @brief Timer C compare 1 */
    [2] = 23,   /** @brief Timer C compare 2 */
  };

  static const int32_t HRTIM_TIMx_CPTxxCR_TBCMPx_POS[3] = {
    [1] = 18,   /** @brief Timer B compare 1 */
    [2] = 19,   /** @brief Timer B compare 2 */
  };

  static const int32_t HRTIM_TIMx_CPTxxCR_EXEVxCPT_POS[11] = {
    [1]  = 2,    /** @brief External event 1 capture */
    [2]  = 3,    /** @brief External event 2 capture */
    [3]  = 4,    /** @brief External event 3 capture */
    [4]  = 5,    /** @brief External event 4 capture */
    [5]  = 6,    /** @brief External event 5 capture */
    [6]  = 7,    /** @brief External event 6 capture */
    [7]  = 8,    /** @brief External event 7 capture */
    [8]  = 9,    /** @brief External event 8 capture */
    [9]  = 10,   /** @brief External event 9 capture */
    [10] = 11,   /** @brief External event 10 capture */
  };

  static const int32_t HRTIM_TIMx_OUTxR_DIDLx_POS[3] = {
    [1] = 7,    /** @brief Output 1 deadtime upon burst mode idle entry */
    [2] = 23,   /** @brief Output 2 deadtime upon burst mode idle entry */
  };

  static const int32_t HRTIM_TIMx_OUTxR_CHPx_POS[3] = {
    [1] = 6,    /** @brief Output 1 chopper enable */
    [2] = 22,   /** @brief Output 2 chopper enable */
  };

  static const int32_t HRTIM_TIMx_OUTxR_FAULTx_POS[3] = {
    [1] = 4,    /** @brief Output 1 fault state */
    [2] = 20,   /** @brief Output 2 fault state */
  };

  static const int32_t HRTIM_TIMx_OUTxR_IDLESx_POS[3] = {
    [1] = 3,    /** @brief Output 1 idle state */
    [2] = 19,   /** @brief Output 2 idle state */
  };

  static const int32_t HRTIM_TIMx_OUTxR_IDLEMx_POS[3] = {
    [1] = 2,    /** @brief Output 1 idle mode */
    [2] = 18,   /** @brief Output 2 idle mode */
  };

  static const int32_t HRTIM_TIMx_OUTxR_POLx_POS[3] = {
    [1] = 1,    /** @brief Output 1 polarity */
    [2] = 17,   /** @brief Output 2 polarity */
  };

  static const int32_t HRTIM_TIMx_FLTxR_FLTxEN_POS[6] = {
    [1] = 0,   /** @brief Fault 1 enable */
    [2] = 1,   /** @brief Fault 2 enable */
    [3] = 2,   /** @brief Fault 3 enable */
    [4] = 3,   /** @brief Fault 4 enable */
    [5] = 4,   /** @brief Fault 5 enable */
  };

  /**********************************************************************************************
   * @section HRTIM_COMMON Register Information
   **********************************************************************************************/

  /**** @subsection HRTIM_COMMON Register Pointers ****/

  static RW_ uint32_t* const HRTIM_COMMON_ISR_PTR     = (RW_ uint32_t* const)0x40017788U;   /** @brief Interrupt status register */
  static RW_ uint32_t* const HRTIM_COMMON_ICR_PTR     = (RW_ uint32_t* const)0x4001778CU;   /** @brief Interrupt clear register */
  static RW_ uint32_t* const HRTIM_COMMON_IER_PTR     = (RW_ uint32_t* const)0x40017790U;   /** @brief Interrupt enable register */
  static WO_ uint32_t* const HRTIM_COMMON_OENR_PTR    = (WO_ uint32_t* const)0x40017794U;   /** @brief Output enable register */
  static RW_ uint32_t* const HRTIM_COMMON_DISR_PTR    = (RW_ uint32_t* const)0x40017798U;   /** @brief DISR */
  static RO_ uint32_t* const HRTIM_COMMON_ODSR_PTR    = (RO_ uint32_t* const)0x4001779CU;   /** @brief Output disable status register */
  static RW_ uint32_t* const HRTIM_COMMON_BMCR_PTR    = (RW_ uint32_t* const)0x400177A0U;   /** @brief Burst mode control register */
  static RW_ uint32_t* const HRTIM_COMMON_BMTRG_PTR   = (RW_ uint32_t* const)0x400177A4U;   /** @brief BMTRG */
  static RW_ uint32_t* const HRTIM_COMMON_BMCMPR6_PTR = (RW_ uint32_t* const)0x400177A8U;   /** @brief BMCMPR6 */
  static RW_ uint32_t* const HRTIM_COMMON_BMPER_PTR   = (RW_ uint32_t* const)0x400177ACU;   /** @brief Burst mode period register */
  static RW_ uint32_t* const HRTIM_COMMON_DLLCR_PTR   = (RW_ uint32_t* const)0x400177CCU;   /** @brief DLL control register */
  static RW_ uint32_t* const HRTIM_COMMON_BDMUPDR_PTR = (RW_ uint32_t* const)0x400177D8U;   /** @brief BDMUPDR */
  static RW_ uint32_t* const HRTIM_COMMON_BDTXUPR_PTR = (RW_ uint32_t* const)0x400177DCU;   /** @brief Burst DMA timerx update register */
  static RW_ uint32_t* const HRTIM_COMMON_BDMADR_PTR  = (RW_ uint32_t* const)0x400177E0U;   /** @brief Burst DMA data register */

  /**** @subsection Enumerated HRTIM_COMMON Register Pointers ****/

  static RW_ uint32_t* const HRTIM_COMMON_CRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40017780U,   /** @brief Control register 1 */
    [2] = (RW_ uint32_t* const)0x40017784U,   /** @brief Control register 2 */
  };

  static RW_ uint32_t* const HRTIM_COMMON_EECRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400177B0U,   /** @brief Timer external event control register 1 */
    [2] = (RW_ uint32_t* const)0x400177B4U,   /** @brief Timer external event control register 2 */
    [3] = (RW_ uint32_t* const)0x400177B8U,   /** @brief Timer external event control register 3 */
  };

  static RW_ uint32_t* const HRTIM_COMMON_ADCxR_PTR[5] = {
    [1] = (RW_ uint32_t* const)0x400177BCU,   /** @brief ADC trigger 1 register */
    [2] = (RW_ uint32_t* const)0x400177C0U,   /** @brief ADC trigger 2 register */
    [3] = (RW_ uint32_t* const)0x400177C4U,   /** @brief ADC trigger 3 register */
    [4] = (RW_ uint32_t* const)0x400177C8U,   /** @brief ADC trigger 4 register */
  };

  static RW_ uint32_t* const HRTIM_COMMON_FLTINRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x400177D0U,   /** @brief HRTIM fault input register 1 */
    [2] = (RW_ uint32_t* const)0x400177D4U,   /** @brief HRTIM fault input register 2 */
  };

  /**** @subsection HRTIM_COMMON Register Field Masks ****/

  static const uint32_t HRTIM_COMMON_CRx_TEUDIS_MSK        = 0x00000020U;   /** @brief Timer E update disable */
  static const uint32_t HRTIM_COMMON_CRx_TDUDIS_MSK        = 0x00000010U;   /** @brief Timer D update disable */
  static const uint32_t HRTIM_COMMON_CRx_TCUDIS_MSK        = 0x00000008U;   /** @brief Timer C update disable */
  static const uint32_t HRTIM_COMMON_CRx_TBUDIS_MSK        = 0x00000004U;   /** @brief Timer B update disable */
  static const uint32_t HRTIM_COMMON_CRx_TAUDIS_MSK        = 0x00000002U;   /** @brief Timer A update disable */
  static const uint32_t HRTIM_COMMON_CRx_MUDIS_MSK         = 0x00000001U;   /** @brief Master update disable */
  static const uint32_t HRTIM_COMMON_ISR_BMPER_MSK         = 0x00020000U;   /** @brief Burst mode period interrupt flag */
  static const uint32_t HRTIM_COMMON_ISR_DLLRDY_MSK        = 0x00010000U;   /** @brief DLL ready interrupt flag */
  static const uint32_t HRTIM_COMMON_ISR_SYSFLT_MSK        = 0x00000020U;   /** @brief System fault interrupt flag */
  static const uint32_t HRTIM_COMMON_ICR_BMPERC_MSK        = 0x00020000U;   /** @brief Burst mode period flag clear */
  static const uint32_t HRTIM_COMMON_ICR_DLLRDYC_MSK       = 0x00010000U;   /** @brief DLL ready interrupt flag clear */
  static const uint32_t HRTIM_COMMON_ICR_SYSFLTC_MSK       = 0x00000020U;   /** @brief System fault interrupt flag clear */
  static const uint32_t HRTIM_COMMON_IER_BMPERIE_MSK       = 0x00020000U;   /** @brief Burst mode period interrupt enable */
  static const uint32_t HRTIM_COMMON_IER_DLLRDYIE_MSK      = 0x00010000U;   /** @brief DLL ready interrupt enable */
  static const uint32_t HRTIM_COMMON_IER_SYSFLTE_MSK       = 0x00000020U;   /** @brief System fault interrupt enable */
  static const uint32_t HRTIM_COMMON_BMCR_BMSTAT_MSK       = 0x80000000U;   /** @brief Burst mode status */
  static const uint32_t HRTIM_COMMON_BMCR_TEBM_MSK         = 0x00200000U;   /** @brief Timer E burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_TDBM_MSK         = 0x00100000U;   /** @brief Timer D burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_TCBM_MSK         = 0x00080000U;   /** @brief Timer C burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_TBBM_MSK         = 0x00040000U;   /** @brief Timer B burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_TABM_MSK         = 0x00020000U;   /** @brief Timer A burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_MTBM_MSK         = 0x00010000U;   /** @brief Master timer burst mode */
  static const uint32_t HRTIM_COMMON_BMCR_BMPREN_MSK       = 0x00000400U;   /** @brief Burst mode preload enable */
  static const uint32_t HRTIM_COMMON_BMCR_BMPRSC_MSK       = 0x000003C0U;   /** @brief Burst mode prescaler */
  static const uint32_t HRTIM_COMMON_BMCR_BMCLK_MSK        = 0x0000003CU;   /** @brief Burst mode clock source */
  static const uint32_t HRTIM_COMMON_BMCR_BMOM_MSK         = 0x00000002U;   /** @brief Burst mode operating mode */
  static const uint32_t HRTIM_COMMON_BMCR_BME_MSK          = 0x00000001U;   /** @brief Burst mode enable */
  static const uint32_t HRTIM_COMMON_BMTRG_OCHPEV_MSK      = 0x80000000U;   /** @brief OCHPEV */
  static const uint32_t HRTIM_COMMON_BMTRG_TEREP_MSK       = 0x01000000U;   /** @brief TEREP */
  static const uint32_t HRTIM_COMMON_BMTRG_TERST_MSK       = 0x00800000U;   /** @brief TERST */
  static const uint32_t HRTIM_COMMON_BMTRG_TDREP_MSK       = 0x00100000U;   /** @brief TDREP */
  static const uint32_t HRTIM_COMMON_BMTRG_TDRST_MSK       = 0x00080000U;   /** @brief TDRST */
  static const uint32_t HRTIM_COMMON_BMTRG_TCREP_MSK       = 0x00010000U;   /** @brief TCREP */
  static const uint32_t HRTIM_COMMON_BMTRG_TCRST_MSK       = 0x00008000U;   /** @brief TCRST */
  static const uint32_t HRTIM_COMMON_BMTRG_TBREP_MSK       = 0x00001000U;   /** @brief TBREP */
  static const uint32_t HRTIM_COMMON_BMTRG_TBRST_MSK       = 0x00000800U;   /** @brief TBRST */
  static const uint32_t HRTIM_COMMON_BMTRG_TAREP_MSK       = 0x00000100U;   /** @brief TAREP */
  static const uint32_t HRTIM_COMMON_BMTRG_TARST_MSK       = 0x00000080U;   /** @brief TARST */
  static const uint32_t HRTIM_COMMON_BMTRG_MSTREP_MSK      = 0x00000004U;   /** @brief MSTREP */
  static const uint32_t HRTIM_COMMON_BMTRG_MSTRST_MSK      = 0x00000002U;   /** @brief MSTRST */
  static const uint32_t HRTIM_COMMON_BMTRG_SW_MSK          = 0x00000001U;   /** @brief SW */
  static const uint32_t HRTIM_COMMON_BMCMPR6_BMCMP_MSK     = 0x0000FFFFU;   /** @brief BMCMP */
  static const uint32_t HRTIM_COMMON_BMPER_BMPER_MSK       = 0x0000FFFFU;   /** @brief Burst mode period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TEPER_MSK    = 0x80000000U;   /** @brief ADC trigger 1 on timer E period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TDPER_MSK    = 0x08000000U;   /** @brief ADC trigger 1 on timer D period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TCPER_MSK    = 0x00800000U;   /** @brief ADC trigger 1 on timer C period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TBRST_MSK    = 0x00080000U;   /** @brief ADC trigger 1 on timer B reset */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TBPER_MSK    = 0x00040000U;   /** @brief ADC trigger 1 on timer B period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TARST_MSK    = 0x00004000U;   /** @brief ADC trigger 1 on timer A reset */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1TAPER_MSK    = 0x00002000U;   /** @brief ADC trigger 1 on timer A period */
  static const uint32_t HRTIM_COMMON_ADCxR_AD1MPER_MSK     = 0x00000010U;   /** @brief ADC trigger 1 on master period */
  static const uint32_t HRTIM_COMMON_DLLCR_CALRTE_MSK      = 0x0000000CU;   /** @brief DLL calibration rate */
  static const uint32_t HRTIM_COMMON_DLLCR_CALEN_MSK       = 0x00000002U;   /** @brief DLL calibration enable */
  static const uint32_t HRTIM_COMMON_DLLCR_CAL_MSK         = 0x00000001U;   /** @brief DLL calibration start */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MREP_MSK      = 0x00000020U;   /** @brief MREP */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MPER_MSK      = 0x00000010U;   /** @brief MPER */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MCNT_MSK      = 0x00000008U;   /** @brief MCNT */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MDIER_MSK     = 0x00000004U;   /** @brief MDIER */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MICR_MSK      = 0x00000002U;   /** @brief MICR */
  static const uint32_t HRTIM_COMMON_BDMUPDR_MCR_MSK       = 0x00000001U;   /** @brief MCR */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR_MSK  = 0x00100000U;   /** @brief HRTIM_FLTxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR_MSK  = 0x00080000U;   /** @brief HRTIM_OUTxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR_MSK  = 0x00040000U;   /** @brief HRTIM_CHPxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR_MSK  = 0x00020000U;   /** @brief HRTIM_RSTxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR_MSK = 0x00000400U;   /** @brief HRTIM_DTxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXREP_MSK   = 0x00000020U;   /** @brief HRTIM_REPxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXPER_MSK   = 0x00000010U;   /** @brief HRTIM_PERxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCNT_MSK   = 0x00000008U;   /** @brief HRTIM_CNTxR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXDIER_MSK  = 0x00000004U;   /** @brief HRTIM_TIMxDIER register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXICR_MSK   = 0x00000002U;   /** @brief HRTIM_TIMxICR register update enable */
  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCR_MSK    = 0x00000001U;   /** @brief HRTIM_TIMxCR register update enable */

  /**** @subsection Enumerated HRTIM_COMMON Register Field Masks ****/

  static const uint32_t HRTIM_COMMON_CRx_ADxUSRC_MSK[5] = {
    [1] = 0x00070000U,   /** @brief ADC trigger 1 update source */
    [2] = 0x00380000U,   /** @brief ADC trigger 2 update source */
    [3] = 0x01C00000U,   /** @brief ADC trigger 3 update source */
    [4] = 0x0E000000U,   /** @brief ADC trigger 4 update source */
  };

  static const uint32_t HRTIM_COMMON_ISR_FLTx_MSK[6] = {
    [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag */
    [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag */
    [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag */
    [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag */
    [5] = 0x00000010U,   /** @brief Fault 5 interrupt flag */
  };

  static const uint32_t HRTIM_COMMON_ICR_FLTxC_MSK[6] = {
    [1] = 0x00000001U,   /** @brief Fault 1 interrupt flag clear */
    [2] = 0x00000002U,   /** @brief Fault 2 interrupt flag clear */
    [3] = 0x00000004U,   /** @brief Fault 3 interrupt flag clear */
    [4] = 0x00000008U,   /** @brief Fault 4 interrupt flag clear */
    [5] = 0x00000010U,   /** @brief Fault 5 interrupt flag clear */
  };

  static const uint32_t HRTIM_COMMON_IER_FLTxIE_MSK[6] = {
    [1] = 0x00000001U,   /** @brief Fault 1 interrupt enable */
    [2] = 0x00000002U,   /** @brief Fault 2 interrupt enable */
    [3] = 0x00000004U,   /** @brief Fault 3 interrupt enable */
    [4] = 0x00000008U,   /** @brief Fault 4 interrupt enable */
    [5] = 0x00000010U,   /** @brief Fault 5 interrupt enable */
  };

  static const uint32_t HRTIM_COMMON_OENR_TExOEN_MSK[3] = {
    [1] = 0x00000100U,   /** @brief Timer E output 1 enable */
    [2] = 0x00000200U,   /** @brief Timer E output 2 enable */
  };

  static const uint32_t HRTIM_COMMON_OENR_TDxOEN_MSK[3] = {
    [1] = 0x00000040U,   /** @brief Timer D output 1 enable */
    [2] = 0x00000080U,   /** @brief Timer D output 2 enable */
  };

  static const uint32_t HRTIM_COMMON_OENR_TCxOEN_MSK[3] = {
    [1] = 0x00000010U,   /** @brief Timer C output 1 enable */
    [2] = 0x00000020U,   /** @brief Timer C output 2 enable */
  };

  static const uint32_t HRTIM_COMMON_OENR_TBxOEN_MSK[3] = {
    [1] = 0x00000004U,   /** @brief Timer B output 1 enable */
    [2] = 0x00000008U,   /** @brief Timer B output 2 enable */
  };

  static const uint32_t HRTIM_COMMON_OENR_TAxOEN_MSK[3] = {
    [1] = 0x00000001U,   /** @brief Timer A output 1 enable */
    [2] = 0x00000002U,   /** @brief Timer A output 2 enable */
  };

  static const uint32_t HRTIM_COMMON_DISR_TExODIS_MSK[3] = {
    [1] = 0x00000100U,   /** @brief TE1ODIS */
    [2] = 0x00000200U,   /** @brief TE2ODIS */
  };

  static const uint32_t HRTIM_COMMON_DISR_TDxODIS_MSK[3] = {
    [1] = 0x00000040U,   /** @brief TD1ODIS */
    [2] = 0x00000080U,   /** @brief TD2ODIS */
  };

  static const uint32_t HRTIM_COMMON_DISR_TCxODIS_MSK[3] = {
    [1] = 0x00000010U,   /** @brief TC1ODIS */
    [2] = 0x00000020U,   /** @brief TC2ODIS */
  };

  static const uint32_t HRTIM_COMMON_DISR_TBxODIS_MSK[3] = {
    [1] = 0x00000004U,   /** @brief TB1ODIS */
    [2] = 0x00000008U,   /** @brief TB2ODIS */
  };

  static const uint32_t HRTIM_COMMON_DISR_TAxODIS_MSK[3] = {
    [1] = 0x00000001U,   /** @brief TA1ODIS */
    [2] = 0x00000002U,   /** @brief TA2ODIS */
  };

  static const uint32_t HRTIM_COMMON_ODSR_TExODS_MSK[3] = {
    [1] = 0x00000100U,   /** @brief Timer E output 1 disable status */
    [2] = 0x00000200U,   /** @brief Timer E output 2 disable status */
  };

  static const uint32_t HRTIM_COMMON_ODSR_TDxODS_MSK[3] = {
    [1] = 0x00000040U,   /** @brief Timer D output 1 disable status */
    [2] = 0x00000080U,   /** @brief Timer D output 2 disable status */
  };

  static const uint32_t HRTIM_COMMON_ODSR_TCxODS_MSK[3] = {
    [1] = 0x00000010U,   /** @brief Timer C output 1 disable status */
    [2] = 0x00000020U,   /** @brief Timer C output 2 disable status */
  };

  static const uint32_t HRTIM_COMMON_ODSR_TBxODS_MSK[3] = {
    [1] = 0x00000004U,   /** @brief Timer B output 1 disable status */
    [2] = 0x00000008U,   /** @brief Timer B output 2 disable status */
  };

  static const uint32_t HRTIM_COMMON_ODSR_TAxODS_MSK[3] = {
    [1] = 0x00000001U,   /** @brief Timer A output 1 disable status */
    [2] = 0x00000002U,   /** @brief Timer A output 2 disable status */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_TECMPx_MSK[3] = {
    [1] = 0x02000000U,   /** @brief TECMP1 */
    [2] = 0x04000000U,   /** @brief TECMP2 */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_TDCMPx_MSK[3] = {
    [1] = 0x00200000U,   /** @brief TDCMP1 */
    [2] = 0x00400000U,   /** @brief TDCMP2 */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_TCCMPx_MSK[3] = {
    [1] = 0x00020000U,   /** @brief TCCMP1 */
    [2] = 0x00040000U,   /** @brief TCCMP2 */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_TBCMPx_MSK[3] = {
    [1] = 0x00002000U,   /** @brief TBCMP1 */
    [2] = 0x00004000U,   /** @brief TBCMP2 */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_TACMPx_MSK[3] = {
    [1] = 0x00000200U,   /** @brief TACMP1 */
    [2] = 0x00000400U,   /** @brief TACMP2 */
  };

  static const uint32_t HRTIM_COMMON_BMTRG_MSTCMPx_MSK[5] = {
    [1] = 0x00000008U,   /** @brief MSTCMP1 */
    [2] = 0x00000010U,   /** @brief MSTCMP2 */
    [3] = 0x00000020U,   /** @brief MSTCMP3 */
    [4] = 0x00000040U,   /** @brief MSTCMP4 */
  };

  static const uint32_t HRTIM_COMMON_EECRx_EExFAST_MSK[6] = {
    [1] = 0x00000020U,   /** @brief External event 1 fast mode */
    [2] = 0x00000800U,   /** @brief External event 2 fast mode */
    [3] = 0x00020000U,   /** @brief External event 3 fast mode */
    [4] = 0x00800000U,   /** @brief External event 4 fast mode */
    [5] = 0x20000000U,   /** @brief External event 5 fast mode */
  };

  static const uint32_t HRTIM_COMMON_EECRx_EExSNS_MSK[6] = {
    [1] = 0x00000018U,   /** @brief External event 1 sensitivity */
    [2] = 0x00000600U,   /** @brief External event 2 sensitivity */
    [3] = 0x00018000U,   /** @brief External event 3 sensitivity */
    [4] = 0x00600000U,   /** @brief External event 4 sensitivity */
    [5] = 0x18000000U,   /** @brief External event 5 sensitivity */
  };

  static const uint32_t HRTIM_COMMON_EECRx_EExPOL_MSK[6] = {
    [1] = 0x00000004U,   /** @brief External event 1 polarity */
    [2] = 0x00000100U,   /** @brief External event 2 polarity */
    [3] = 0x00004000U,   /** @brief External event 3 polarity */
    [4] = 0x00100000U,   /** @brief External event 4 polarity */
    [5] = 0x04000000U,   /** @brief External event 5 polarity */
  };

  static const uint32_t HRTIM_COMMON_EECRx_EExSRC_MSK[6] = {
    [1] = 0x00000003U,   /** @brief External event 1 source */
    [2] = 0x000000C0U,   /** @brief External event 2 source */
    [3] = 0x00003000U,   /** @brief External event 3 source */
    [4] = 0x000C0000U,   /** @brief External event 4 source */
    [5] = 0x03000000U,   /** @brief External event 5 source */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1TECx_MSK[5] = {
    [2] = 0x10000000U,   /** @brief ADC trigger 1 on timer E compare 2 */
    [3] = 0x20000000U,   /** @brief ADC trigger 1 on timer E compare 3 */
    [4] = 0x40000000U,   /** @brief ADC trigger 1 on timer E compare 4 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1TDCx_MSK[5] = {
    [2] = 0x01000000U,   /** @brief ADC trigger 1 on timer D compare 2 */
    [3] = 0x02000000U,   /** @brief ADC trigger 1 on timer D compare 3 */
    [4] = 0x04000000U,   /** @brief ADC trigger 1 on timer D compare 4 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1TCCx_MSK[5] = {
    [2] = 0x00100000U,   /** @brief ADC trigger 1 on timer C compare 2 */
    [3] = 0x00200000U,   /** @brief ADC trigger 1 on timer C compare 3 */
    [4] = 0x00400000U,   /** @brief ADC trigger 1 on timer C compare 4 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1TBCx_MSK[5] = {
    [2] = 0x00008000U,   /** @brief ADC trigger 1 on timer B compare 2 */
    [3] = 0x00010000U,   /** @brief ADC trigger 1 on timer B compare 3 */
    [4] = 0x00020000U,   /** @brief ADC trigger 1 on timer B compare 4 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1TACx_MSK[5] = {
    [2] = 0x00000400U,   /** @brief ADC trigger 1 on timer A compare 2 */
    [3] = 0x00000800U,   /** @brief ADC trigger 1 on timer A compare 3 */
    [4] = 0x00001000U,   /** @brief ADC trigger 1 on timer A compare 4 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1EEVx_MSK[6] = {
    [1] = 0x00000020U,   /** @brief ADC trigger 1 on external event 1 */
    [2] = 0x00000040U,   /** @brief ADC trigger 1 on external event 2 */
    [3] = 0x00000080U,   /** @brief ADC trigger 1 on external event 3 */
    [4] = 0x00000100U,   /** @brief ADC trigger 1 on external event 4 */
    [5] = 0x00000200U,   /** @brief ADC trigger 1 on external event 5 */
  };

  static const uint32_t HRTIM_COMMON_ADCxR_AD1MCx_MSK[5] = {
    [1] = 0x00000001U,   /** @brief ADC trigger 1 on master compare 1 */
    [2] = 0x00000002U,   /** @brief ADC trigger 1 on master compare 2 */
    [3] = 0x00000004U,   /** @brief ADC trigger 1 on master compare 3 */
    [4] = 0x00000008U,   /** @brief ADC trigger 1 on master compare 4 */
  };

  static const uint32_t HRTIM_COMMON_FLTINRx_FLTxLCK_MSK[5] = {
    [1] = 0x00000080U,   /** @brief FLT1LCK */
    [2] = 0x00008000U,   /** @brief FLT2LCK */
    [3] = 0x00800000U,   /** @brief FLT3LCK */
    [4] = 0x80000000U,   /** @brief FLT4LCK */
  };

  static const uint32_t HRTIM_COMMON_FLTINRx_FLTxF_MSK[5] = {
    [1] = 0x00000078U,   /** @brief FLT1F */
    [2] = 0x00007800U,   /** @brief FLT2F */
    [3] = 0x00780000U,   /** @brief FLT3F */
    [4] = 0x78000000U,   /** @brief FLT4F */
  };

  static const uint32_t HRTIM_COMMON_FLTINRx_FLTxSRC_MSK[5] = {
    [1] = 0x00000004U,   /** @brief FLT1SRC */
    [2] = 0x00000400U,   /** @brief FLT2SRC */
    [3] = 0x00040000U,   /** @brief FLT3SRC */
    [4] = 0x04000000U,   /** @brief FLT4SRC */
  };

  static const uint32_t HRTIM_COMMON_FLTINRx_FLTxP_MSK[5] = {
    [1] = 0x00000002U,   /** @brief FLT1P */
    [2] = 0x00000200U,   /** @brief FLT2P */
    [3] = 0x00020000U,   /** @brief FLT3P */
    [4] = 0x02000000U,   /** @brief FLT4P */
  };

  static const uint32_t HRTIM_COMMON_FLTINRx_FLTxE_MSK[5] = {
    [1] = 0x00000001U,   /** @brief FLT1E */
    [2] = 0x00000100U,   /** @brief FLT2E */
    [3] = 0x00010000U,   /** @brief FLT3E */
    [4] = 0x01000000U,   /** @brief FLT4E */
  };

  static const uint32_t HRTIM_COMMON_BDMUPDR_MCMPx_MSK[5] = {
    [1] = 0x00000040U,   /** @brief MCMP1 */
    [2] = 0x00000080U,   /** @brief MCMP2 */
    [3] = 0x00000100U,   /** @brief MCMP3 */
    [4] = 0x00000200U,   /** @brief MCMP4 */
  };

  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXEEFRx_MSK[3] = {
    [1] = 0x00008000U,   /** @brief HRTIM_EEFxR1 register update enable */
    [2] = 0x00010000U,   /** @brief HRTIM_EEFxR2 register update enable */
  };

  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXRSTxR_MSK[3] = {
    [1] = 0x00001000U,   /** @brief HRTIM_RST1xR register update enable */
    [2] = 0x00004000U,   /** @brief HRTIM_RST2xR register update enable */
  };

  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXSETxR_MSK[3] = {
    [1] = 0x00000800U,   /** @brief HRTIM_SET1xR register update enable */
    [2] = 0x00002000U,   /** @brief HRTIM_SET2xR register update enable */
  };

  static const uint32_t HRTIM_COMMON_BDTXUPR_TIMXCMPx_MSK[5] = {
    [1] = 0x00000040U,   /** @brief HRTIM_CMP1xR register update enable */
    [2] = 0x00000080U,   /** @brief HRTIM_CMP2xR register update enable */
    [3] = 0x00000100U,   /** @brief HRTIM_CMP3xR register update enable */
    [4] = 0x00000200U,   /** @brief HRTIM_CMP4xR register update enable */
  };

  /**** @subsection HRTIM_COMMON Register Field Positions ****/

  static const int32_t HRTIM_COMMON_CRx_TEUDIS_POS        = 5;    /** @brief Timer E update disable */
  static const int32_t HRTIM_COMMON_CRx_TDUDIS_POS        = 4;    /** @brief Timer D update disable */
  static const int32_t HRTIM_COMMON_CRx_TCUDIS_POS        = 3;    /** @brief Timer C update disable */
  static const int32_t HRTIM_COMMON_CRx_TBUDIS_POS        = 2;    /** @brief Timer B update disable */
  static const int32_t HRTIM_COMMON_CRx_TAUDIS_POS        = 1;    /** @brief Timer A update disable */
  static const int32_t HRTIM_COMMON_CRx_MUDIS_POS         = 0;    /** @brief Master update disable */
  static const int32_t HRTIM_COMMON_ISR_BMPER_POS         = 17;   /** @brief Burst mode period interrupt flag */
  static const int32_t HRTIM_COMMON_ISR_DLLRDY_POS        = 16;   /** @brief DLL ready interrupt flag */
  static const int32_t HRTIM_COMMON_ISR_SYSFLT_POS        = 5;    /** @brief System fault interrupt flag */
  static const int32_t HRTIM_COMMON_ICR_BMPERC_POS        = 17;   /** @brief Burst mode period flag clear */
  static const int32_t HRTIM_COMMON_ICR_DLLRDYC_POS       = 16;   /** @brief DLL ready interrupt flag clear */
  static const int32_t HRTIM_COMMON_ICR_SYSFLTC_POS       = 5;    /** @brief System fault interrupt flag clear */
  static const int32_t HRTIM_COMMON_IER_BMPERIE_POS       = 17;   /** @brief Burst mode period interrupt enable */
  static const int32_t HRTIM_COMMON_IER_DLLRDYIE_POS      = 16;   /** @brief DLL ready interrupt enable */
  static const int32_t HRTIM_COMMON_IER_SYSFLTE_POS       = 5;    /** @brief System fault interrupt enable */
  static const int32_t HRTIM_COMMON_BMCR_BMSTAT_POS       = 31;   /** @brief Burst mode status */
  static const int32_t HRTIM_COMMON_BMCR_TEBM_POS         = 21;   /** @brief Timer E burst mode */
  static const int32_t HRTIM_COMMON_BMCR_TDBM_POS         = 20;   /** @brief Timer D burst mode */
  static const int32_t HRTIM_COMMON_BMCR_TCBM_POS         = 19;   /** @brief Timer C burst mode */
  static const int32_t HRTIM_COMMON_BMCR_TBBM_POS         = 18;   /** @brief Timer B burst mode */
  static const int32_t HRTIM_COMMON_BMCR_TABM_POS         = 17;   /** @brief Timer A burst mode */
  static const int32_t HRTIM_COMMON_BMCR_MTBM_POS         = 16;   /** @brief Master timer burst mode */
  static const int32_t HRTIM_COMMON_BMCR_BMPREN_POS       = 10;   /** @brief Burst mode preload enable */
  static const int32_t HRTIM_COMMON_BMCR_BMPRSC_POS       = 6;    /** @brief Burst mode prescaler */
  static const int32_t HRTIM_COMMON_BMCR_BMCLK_POS        = 2;    /** @brief Burst mode clock source */
  static const int32_t HRTIM_COMMON_BMCR_BMOM_POS         = 1;    /** @brief Burst mode operating mode */
  static const int32_t HRTIM_COMMON_BMCR_BME_POS          = 0;    /** @brief Burst mode enable */
  static const int32_t HRTIM_COMMON_BMTRG_OCHPEV_POS      = 31;   /** @brief OCHPEV */
  static const int32_t HRTIM_COMMON_BMTRG_TEREP_POS       = 24;   /** @brief TEREP */
  static const int32_t HRTIM_COMMON_BMTRG_TERST_POS       = 23;   /** @brief TERST */
  static const int32_t HRTIM_COMMON_BMTRG_TDREP_POS       = 20;   /** @brief TDREP */
  static const int32_t HRTIM_COMMON_BMTRG_TDRST_POS       = 19;   /** @brief TDRST */
  static const int32_t HRTIM_COMMON_BMTRG_TCREP_POS       = 16;   /** @brief TCREP */
  static const int32_t HRTIM_COMMON_BMTRG_TCRST_POS       = 15;   /** @brief TCRST */
  static const int32_t HRTIM_COMMON_BMTRG_TBREP_POS       = 12;   /** @brief TBREP */
  static const int32_t HRTIM_COMMON_BMTRG_TBRST_POS       = 11;   /** @brief TBRST */
  static const int32_t HRTIM_COMMON_BMTRG_TAREP_POS       = 8;    /** @brief TAREP */
  static const int32_t HRTIM_COMMON_BMTRG_TARST_POS       = 7;    /** @brief TARST */
  static const int32_t HRTIM_COMMON_BMTRG_MSTREP_POS      = 2;    /** @brief MSTREP */
  static const int32_t HRTIM_COMMON_BMTRG_MSTRST_POS      = 1;    /** @brief MSTRST */
  static const int32_t HRTIM_COMMON_BMTRG_SW_POS          = 0;    /** @brief SW */
  static const int32_t HRTIM_COMMON_BMCMPR6_BMCMP_POS     = 0;    /** @brief BMCMP */
  static const int32_t HRTIM_COMMON_BMPER_BMPER_POS       = 0;    /** @brief Burst mode period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TEPER_POS    = 31;   /** @brief ADC trigger 1 on timer E period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TDPER_POS    = 27;   /** @brief ADC trigger 1 on timer D period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TCPER_POS    = 23;   /** @brief ADC trigger 1 on timer C period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TBRST_POS    = 19;   /** @brief ADC trigger 1 on timer B reset */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TBPER_POS    = 18;   /** @brief ADC trigger 1 on timer B period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TARST_POS    = 14;   /** @brief ADC trigger 1 on timer A reset */
  static const int32_t HRTIM_COMMON_ADCxR_AD1TAPER_POS    = 13;   /** @brief ADC trigger 1 on timer A period */
  static const int32_t HRTIM_COMMON_ADCxR_AD1MPER_POS     = 4;    /** @brief ADC trigger 1 on master period */
  static const int32_t HRTIM_COMMON_DLLCR_CALRTE_POS      = 2;    /** @brief DLL calibration rate */
  static const int32_t HRTIM_COMMON_DLLCR_CALEN_POS       = 1;    /** @brief DLL calibration enable */
  static const int32_t HRTIM_COMMON_DLLCR_CAL_POS         = 0;    /** @brief DLL calibration start */
  static const int32_t HRTIM_COMMON_BDMUPDR_MREP_POS      = 5;    /** @brief MREP */
  static const int32_t HRTIM_COMMON_BDMUPDR_MPER_POS      = 4;    /** @brief MPER */
  static const int32_t HRTIM_COMMON_BDMUPDR_MCNT_POS      = 3;    /** @brief MCNT */
  static const int32_t HRTIM_COMMON_BDMUPDR_MDIER_POS     = 2;    /** @brief MDIER */
  static const int32_t HRTIM_COMMON_BDMUPDR_MICR_POS      = 1;    /** @brief MICR */
  static const int32_t HRTIM_COMMON_BDMUPDR_MCR_POS       = 0;    /** @brief MCR */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXFLTR_POS  = 20;   /** @brief HRTIM_FLTxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXOUTR_POS  = 19;   /** @brief HRTIM_OUTxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCHPR_POS  = 18;   /** @brief HRTIM_CHPxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXRSTR_POS  = 17;   /** @brief HRTIM_RSTxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMX_DTXR_POS = 10;   /** @brief HRTIM_DTxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXREP_POS   = 5;    /** @brief HRTIM_REPxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXPER_POS   = 4;    /** @brief HRTIM_PERxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCNT_POS   = 3;    /** @brief HRTIM_CNTxR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXDIER_POS  = 2;    /** @brief HRTIM_TIMxDIER register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXICR_POS   = 1;    /** @brief HRTIM_TIMxICR register update enable */
  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCR_POS    = 0;    /** @brief HRTIM_TIMxCR register update enable */

  /**** @subsection Enumerated HRTIM_COMMON Register Field Positions ****/

  static const int32_t HRTIM_COMMON_CRx_ADxUSRC_POS[5] = {
    [1] = 16,   /** @brief ADC trigger 1 update source */
    [2] = 19,   /** @brief ADC trigger 2 update source */
    [3] = 22,   /** @brief ADC trigger 3 update source */
    [4] = 25,   /** @brief ADC trigger 4 update source */
  };

  static const int32_t HRTIM_COMMON_ISR_FLTx_POS[6] = {
    [1] = 0,   /** @brief Fault 1 interrupt flag */
    [2] = 1,   /** @brief Fault 2 interrupt flag */
    [3] = 2,   /** @brief Fault 3 interrupt flag */
    [4] = 3,   /** @brief Fault 4 interrupt flag */
    [5] = 4,   /** @brief Fault 5 interrupt flag */
  };

  static const int32_t HRTIM_COMMON_ICR_FLTxC_POS[6] = {
    [1] = 0,   /** @brief Fault 1 interrupt flag clear */
    [2] = 1,   /** @brief Fault 2 interrupt flag clear */
    [3] = 2,   /** @brief Fault 3 interrupt flag clear */
    [4] = 3,   /** @brief Fault 4 interrupt flag clear */
    [5] = 4,   /** @brief Fault 5 interrupt flag clear */
  };

  static const int32_t HRTIM_COMMON_IER_FLTxIE_POS[6] = {
    [1] = 0,   /** @brief Fault 1 interrupt enable */
    [2] = 1,   /** @brief Fault 2 interrupt enable */
    [3] = 2,   /** @brief Fault 3 interrupt enable */
    [4] = 3,   /** @brief Fault 4 interrupt enable */
    [5] = 4,   /** @brief Fault 5 interrupt enable */
  };

  static const int32_t HRTIM_COMMON_OENR_TExOEN_POS[3] = {
    [1] = 8,   /** @brief Timer E output 1 enable */
    [2] = 9,   /** @brief Timer E output 2 enable */
  };

  static const int32_t HRTIM_COMMON_OENR_TDxOEN_POS[3] = {
    [1] = 6,   /** @brief Timer D output 1 enable */
    [2] = 7,   /** @brief Timer D output 2 enable */
  };

  static const int32_t HRTIM_COMMON_OENR_TCxOEN_POS[3] = {
    [1] = 4,   /** @brief Timer C output 1 enable */
    [2] = 5,   /** @brief Timer C output 2 enable */
  };

  static const int32_t HRTIM_COMMON_OENR_TBxOEN_POS[3] = {
    [1] = 2,   /** @brief Timer B output 1 enable */
    [2] = 3,   /** @brief Timer B output 2 enable */
  };

  static const int32_t HRTIM_COMMON_OENR_TAxOEN_POS[3] = {
    [1] = 0,   /** @brief Timer A output 1 enable */
    [2] = 1,   /** @brief Timer A output 2 enable */
  };

  static const int32_t HRTIM_COMMON_DISR_TExODIS_POS[3] = {
    [1] = 8,   /** @brief TE1ODIS */
    [2] = 9,   /** @brief TE2ODIS */
  };

  static const int32_t HRTIM_COMMON_DISR_TDxODIS_POS[3] = {
    [1] = 6,   /** @brief TD1ODIS */
    [2] = 7,   /** @brief TD2ODIS */
  };

  static const int32_t HRTIM_COMMON_DISR_TCxODIS_POS[3] = {
    [1] = 4,   /** @brief TC1ODIS */
    [2] = 5,   /** @brief TC2ODIS */
  };

  static const int32_t HRTIM_COMMON_DISR_TBxODIS_POS[3] = {
    [1] = 2,   /** @brief TB1ODIS */
    [2] = 3,   /** @brief TB2ODIS */
  };

  static const int32_t HRTIM_COMMON_DISR_TAxODIS_POS[3] = {
    [1] = 0,   /** @brief TA1ODIS */
    [2] = 1,   /** @brief TA2ODIS */
  };

  static const int32_t HRTIM_COMMON_ODSR_TExODS_POS[3] = {
    [1] = 8,   /** @brief Timer E output 1 disable status */
    [2] = 9,   /** @brief Timer E output 2 disable status */
  };

  static const int32_t HRTIM_COMMON_ODSR_TDxODS_POS[3] = {
    [1] = 6,   /** @brief Timer D output 1 disable status */
    [2] = 7,   /** @brief Timer D output 2 disable status */
  };

  static const int32_t HRTIM_COMMON_ODSR_TCxODS_POS[3] = {
    [1] = 4,   /** @brief Timer C output 1 disable status */
    [2] = 5,   /** @brief Timer C output 2 disable status */
  };

  static const int32_t HRTIM_COMMON_ODSR_TBxODS_POS[3] = {
    [1] = 2,   /** @brief Timer B output 1 disable status */
    [2] = 3,   /** @brief Timer B output 2 disable status */
  };

  static const int32_t HRTIM_COMMON_ODSR_TAxODS_POS[3] = {
    [1] = 0,   /** @brief Timer A output 1 disable status */
    [2] = 1,   /** @brief Timer A output 2 disable status */
  };

  static const int32_t HRTIM_COMMON_BMTRG_TECMPx_POS[3] = {
    [1] = 25,   /** @brief TECMP1 */
    [2] = 26,   /** @brief TECMP2 */
  };

  static const int32_t HRTIM_COMMON_BMTRG_TDCMPx_POS[3] = {
    [1] = 21,   /** @brief TDCMP1 */
    [2] = 22,   /** @brief TDCMP2 */
  };

  static const int32_t HRTIM_COMMON_BMTRG_TCCMPx_POS[3] = {
    [1] = 17,   /** @brief TCCMP1 */
    [2] = 18,   /** @brief TCCMP2 */
  };

  static const int32_t HRTIM_COMMON_BMTRG_TBCMPx_POS[3] = {
    [1] = 13,   /** @brief TBCMP1 */
    [2] = 14,   /** @brief TBCMP2 */
  };

  static const int32_t HRTIM_COMMON_BMTRG_TACMPx_POS[3] = {
    [1] = 9,    /** @brief TACMP1 */
    [2] = 10,   /** @brief TACMP2 */
  };

  static const int32_t HRTIM_COMMON_BMTRG_MSTCMPx_POS[5] = {
    [1] = 3,   /** @brief MSTCMP1 */
    [2] = 4,   /** @brief MSTCMP2 */
    [3] = 5,   /** @brief MSTCMP3 */
    [4] = 6,   /** @brief MSTCMP4 */
  };

  static const int32_t HRTIM_COMMON_EECRx_EExFAST_POS[6] = {
    [1] = 5,    /** @brief External event 1 fast mode */
    [2] = 11,   /** @brief External event 2 fast mode */
    [3] = 17,   /** @brief External event 3 fast mode */
    [4] = 23,   /** @brief External event 4 fast mode */
    [5] = 29,   /** @brief External event 5 fast mode */
  };

  static const int32_t HRTIM_COMMON_EECRx_EExSNS_POS[6] = {
    [1] = 3,    /** @brief External event 1 sensitivity */
    [2] = 9,    /** @brief External event 2 sensitivity */
    [3] = 15,   /** @brief External event 3 sensitivity */
    [4] = 21,   /** @brief External event 4 sensitivity */
    [5] = 27,   /** @brief External event 5 sensitivity */
  };

  static const int32_t HRTIM_COMMON_EECRx_EExPOL_POS[6] = {
    [1] = 2,    /** @brief External event 1 polarity */
    [2] = 8,    /** @brief External event 2 polarity */
    [3] = 14,   /** @brief External event 3 polarity */
    [4] = 20,   /** @brief External event 4 polarity */
    [5] = 26,   /** @brief External event 5 polarity */
  };

  static const int32_t HRTIM_COMMON_EECRx_EExSRC_POS[6] = {
    [1] = 0,    /** @brief External event 1 source */
    [2] = 6,    /** @brief External event 2 source */
    [3] = 12,   /** @brief External event 3 source */
    [4] = 18,   /** @brief External event 4 source */
    [5] = 24,   /** @brief External event 5 source */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1TECx_POS[5] = {
    [2] = 28,   /** @brief ADC trigger 1 on timer E compare 2 */
    [3] = 29,   /** @brief ADC trigger 1 on timer E compare 3 */
    [4] = 30,   /** @brief ADC trigger 1 on timer E compare 4 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1TDCx_POS[5] = {
    [2] = 24,   /** @brief ADC trigger 1 on timer D compare 2 */
    [3] = 25,   /** @brief ADC trigger 1 on timer D compare 3 */
    [4] = 26,   /** @brief ADC trigger 1 on timer D compare 4 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1TCCx_POS[5] = {
    [2] = 20,   /** @brief ADC trigger 1 on timer C compare 2 */
    [3] = 21,   /** @brief ADC trigger 1 on timer C compare 3 */
    [4] = 22,   /** @brief ADC trigger 1 on timer C compare 4 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1TBCx_POS[5] = {
    [2] = 15,   /** @brief ADC trigger 1 on timer B compare 2 */
    [3] = 16,   /** @brief ADC trigger 1 on timer B compare 3 */
    [4] = 17,   /** @brief ADC trigger 1 on timer B compare 4 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1TACx_POS[5] = {
    [2] = 10,   /** @brief ADC trigger 1 on timer A compare 2 */
    [3] = 11,   /** @brief ADC trigger 1 on timer A compare 3 */
    [4] = 12,   /** @brief ADC trigger 1 on timer A compare 4 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1EEVx_POS[6] = {
    [1] = 5,   /** @brief ADC trigger 1 on external event 1 */
    [2] = 6,   /** @brief ADC trigger 1 on external event 2 */
    [3] = 7,   /** @brief ADC trigger 1 on external event 3 */
    [4] = 8,   /** @brief ADC trigger 1 on external event 4 */
    [5] = 9,   /** @brief ADC trigger 1 on external event 5 */
  };

  static const int32_t HRTIM_COMMON_ADCxR_AD1MCx_POS[5] = {
    [1] = 0,   /** @brief ADC trigger 1 on master compare 1 */
    [2] = 1,   /** @brief ADC trigger 1 on master compare 2 */
    [3] = 2,   /** @brief ADC trigger 1 on master compare 3 */
    [4] = 3,   /** @brief ADC trigger 1 on master compare 4 */
  };

  static const int32_t HRTIM_COMMON_FLTINRx_FLTxLCK_POS[5] = {
    [1] = 7,    /** @brief FLT1LCK */
    [2] = 15,   /** @brief FLT2LCK */
    [3] = 23,   /** @brief FLT3LCK */
    [4] = 31,   /** @brief FLT4LCK */
  };

  static const int32_t HRTIM_COMMON_FLTINRx_FLTxF_POS[5] = {
    [1] = 3,    /** @brief FLT1F */
    [2] = 11,   /** @brief FLT2F */
    [3] = 19,   /** @brief FLT3F */
    [4] = 27,   /** @brief FLT4F */
  };

  static const int32_t HRTIM_COMMON_FLTINRx_FLTxSRC_POS[5] = {
    [1] = 2,    /** @brief FLT1SRC */
    [2] = 10,   /** @brief FLT2SRC */
    [3] = 18,   /** @brief FLT3SRC */
    [4] = 26,   /** @brief FLT4SRC */
  };

  static const int32_t HRTIM_COMMON_FLTINRx_FLTxP_POS[5] = {
    [1] = 1,    /** @brief FLT1P */
    [2] = 9,    /** @brief FLT2P */
    [3] = 17,   /** @brief FLT3P */
    [4] = 25,   /** @brief FLT4P */
  };

  static const int32_t HRTIM_COMMON_FLTINRx_FLTxE_POS[5] = {
    [1] = 0,    /** @brief FLT1E */
    [2] = 8,    /** @brief FLT2E */
    [3] = 16,   /** @brief FLT3E */
    [4] = 24,   /** @brief FLT4E */
  };

  static const int32_t HRTIM_COMMON_BDMUPDR_MCMPx_POS[5] = {
    [1] = 6,   /** @brief MCMP1 */
    [2] = 7,   /** @brief MCMP2 */
    [3] = 8,   /** @brief MCMP3 */
    [4] = 9,   /** @brief MCMP4 */
  };

  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXEEFRx_POS[3] = {
    [1] = 15,   /** @brief HRTIM_EEFxR1 register update enable */
    [2] = 16,   /** @brief HRTIM_EEFxR2 register update enable */
  };

  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXRSTxR_POS[3] = {
    [1] = 12,   /** @brief HRTIM_RST1xR register update enable */
    [2] = 14,   /** @brief HRTIM_RST2xR register update enable */
  };

  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXSETxR_POS[3] = {
    [1] = 11,   /** @brief HRTIM_SET1xR register update enable */
    [2] = 13,   /** @brief HRTIM_SET2xR register update enable */
  };

  static const int32_t HRTIM_COMMON_BDTXUPR_TIMXCMPx_POS[5] = {
    [1] = 6,   /** @brief HRTIM_CMP1xR register update enable */
    [2] = 7,   /** @brief HRTIM_CMP2xR register update enable */
    [3] = 8,   /** @brief HRTIM_CMP3xR register update enable */
    [4] = 9,   /** @brief HRTIM_CMP4xR register update enable */
  };

  /**********************************************************************************************
   * @section DFSDM Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated DFSDM Register Pointers ****/

  static RW_ uint32_t* const DFSDM_DFSDM_CHCFG0Rx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40017000U,   /** @brief DFSDM channel configuration 0 register 1 */
    [2] = (RW_ uint32_t* const)0x40017020U,   /** @brief DFSDM channel configuration 0 register 2 */
  };

  static RW_ uint32_t* const DFSDM_DFSDM_CHCFGxR1_PTR[8] = {
    [1] = (RW_ uint32_t* const)0x40017004U,   /** @brief DFSDM channel configuration 1 register 1 */
    [2] = (RW_ uint32_t* const)0x40017008U,   /** @brief DFSDM channel configuration 2 register 1 */
    [3] = (RW_ uint32_t* const)0x4001700CU,   /** @brief DFSDM channel configuration 3 register 1 */
    [4] = (RW_ uint32_t* const)0x40017010U,   /** @brief DFSDM channel configuration 4 register 1 */
    [5] = (RW_ uint32_t* const)0x40017014U,   /** @brief DFSDM channel configuration 5 register 1 */
    [6] = (RW_ uint32_t* const)0x40017018U,   /** @brief DFSDM channel configuration 6 register 1 */
    [7] = (RW_ uint32_t* const)0x4001701CU,   /** @brief DFSDM channel configuration 7 register 1 */
  };

  static RW_ uint32_t* const DFSDM_DFSDM_CHCFGxR2_PTR[8] = {
    [1] = (RW_ uint32_t* const)0x40017024U,   /** @brief DFSDM channel configuration 1 register 2 */
    [2] = (RW_ uint32_t* const)0x40017028U,   /** @brief DFSDM channel configuration 2 register 2 */
    [3] = (RW_ uint32_t* const)0x4001702CU,   /** @brief DFSDM channel configuration 3 register 2 */
    [4] = (RW_ uint32_t* const)0x40017030U,   /** @brief DFSDM channel configuration 4 register 2 */
    [5] = (RW_ uint32_t* const)0x40017034U,   /** @brief DFSDM channel configuration 5 register 2 */
    [6] = (RW_ uint32_t* const)0x40017038U,   /** @brief DFSDM channel configuration 6 register 2 */
    [7] = (RW_ uint32_t* const)0x4001703CU,   /** @brief DFSDM channel configuration 7 register 2 */
  };

  static RW_ uint32_t* const DFSDM_DFSDM_AWSCDxR_PTR[8] = {
    [0] = (RW_ uint32_t* const)0x40017040U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [1] = (RW_ uint32_t* const)0x40017044U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [2] = (RW_ uint32_t* const)0x40017048U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [3] = (RW_ uint32_t* const)0x4001704CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [4] = (RW_ uint32_t* const)0x40017050U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [5] = (RW_ uint32_t* const)0x40017054U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [6] = (RW_ uint32_t* const)0x40017058U,   /** @brief DFSDM analog watchdog and short-circuit detector register */
    [7] = (RW_ uint32_t* const)0x4001705CU,   /** @brief DFSDM analog watchdog and short-circuit detector register */
  };

  static RO_ uint32_t* const DFSDM_DFSDM_CHWDATxR_PTR[8] = {
    [0] = (RO_ uint32_t* const)0x40017060U,   /** @brief DFSDM channel watchdog filter data register */
    [1] = (RO_ uint32_t* const)0x40017064U,   /** @brief DFSDM channel watchdog filter data register */
    [2] = (RO_ uint32_t* const)0x40017068U,   /** @brief DFSDM channel watchdog filter data register */
    [3] = (RO_ uint32_t* const)0x4001706CU,   /** @brief DFSDM channel watchdog filter data register */
    [4] = (RO_ uint32_t* const)0x40017070U,   /** @brief DFSDM channel watchdog filter data register */
    [5] = (RO_ uint32_t* const)0x40017074U,   /** @brief DFSDM channel watchdog filter data register */
    [6] = (RO_ uint32_t* const)0x40017078U,   /** @brief DFSDM channel watchdog filter data register */
    [7] = (RO_ uint32_t* const)0x4001707CU,   /** @brief DFSDM channel watchdog filter data register */
  };

  static RW_ uint32_t* const DFSDM_DFSDM_CHDATINxR_PTR[8] = {
    [0] = (RW_ uint32_t* const)0x40017080U,   /** @brief DFSDM channel data input register */
    [1] = (RW_ uint32_t* const)0x40017084U,   /** @brief DFSDM channel data input register */
    [2] = (RW_ uint32_t* const)0x40017088U,   /** @brief DFSDM channel data input register */
    [3] = (RW_ uint32_t* const)0x4001708CU,   /** @brief DFSDM channel data input register */
    [4] = (RW_ uint32_t* const)0x40017090U,   /** @brief DFSDM channel data input register */
    [5] = (RW_ uint32_t* const)0x40017094U,   /** @brief DFSDM channel data input register */
    [6] = (RW_ uint32_t* const)0x40017098U,   /** @brief DFSDM channel data input register */
    [7] = (RW_ uint32_t* const)0x4001709CU,   /** @brief DFSDM channel data input register */
  };

  static RW_ uint32_t* const DFSDM_DFSDM0_CRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x400170A0U,   /** @brief DFSDM control register 1 */
    [2] = (RW_ uint32_t* const)0x400170B0U,   /** @brief DFSDM control register 2 */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_CR1_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400170A4U,   /** @brief DFSDM control register 1 */
    [2] = (RW_ uint32_t* const)0x400170A8U,   /** @brief DFSDM control register 1 */
    [3] = (RW_ uint32_t* const)0x400170ACU,   /** @brief DFSDM control register 1 */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_CR2_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x400170B4U,   /** @brief DFSDM control register 2 */
    [2] = (RW_ uint32_t* const)0x400170B8U,   /** @brief DFSDM control register 2 */
    [3] = (RW_ uint32_t* const)0x400170BCU,   /** @brief DFSDM control register 2 */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_ISR_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x400170C0U,   /** @brief DFSDM interrupt and status register */
    [1] = (RO_ uint32_t* const)0x400170C4U,   /** @brief DFSDM interrupt and status register */
    [2] = (RO_ uint32_t* const)0x400170C8U,   /** @brief DFSDM interrupt and status register */
    [3] = (RO_ uint32_t* const)0x400170CCU,   /** @brief DFSDM interrupt and status register */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_ICR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x400170D0U,   /** @brief DFSDM interrupt flag clear register */
    [1] = (RW_ uint32_t* const)0x400170D4U,   /** @brief DFSDM interrupt flag clear register */
    [2] = (RW_ uint32_t* const)0x400170D8U,   /** @brief DFSDM interrupt flag clear register */
    [3] = (RW_ uint32_t* const)0x400170DCU,   /** @brief DFSDM interrupt flag clear register */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_JCHGR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x400170E0U,   /** @brief DFSDM injected channel group selection register */
    [1] = (RW_ uint32_t* const)0x400170E4U,   /** @brief DFSDM injected channel group selection register */
    [2] = (RW_ uint32_t* const)0x400170E8U,   /** @brief DFSDM injected channel group selection register */
    [3] = (RW_ uint32_t* const)0x400170ECU,   /** @brief DFSDM injected channel group selection register */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_FCR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x400170F0U,   /** @brief DFSDM filter control register */
    [1] = (RW_ uint32_t* const)0x400170F4U,   /** @brief DFSDM filter control register */
    [2] = (RW_ uint32_t* const)0x400170F8U,   /** @brief DFSDM filter control register */
    [3] = (RW_ uint32_t* const)0x400170FCU,   /** @brief DFSDM filter control register */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_JDATAR_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017100U,   /** @brief DFSDM data register for injected group */
    [1] = (RO_ uint32_t* const)0x40017104U,   /** @brief DFSDM data register for injected group */
    [2] = (RO_ uint32_t* const)0x40017108U,   /** @brief DFSDM data register for injected group */
    [3] = (RO_ uint32_t* const)0x4001710CU,   /** @brief DFSDM data register for injected group */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_RDATAR_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017110U,   /** @brief DFSDM data register for the regular channel */
    [1] = (RO_ uint32_t* const)0x40017114U,   /** @brief DFSDM data register for the regular channel */
    [2] = (RO_ uint32_t* const)0x40017118U,   /** @brief DFSDM data register for the regular channel */
    [3] = (RO_ uint32_t* const)0x4001711CU,   /** @brief DFSDM data register for the regular channel */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_AWHTR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x40017120U,   /** @brief DFSDM analog watchdog high threshold register */
    [1] = (RW_ uint32_t* const)0x40017124U,   /** @brief DFSDM analog watchdog high threshold register */
    [2] = (RW_ uint32_t* const)0x40017128U,   /** @brief DFSDM analog watchdog high threshold register */
    [3] = (RW_ uint32_t* const)0x4001712CU,   /** @brief DFSDM analog watchdog high threshold register */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_AWLTR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x40017130U,   /** @brief DFSDM analog watchdog low threshold register */
    [1] = (RW_ uint32_t* const)0x40017134U,   /** @brief DFSDM analog watchdog low threshold register */
    [2] = (RW_ uint32_t* const)0x40017138U,   /** @brief DFSDM analog watchdog low threshold register */
    [3] = (RW_ uint32_t* const)0x4001713CU,   /** @brief DFSDM analog watchdog low threshold register */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_AWSR_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017140U,   /** @brief DFSDM analog watchdog status register */
    [1] = (RO_ uint32_t* const)0x40017144U,   /** @brief DFSDM analog watchdog status register */
    [2] = (RO_ uint32_t* const)0x40017148U,   /** @brief DFSDM analog watchdog status register */
    [3] = (RO_ uint32_t* const)0x4001714CU,   /** @brief DFSDM analog watchdog status register */
  };

  static RW_ uint32_t* const DFSDM_DFSDMx_AWCFR_PTR[4] = {
    [0] = (RW_ uint32_t* const)0x40017150U,   /** @brief DFSDM analog watchdog clear flag register */
    [1] = (RW_ uint32_t* const)0x40017154U,   /** @brief DFSDM analog watchdog clear flag register */
    [2] = (RW_ uint32_t* const)0x40017158U,   /** @brief DFSDM analog watchdog clear flag register */
    [3] = (RW_ uint32_t* const)0x4001715CU,   /** @brief DFSDM analog watchdog clear flag register */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_EXMAX_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017160U,   /** @brief DFSDM extremes detector maximum register */
    [1] = (RO_ uint32_t* const)0x40017164U,   /** @brief DFSDM extremes detector maximum register */
    [2] = (RO_ uint32_t* const)0x40017168U,   /** @brief DFSDM extremes detector maximum register */
    [3] = (RO_ uint32_t* const)0x4001716CU,   /** @brief DFSDM extremes detector maximum register */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_EXMIN_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017170U,   /** @brief DFSDM extremes detector minimum register */
    [1] = (RO_ uint32_t* const)0x40017174U,   /** @brief DFSDM extremes detector minimum register */
    [2] = (RO_ uint32_t* const)0x40017178U,   /** @brief DFSDM extremes detector minimum register */
    [3] = (RO_ uint32_t* const)0x4001717CU,   /** @brief DFSDM extremes detector minimum register */
  };

  static RO_ uint32_t* const DFSDM_DFSDMx_CNVTIMR_PTR[4] = {
    [0] = (RO_ uint32_t* const)0x40017180U,   /** @brief DFSDM conversion timer register */
    [1] = (RO_ uint32_t* const)0x40017184U,   /** @brief DFSDM conversion timer register */
    [2] = (RO_ uint32_t* const)0x40017188U,   /** @brief DFSDM conversion timer register */
    [3] = (RO_ uint32_t* const)0x4001718CU,   /** @brief DFSDM conversion timer register */
  };

  /**** @subsection DFSDM Register Field Masks ****/

  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_SITP_MSK     = 0x00000003U;   /** @brief Serial interface type for channel 0 */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_SPICKSEL_MSK = 0x0000000CU;   /** @brief SPI clock select for channel 0 */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_SCDEN_MSK    = 0x00000020U;   /** @brief Short-circuit detector enable on channel 0 */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_CKABEN_MSK   = 0x00000040U;   /** @brief Clock absence detector enable on channel 0 */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_CHEN_MSK     = 0x00000080U;   /** @brief Channel 0 enable */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_CHINSEL_MSK  = 0x00000100U;   /** @brief Channel inputs selection */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_DATMPX_MSK   = 0x00003000U;   /** @brief Input data multiplexer for channel 0 */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_DATPACK_MSK  = 0x0000C000U;   /** @brief Data packing mode in dfsdm_chdatinyr register */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTDIV_MSK = 0x00FF0000U;   /** @brief Output serial clock divider */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTSRC_MSK = 0x40000000U;   /** @brief Output serial clock source selection */
  static const uint32_t DFSDM_DFSDM_CHCFG0Rx_DFSDMEN_MSK  = 0x80000000U;   /** @brief Global enable for DFSDM interface */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_SITP_MSK     = 0x00000003U;   /** @brief Serial interface type for channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_SPICKSEL_MSK = 0x0000000CU;   /** @brief SPI clock select for channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_SCDEN_MSK    = 0x00000020U;   /** @brief Short-circuit detector enable on channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKABEN_MSK   = 0x00000040U;   /** @brief Clock absence detector enable on channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_CHEN_MSK     = 0x00000080U;   /** @brief Channel 1 enable */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_CHINSEL_MSK  = 0x00000100U;   /** @brief Channel inputs selection */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_DATMPX_MSK   = 0x00003000U;   /** @brief Input data multiplexer for channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_DATPACK_MSK  = 0x0000C000U;   /** @brief Data packing mode in dfsdm_chdatinyr register */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKOUTDIV_MSK = 0x00FF0000U;   /** @brief Output serial clock divider */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_CKOUTSRC_MSK = 0x40000000U;   /** @brief Output serial clock source selection */
  static const uint32_t DFSDM_DFSDM_CHCFGxR1_DFSDMEN_MSK  = 0x80000000U;   /** @brief Global enable for DFSDM interface */
  static const uint32_t DFSDM_DFSDM_CHCFGxR2_DTRBS_MSK    = 0x000000F8U;   /** @brief Data right bit-shift for channel 1 */
  static const uint32_t DFSDM_DFSDM_CHCFGxR2_OFFSET_MSK   = 0xFFFFFF00U;   /** @brief 24-bit calibration offset for channel 1 */
  static const uint32_t DFSDM_DFSDM_AWSCDxR_SCDT_MSK      = 0x000000FFU;   /** @brief Short-circuit detector threshold for channel 0 */
  static const uint32_t DFSDM_DFSDM_AWSCDxR_BKSCD_MSK     = 0x0000F000U;   /** @brief Break signal assignment for short-circuit detector on channel 0 */
  static const uint32_t DFSDM_DFSDM_AWSCDxR_AWFOSR_MSK    = 0x001F0000U;   /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
  static const uint32_t DFSDM_DFSDM_AWSCDxR_AWFORD_MSK    = 0x00C00000U;   /** @brief Analog watchdog sinc filter order on channel 0 */
  static const uint32_t DFSDM_DFSDM_CHWDATxR_WDATA_MSK    = 0x0000FFFFU;   /** @brief Input channel y watchdog data */
  static const uint32_t DFSDM_DFSDM0_CRx_DFEN_MSK         = 0x00000001U;   /** @brief DFSDM enable */
  static const uint32_t DFSDM_DFSDM0_CRx_JSWSTART_MSK     = 0x00000002U;   /** @brief Start a conversion of the injected group of channels */
  static const uint32_t DFSDM_DFSDM0_CRx_JSYNC_MSK        = 0x00000008U;   /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
  static const uint32_t DFSDM_DFSDM0_CRx_JSCAN_MSK        = 0x00000010U;   /** @brief Scanning conversion mode for injected conversions */
  static const uint32_t DFSDM_DFSDM0_CRx_JDMAEN_MSK       = 0x00000020U;   /** @brief DMA channel enabled to read data for the injected channel group */
  static const uint32_t DFSDM_DFSDM0_CRx_JEXTSEL_MSK      = 0x00001F00U;   /** @brief Trigger signal selection for launching injected conversions */
  static const uint32_t DFSDM_DFSDM0_CRx_JEXTEN_MSK       = 0x00006000U;   /** @brief Trigger enable and trigger edge selection for injected conversions */
  static const uint32_t DFSDM_DFSDM0_CRx_RSWSTART_MSK     = 0x00020000U;   /** @brief Software start of a conversion on the regular channel */
  static const uint32_t DFSDM_DFSDM0_CRx_RCONT_MSK        = 0x00040000U;   /** @brief Continuous mode selection for regular conversions */
  static const uint32_t DFSDM_DFSDM0_CRx_RSYNC_MSK        = 0x00080000U;   /** @brief Launch regular conversion synchronously with DFSDM0 */
  static const uint32_t DFSDM_DFSDM0_CRx_RDMAEN_MSK       = 0x00200000U;   /** @brief DMA channel enabled to read data for the regular conversion */
  static const uint32_t DFSDM_DFSDM0_CRx_RCH_MSK          = 0x07000000U;   /** @brief Regular channel selection */
  static const uint32_t DFSDM_DFSDM0_CRx_FAST_MSK         = 0x20000000U;   /** @brief Fast conversion mode selection for regular conversions */
  static const uint32_t DFSDM_DFSDM0_CRx_AWFSEL_MSK       = 0x40000000U;   /** @brief Analog watchdog fast mode select */
  static const uint32_t DFSDM_DFSDMx_CR1_DFEN_MSK         = 0x00000001U;   /** @brief DFSDM enable */
  static const uint32_t DFSDM_DFSDMx_CR1_JSWSTART_MSK     = 0x00000002U;   /** @brief Start a conversion of the injected group of channels */
  static const uint32_t DFSDM_DFSDMx_CR1_JSYNC_MSK        = 0x00000008U;   /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
  static const uint32_t DFSDM_DFSDMx_CR1_JSCAN_MSK        = 0x00000010U;   /** @brief Scanning conversion mode for injected conversions */
  static const uint32_t DFSDM_DFSDMx_CR1_JDMAEN_MSK       = 0x00000020U;   /** @brief DMA channel enabled to read data for the injected channel group */
  static const uint32_t DFSDM_DFSDMx_CR1_JEXTSEL_MSK      = 0x00001F00U;   /** @brief Trigger signal selection for launching injected conversions */
  static const uint32_t DFSDM_DFSDMx_CR1_JEXTEN_MSK       = 0x00006000U;   /** @brief Trigger enable and trigger edge selection for injected conversions */
  static const uint32_t DFSDM_DFSDMx_CR1_RSWSTART_MSK     = 0x00020000U;   /** @brief Software start of a conversion on the regular channel */
  static const uint32_t DFSDM_DFSDMx_CR1_RCONT_MSK        = 0x00040000U;   /** @brief Continuous mode selection for regular conversions */
  static const uint32_t DFSDM_DFSDMx_CR1_RSYNC_MSK        = 0x00080000U;   /** @brief Launch regular conversion synchronously with DFSDM0 */
  static const uint32_t DFSDM_DFSDMx_CR1_RDMAEN_MSK       = 0x00200000U;   /** @brief DMA channel enabled to read data for the regular conversion */
  static const uint32_t DFSDM_DFSDMx_CR1_RCH_MSK          = 0x07000000U;   /** @brief Regular channel selection */
  static const uint32_t DFSDM_DFSDMx_CR1_FAST_MSK         = 0x20000000U;   /** @brief Fast conversion mode selection for regular conversions */
  static const uint32_t DFSDM_DFSDMx_CR1_AWFSEL_MSK       = 0x40000000U;   /** @brief Analog watchdog fast mode select */
  static const uint32_t DFSDM_DFSDMx_CR2_JEOCIE_MSK       = 0x00000001U;   /** @brief Injected end of conversion interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_REOCIE_MSK       = 0x00000002U;   /** @brief Regular end of conversion interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_JOVRIE_MSK       = 0x00000004U;   /** @brief Injected data overrun interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_ROVRIE_MSK       = 0x00000008U;   /** @brief Regular data overrun interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_AWDIE_MSK        = 0x00000010U;   /** @brief Analog watchdog interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_SCDIE_MSK        = 0x00000020U;   /** @brief Short-circuit detector interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_CKABIE_MSK       = 0x00000040U;   /** @brief Clock absence interrupt enable */
  static const uint32_t DFSDM_DFSDMx_CR2_EXCH_MSK         = 0x0000FF00U;   /** @brief Extremes detector channel selection */
  static const uint32_t DFSDM_DFSDMx_CR2_AWDCH_MSK        = 0x00FF0000U;   /** @brief Analog watchdog channel selection */
  static const uint32_t DFSDM_DFSDMx_ISR_JEOCF_MSK        = 0x00000001U;   /** @brief End of injected conversion flag */
  static const uint32_t DFSDM_DFSDMx_ISR_REOCF_MSK        = 0x00000002U;   /** @brief End of regular conversion flag */
  static const uint32_t DFSDM_DFSDMx_ISR_JOVRF_MSK        = 0x00000004U;   /** @brief Injected conversion overrun flag */
  static const uint32_t DFSDM_DFSDMx_ISR_ROVRF_MSK        = 0x00000008U;   /** @brief Regular conversion overrun flag */
  static const uint32_t DFSDM_DFSDMx_ISR_AWDF_MSK         = 0x00000010U;   /** @brief Analog watchdog */
  static const uint32_t DFSDM_DFSDMx_ISR_JCIP_MSK         = 0x00002000U;   /** @brief Injected conversion in progress status */
  static const uint32_t DFSDM_DFSDMx_ISR_RCIP_MSK         = 0x00004000U;   /** @brief Regular conversion in progress status */
  static const uint32_t DFSDM_DFSDMx_ISR_CKABF_MSK        = 0x00FF0000U;   /** @brief Clock absence flag */
  static const uint32_t DFSDM_DFSDMx_ISR_SCDF_MSK         = 0xFF000000U;   /** @brief Short-circuit detector flag */
  static const uint32_t DFSDM_DFSDMx_ICR_CLRJOVRF_MSK     = 0x00000004U;   /** @brief Clear the injected conversion overrun flag */
  static const uint32_t DFSDM_DFSDMx_ICR_CLRROVRF_MSK     = 0x00000008U;   /** @brief Clear the regular conversion overrun flag */
  static const uint32_t DFSDM_DFSDMx_ICR_CLRCKABF_MSK     = 0x00FF0000U;   /** @brief Clear the clock absence flag */
  static const uint32_t DFSDM_DFSDMx_ICR_CLRSCDF_MSK      = 0xFF000000U;   /** @brief Clear the short-circuit detector flag */
  static const uint32_t DFSDM_DFSDMx_JCHGR_JCHG_MSK       = 0x000000FFU;   /** @brief Injected channel group selection */
  static const uint32_t DFSDM_DFSDMx_FCR_IOSR_MSK         = 0x000000FFU;   /** @brief Integrator oversampling ratio (averaging length) */
  static const uint32_t DFSDM_DFSDMx_FCR_FOSR_MSK         = 0x03FF0000U;   /** @brief Sinc filter oversampling ratio (decimation rate) */
  static const uint32_t DFSDM_DFSDMx_FCR_FORD_MSK         = 0xE0000000U;   /** @brief Sinc filter order */
  static const uint32_t DFSDM_DFSDMx_JDATAR_JDATACH_MSK   = 0x00000007U;   /** @brief Injected channel most recently converted */
  static const uint32_t DFSDM_DFSDMx_JDATAR_JDATA_MSK     = 0xFFFFFF00U;   /** @brief Injected group conversion data */
  static const uint32_t DFSDM_DFSDMx_RDATAR_RDATACH_MSK   = 0x00000007U;   /** @brief Regular channel most recently converted */
  static const uint32_t DFSDM_DFSDMx_RDATAR_RPEND_MSK     = 0x00000010U;   /** @brief Regular channel pending data */
  static const uint32_t DFSDM_DFSDMx_RDATAR_RDATA_MSK     = 0xFFFFFF00U;   /** @brief Regular channel conversion data */
  static const uint32_t DFSDM_DFSDMx_AWHTR_BKAWH_MSK      = 0x0000000FU;   /** @brief Break signal assignment to analog watchdog high threshold event */
  static const uint32_t DFSDM_DFSDMx_AWHTR_AWHT_MSK       = 0xFFFFFF00U;   /** @brief Analog watchdog high threshold */
  static const uint32_t DFSDM_DFSDMx_AWLTR_BKAWL_MSK      = 0x0000000FU;   /** @brief Break signal assignment to analog watchdog low threshold event */
  static const uint32_t DFSDM_DFSDMx_AWLTR_AWLT_MSK       = 0xFFFFFF00U;   /** @brief Analog watchdog low threshold */
  static const uint32_t DFSDM_DFSDMx_AWSR_AWLTF_MSK       = 0x000000FFU;   /** @brief Analog watchdog low threshold flag */
  static const uint32_t DFSDM_DFSDMx_AWSR_AWHTF_MSK       = 0x0000FF00U;   /** @brief Analog watchdog high threshold flag */
  static const uint32_t DFSDM_DFSDMx_AWCFR_CLRAWLTF_MSK   = 0x000000FFU;   /** @brief Clear the analog watchdog low threshold flag */
  static const uint32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF_MSK   = 0x0000FF00U;   /** @brief Clear the analog watchdog high threshold flag */
  static const uint32_t DFSDM_DFSDMx_EXMAX_EXMAXCH_MSK    = 0x00000007U;   /** @brief Extremes detector maximum data channel */
  static const uint32_t DFSDM_DFSDMx_EXMAX_EXMAX_MSK      = 0xFFFFFF00U;   /** @brief Extremes detector maximum value */
  static const uint32_t DFSDM_DFSDMx_EXMIN_EXMINCH_MSK    = 0x00000007U;   /** @brief Extremes detector minimum data channel */
  static const uint32_t DFSDM_DFSDMx_EXMIN_EXMIN_MSK      = 0xFFFFFF00U;   /** @brief Extremes detector minimum value */
  static const uint32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT_MSK   = 0xFFFFFFF0U;   /** @brief 28-bit timer counting conversion time */

  /**** @subsection Enumerated DFSDM Register Field Masks ****/

  static const uint32_t DFSDM_DFSDM_CHDATINxR_INDATx_MSK[2] = {
    [0] = 0x0000FFFFU,   /** @brief Input data for channel 0 */
    [1] = 0xFFFF0000U,   /** @brief Input data for channel 1 */
  };

  /**** @subsection DFSDM Register Field Positions ****/

  static const int32_t DFSDM_DFSDM_CHCFG0Rx_SITP_POS     = 0;    /** @brief Serial interface type for channel 0 */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_SPICKSEL_POS = 2;    /** @brief SPI clock select for channel 0 */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_SCDEN_POS    = 5;    /** @brief Short-circuit detector enable on channel 0 */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_CKABEN_POS   = 6;    /** @brief Clock absence detector enable on channel 0 */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_CHEN_POS     = 7;    /** @brief Channel 0 enable */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_CHINSEL_POS  = 8;    /** @brief Channel inputs selection */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_DATMPX_POS   = 12;   /** @brief Input data multiplexer for channel 0 */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_DATPACK_POS  = 14;   /** @brief Data packing mode in dfsdm_chdatinyr register */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTDIV_POS = 16;   /** @brief Output serial clock divider */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_CKOUTSRC_POS = 30;   /** @brief Output serial clock source selection */
  static const int32_t DFSDM_DFSDM_CHCFG0Rx_DFSDMEN_POS  = 31;   /** @brief Global enable for DFSDM interface */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_SITP_POS     = 0;    /** @brief Serial interface type for channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_SPICKSEL_POS = 2;    /** @brief SPI clock select for channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_SCDEN_POS    = 5;    /** @brief Short-circuit detector enable on channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_CKABEN_POS   = 6;    /** @brief Clock absence detector enable on channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_CHEN_POS     = 7;    /** @brief Channel 1 enable */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_CHINSEL_POS  = 8;    /** @brief Channel inputs selection */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_DATMPX_POS   = 12;   /** @brief Input data multiplexer for channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_DATPACK_POS  = 14;   /** @brief Data packing mode in dfsdm_chdatinyr register */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_CKOUTDIV_POS = 16;   /** @brief Output serial clock divider */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_CKOUTSRC_POS = 30;   /** @brief Output serial clock source selection */
  static const int32_t DFSDM_DFSDM_CHCFGxR1_DFSDMEN_POS  = 31;   /** @brief Global enable for DFSDM interface */
  static const int32_t DFSDM_DFSDM_CHCFGxR2_DTRBS_POS    = 3;    /** @brief Data right bit-shift for channel 1 */
  static const int32_t DFSDM_DFSDM_CHCFGxR2_OFFSET_POS   = 8;    /** @brief 24-bit calibration offset for channel 1 */
  static const int32_t DFSDM_DFSDM_AWSCDxR_SCDT_POS      = 0;    /** @brief Short-circuit detector threshold for channel 0 */
  static const int32_t DFSDM_DFSDM_AWSCDxR_BKSCD_POS     = 12;   /** @brief Break signal assignment for short-circuit detector on channel 0 */
  static const int32_t DFSDM_DFSDM_AWSCDxR_AWFOSR_POS    = 16;   /** @brief Analog watchdog filter oversampling ratio (decimation rate) on channel 0 */
  static const int32_t DFSDM_DFSDM_AWSCDxR_AWFORD_POS    = 22;   /** @brief Analog watchdog sinc filter order on channel 0 */
  static const int32_t DFSDM_DFSDM_CHWDATxR_WDATA_POS    = 0;    /** @brief Input channel y watchdog data */
  static const int32_t DFSDM_DFSDM0_CRx_DFEN_POS         = 0;    /** @brief DFSDM enable */
  static const int32_t DFSDM_DFSDM0_CRx_JSWSTART_POS     = 1;    /** @brief Start a conversion of the injected group of channels */
  static const int32_t DFSDM_DFSDM0_CRx_JSYNC_POS        = 3;    /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
  static const int32_t DFSDM_DFSDM0_CRx_JSCAN_POS        = 4;    /** @brief Scanning conversion mode for injected conversions */
  static const int32_t DFSDM_DFSDM0_CRx_JDMAEN_POS       = 5;    /** @brief DMA channel enabled to read data for the injected channel group */
  static const int32_t DFSDM_DFSDM0_CRx_JEXTSEL_POS      = 8;    /** @brief Trigger signal selection for launching injected conversions */
  static const int32_t DFSDM_DFSDM0_CRx_JEXTEN_POS       = 13;   /** @brief Trigger enable and trigger edge selection for injected conversions */
  static const int32_t DFSDM_DFSDM0_CRx_RSWSTART_POS     = 17;   /** @brief Software start of a conversion on the regular channel */
  static const int32_t DFSDM_DFSDM0_CRx_RCONT_POS        = 18;   /** @brief Continuous mode selection for regular conversions */
  static const int32_t DFSDM_DFSDM0_CRx_RSYNC_POS        = 19;   /** @brief Launch regular conversion synchronously with DFSDM0 */
  static const int32_t DFSDM_DFSDM0_CRx_RDMAEN_POS       = 21;   /** @brief DMA channel enabled to read data for the regular conversion */
  static const int32_t DFSDM_DFSDM0_CRx_RCH_POS          = 24;   /** @brief Regular channel selection */
  static const int32_t DFSDM_DFSDM0_CRx_FAST_POS         = 29;   /** @brief Fast conversion mode selection for regular conversions */
  static const int32_t DFSDM_DFSDM0_CRx_AWFSEL_POS       = 30;   /** @brief Analog watchdog fast mode select */
  static const int32_t DFSDM_DFSDMx_CR1_DFEN_POS         = 0;    /** @brief DFSDM enable */
  static const int32_t DFSDM_DFSDMx_CR1_JSWSTART_POS     = 1;    /** @brief Start a conversion of the injected group of channels */
  static const int32_t DFSDM_DFSDMx_CR1_JSYNC_POS        = 3;    /** @brief Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger */
  static const int32_t DFSDM_DFSDMx_CR1_JSCAN_POS        = 4;    /** @brief Scanning conversion mode for injected conversions */
  static const int32_t DFSDM_DFSDMx_CR1_JDMAEN_POS       = 5;    /** @brief DMA channel enabled to read data for the injected channel group */
  static const int32_t DFSDM_DFSDMx_CR1_JEXTSEL_POS      = 8;    /** @brief Trigger signal selection for launching injected conversions */
  static const int32_t DFSDM_DFSDMx_CR1_JEXTEN_POS       = 13;   /** @brief Trigger enable and trigger edge selection for injected conversions */
  static const int32_t DFSDM_DFSDMx_CR1_RSWSTART_POS     = 17;   /** @brief Software start of a conversion on the regular channel */
  static const int32_t DFSDM_DFSDMx_CR1_RCONT_POS        = 18;   /** @brief Continuous mode selection for regular conversions */
  static const int32_t DFSDM_DFSDMx_CR1_RSYNC_POS        = 19;   /** @brief Launch regular conversion synchronously with DFSDM0 */
  static const int32_t DFSDM_DFSDMx_CR1_RDMAEN_POS       = 21;   /** @brief DMA channel enabled to read data for the regular conversion */
  static const int32_t DFSDM_DFSDMx_CR1_RCH_POS          = 24;   /** @brief Regular channel selection */
  static const int32_t DFSDM_DFSDMx_CR1_FAST_POS         = 29;   /** @brief Fast conversion mode selection for regular conversions */
  static const int32_t DFSDM_DFSDMx_CR1_AWFSEL_POS       = 30;   /** @brief Analog watchdog fast mode select */
  static const int32_t DFSDM_DFSDMx_CR2_JEOCIE_POS       = 0;    /** @brief Injected end of conversion interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_REOCIE_POS       = 1;    /** @brief Regular end of conversion interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_JOVRIE_POS       = 2;    /** @brief Injected data overrun interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_ROVRIE_POS       = 3;    /** @brief Regular data overrun interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_AWDIE_POS        = 4;    /** @brief Analog watchdog interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_SCDIE_POS        = 5;    /** @brief Short-circuit detector interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_CKABIE_POS       = 6;    /** @brief Clock absence interrupt enable */
  static const int32_t DFSDM_DFSDMx_CR2_EXCH_POS         = 8;    /** @brief Extremes detector channel selection */
  static const int32_t DFSDM_DFSDMx_CR2_AWDCH_POS        = 16;   /** @brief Analog watchdog channel selection */
  static const int32_t DFSDM_DFSDMx_ISR_JEOCF_POS        = 0;    /** @brief End of injected conversion flag */
  static const int32_t DFSDM_DFSDMx_ISR_REOCF_POS        = 1;    /** @brief End of regular conversion flag */
  static const int32_t DFSDM_DFSDMx_ISR_JOVRF_POS        = 2;    /** @brief Injected conversion overrun flag */
  static const int32_t DFSDM_DFSDMx_ISR_ROVRF_POS        = 3;    /** @brief Regular conversion overrun flag */
  static const int32_t DFSDM_DFSDMx_ISR_AWDF_POS         = 4;    /** @brief Analog watchdog */
  static const int32_t DFSDM_DFSDMx_ISR_JCIP_POS         = 13;   /** @brief Injected conversion in progress status */
  static const int32_t DFSDM_DFSDMx_ISR_RCIP_POS         = 14;   /** @brief Regular conversion in progress status */
  static const int32_t DFSDM_DFSDMx_ISR_CKABF_POS        = 16;   /** @brief Clock absence flag */
  static const int32_t DFSDM_DFSDMx_ISR_SCDF_POS         = 24;   /** @brief Short-circuit detector flag */
  static const int32_t DFSDM_DFSDMx_ICR_CLRJOVRF_POS     = 2;    /** @brief Clear the injected conversion overrun flag */
  static const int32_t DFSDM_DFSDMx_ICR_CLRROVRF_POS     = 3;    /** @brief Clear the regular conversion overrun flag */
  static const int32_t DFSDM_DFSDMx_ICR_CLRCKABF_POS     = 16;   /** @brief Clear the clock absence flag */
  static const int32_t DFSDM_DFSDMx_ICR_CLRSCDF_POS      = 24;   /** @brief Clear the short-circuit detector flag */
  static const int32_t DFSDM_DFSDMx_JCHGR_JCHG_POS       = 0;    /** @brief Injected channel group selection */
  static const int32_t DFSDM_DFSDMx_FCR_IOSR_POS         = 0;    /** @brief Integrator oversampling ratio (averaging length) */
  static const int32_t DFSDM_DFSDMx_FCR_FOSR_POS         = 16;   /** @brief Sinc filter oversampling ratio (decimation rate) */
  static const int32_t DFSDM_DFSDMx_FCR_FORD_POS         = 29;   /** @brief Sinc filter order */
  static const int32_t DFSDM_DFSDMx_JDATAR_JDATACH_POS   = 0;    /** @brief Injected channel most recently converted */
  static const int32_t DFSDM_DFSDMx_JDATAR_JDATA_POS     = 8;    /** @brief Injected group conversion data */
  static const int32_t DFSDM_DFSDMx_RDATAR_RDATACH_POS   = 0;    /** @brief Regular channel most recently converted */
  static const int32_t DFSDM_DFSDMx_RDATAR_RPEND_POS     = 4;    /** @brief Regular channel pending data */
  static const int32_t DFSDM_DFSDMx_RDATAR_RDATA_POS     = 8;    /** @brief Regular channel conversion data */
  static const int32_t DFSDM_DFSDMx_AWHTR_BKAWH_POS      = 0;    /** @brief Break signal assignment to analog watchdog high threshold event */
  static const int32_t DFSDM_DFSDMx_AWHTR_AWHT_POS       = 8;    /** @brief Analog watchdog high threshold */
  static const int32_t DFSDM_DFSDMx_AWLTR_BKAWL_POS      = 0;    /** @brief Break signal assignment to analog watchdog low threshold event */
  static const int32_t DFSDM_DFSDMx_AWLTR_AWLT_POS       = 8;    /** @brief Analog watchdog low threshold */
  static const int32_t DFSDM_DFSDMx_AWSR_AWLTF_POS       = 0;    /** @brief Analog watchdog low threshold flag */
  static const int32_t DFSDM_DFSDMx_AWSR_AWHTF_POS       = 8;    /** @brief Analog watchdog high threshold flag */
  static const int32_t DFSDM_DFSDMx_AWCFR_CLRAWLTF_POS   = 0;    /** @brief Clear the analog watchdog low threshold flag */
  static const int32_t DFSDM_DFSDMx_AWCFR_CLRAWHTF_POS   = 8;    /** @brief Clear the analog watchdog high threshold flag */
  static const int32_t DFSDM_DFSDMx_EXMAX_EXMAXCH_POS    = 0;    /** @brief Extremes detector maximum data channel */
  static const int32_t DFSDM_DFSDMx_EXMAX_EXMAX_POS      = 8;    /** @brief Extremes detector maximum value */
  static const int32_t DFSDM_DFSDMx_EXMIN_EXMINCH_POS    = 0;    /** @brief Extremes detector minimum data channel */
  static const int32_t DFSDM_DFSDMx_EXMIN_EXMIN_POS      = 8;    /** @brief Extremes detector minimum value */
  static const int32_t DFSDM_DFSDMx_CNVTIMR_CNVCNT_POS   = 4;    /** @brief 28-bit timer counting conversion time */

  /**** @subsection Enumerated DFSDM Register Field Positions ****/

  static const int32_t DFSDM_DFSDM_CHDATINxR_INDATx_POS[2] = {
    [0] = 0,    /** @brief Input data for channel 0 */
    [1] = 16,   /** @brief Input data for channel 1 */
  };

  /**********************************************************************************************
   * @section G2_TIM1x Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated G2_TIM1x Register Pointers ****/

  static RW_ uint32_t* const G2_TIM1x_CRx_PTR[8][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40014400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40014404U,   /** @brief Control register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40014800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40014804U,   /** @brief Control register 2 */
    },
  };

  static RW_ uint32_t* const G2_TIM1x_DIER_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x4001440CU,   /** @brief DMA/Interrupt enable register */
    [7] = (RW_ uint32_t* const)0x4001480CU,   /** @brief DMA/Interrupt enable register */
  };

  static RW_ uint32_t* const G2_TIM1x_SR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014410U,   /** @brief Status register */
    [7] = (RW_ uint32_t* const)0x40014810U,   /** @brief Status register */
  };

  static WO_ uint32_t* const G2_TIM1x_EGR_PTR[8] = {
    [6] = (WO_ uint32_t* const)0x40014414U,   /** @brief Event generation register */
    [7] = (WO_ uint32_t* const)0x40014814U,   /** @brief Event generation register */
  };

  static RW_ uint32_t* const G2_TIM1x_CCMR1_OUTPUT_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014418U,   /** @brief Capture/compare mode register (output mode) */
    [7] = (RW_ uint32_t* const)0x40014818U,   /** @brief Capture/compare mode register (output mode) */
  };

  static RW_ uint32_t* const G2_TIM1x_CCMR1_INPUT_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014418U,   /** @brief Capture/compare mode register (output mode) */
    [7] = (RW_ uint32_t* const)0x40014818U,   /** @brief Capture/compare mode register (output mode) */
  };

  static RW_ uint32_t* const G2_TIM1x_CCER_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014420U,   /** @brief Capture/compare enable register */
    [7] = (RW_ uint32_t* const)0x40014820U,   /** @brief Capture/compare enable register */
  };

  static RW_ uint32_t* const G2_TIM1x_CNT_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014424U,   /** @brief Counter */
    [7] = (RW_ uint32_t* const)0x40014824U,   /** @brief Counter */
  };

  static RW_ uint32_t* const G2_TIM1x_PSC_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014428U,   /** @brief Prescaler */
    [7] = (RW_ uint32_t* const)0x40014828U,   /** @brief Prescaler */
  };

  static RW_ uint32_t* const G2_TIM1x_ARR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x4001442CU,   /** @brief Auto-reload register */
    [7] = (RW_ uint32_t* const)0x4001482CU,   /** @brief Auto-reload register */
  };

  static RW_ uint32_t* const G2_TIM1x_RCR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014430U,   /** @brief Repetition counter register */
    [7] = (RW_ uint32_t* const)0x40014830U,   /** @brief Repetition counter register */
  };

  static RW_ uint32_t* const G2_TIM1x_CCR1_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014434U,   /** @brief Capture/compare register 1 */
    [7] = (RW_ uint32_t* const)0x40014834U,   /** @brief Capture/compare register 1 */
  };

  static RW_ uint32_t* const G2_TIM1x_BDTR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014444U,   /** @brief Break and dead-time register */
    [7] = (RW_ uint32_t* const)0x40014844U,   /** @brief Break and dead-time register */
  };

  static RW_ uint32_t* const G2_TIM1x_DCR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014448U,   /** @brief DMA control register */
    [7] = (RW_ uint32_t* const)0x40014848U,   /** @brief DMA control register */
  };

  static RW_ uint32_t* const G2_TIM1x_DMAR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x4001444CU,   /** @brief DMA address for full transfer */
    [7] = (RW_ uint32_t* const)0x4001484CU,   /** @brief DMA address for full transfer */
  };

  static RW_ uint32_t* const G2_TIM1x_TIM16_AF1_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014460U,   /** @brief TIM16 alternate function register 1 */
    [7] = (RW_ uint32_t* const)0x40014860U,   /** @brief TIM17 alternate function register 1 */
  };

  static RW_ uint32_t* const G2_TIM1x_TIM16_TISEL_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40014468U,   /** @brief TIM16 input selection register */
    [7] = (RW_ uint32_t* const)0x40014868U,   /** @brief TIM17 input selection register */
  };

  /**** @subsection G2_TIM1x Register Field Masks ****/

  static const uint32_t G2_TIM1x_CRx_CEN_MSK             = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t G2_TIM1x_CRx_UDIS_MSK            = 0x00000002U;   /** @brief Update disable */
  static const uint32_t G2_TIM1x_CRx_URS_MSK             = 0x00000004U;   /** @brief Update request source */
  static const uint32_t G2_TIM1x_CRx_OPM_MSK             = 0x00000008U;   /** @brief One-pulse mode */
  static const uint32_t G2_TIM1x_CRx_ARPE_MSK            = 0x00000080U;   /** @brief Auto-reload preload enable */
  static const uint32_t G2_TIM1x_CRx_CKD_MSK             = 0x00000300U;   /** @brief Clock division */
  static const uint32_t G2_TIM1x_CRx_UIFREMAP_MSK        = 0x00000800U;   /** @brief UIF status bit remapping */
  static const uint32_t G2_TIM1x_DIER_UIE_MSK            = 0x00000001U;   /** @brief Update interrupt enable */
  static const uint32_t G2_TIM1x_DIER_CC1IE_MSK          = 0x00000002U;   /** @brief Capture/Compare 1 interrupt enable */
  static const uint32_t G2_TIM1x_DIER_COMIE_MSK          = 0x00000020U;   /** @brief COM interrupt enable */
  static const uint32_t G2_TIM1x_DIER_BIE_MSK            = 0x00000080U;   /** @brief Break interrupt enable */
  static const uint32_t G2_TIM1x_DIER_UDE_MSK            = 0x00000100U;   /** @brief Update DMA request enable */
  static const uint32_t G2_TIM1x_DIER_CC1DE_MSK          = 0x00000200U;   /** @brief Capture/Compare 1 DMA request enable */
  static const uint32_t G2_TIM1x_DIER_COMDE_MSK          = 0x00002000U;   /** @brief COM DMA request enable */
  static const uint32_t G2_TIM1x_SR_CC1OF_MSK            = 0x00000200U;   /** @brief Capture/Compare 1 overcapture flag */
  static const uint32_t G2_TIM1x_SR_BIF_MSK              = 0x00000080U;   /** @brief Break interrupt flag */
  static const uint32_t G2_TIM1x_SR_COMIF_MSK            = 0x00000020U;   /** @brief COM interrupt flag */
  static const uint32_t G2_TIM1x_SR_CC1IF_MSK            = 0x00000002U;   /** @brief Capture/compare 1 interrupt flag */
  static const uint32_t G2_TIM1x_SR_UIF_MSK              = 0x00000001U;   /** @brief Update interrupt flag */
  static const uint32_t G2_TIM1x_EGR_BG_MSK              = 0x00000080U;   /** @brief Break generation */
  static const uint32_t G2_TIM1x_EGR_COMG_MSK            = 0x00000020U;   /** @brief Capture/Compare control update generation */
  static const uint32_t G2_TIM1x_EGR_CC1G_MSK            = 0x00000002U;   /** @brief Capture/compare 1 generation */
  static const uint32_t G2_TIM1x_EGR_UG_MSK              = 0x00000001U;   /** @brief Update generation */
  static const uint32_t G2_TIM1x_CCMR1_OUTPUT_CC1S_MSK   = 0x00000003U;   /** @brief Capture/Compare 1 selection */
  static const uint32_t G2_TIM1x_CCMR1_OUTPUT_OC1FE_MSK  = 0x00000004U;   /** @brief Output compare 1 fast enable */
  static const uint32_t G2_TIM1x_CCMR1_OUTPUT_OC1PE_MSK  = 0x00000008U;   /** @brief Output compare 1 preload enable */
  static const uint32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_MSK   = 0x00000070U;   /** @brief Output compare 1 mode */
  static const uint32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_3_MSK = 0x00010000U;   /** @brief Output compare 1 mode */
  static const uint32_t G2_TIM1x_CCMR1_INPUT_IC1F_MSK    = 0x000000F0U;   /** @brief Input capture 1 filter */
  static const uint32_t G2_TIM1x_CCMR1_INPUT_IC1PSC_MSK  = 0x0000000CU;   /** @brief Input capture 1 prescaler */
  static const uint32_t G2_TIM1x_CCMR1_INPUT_CC1S_MSK    = 0x00000003U;   /** @brief Capture/Compare 1 selection */
  static const uint32_t G2_TIM1x_CCER_CC1NP_MSK          = 0x00000008U;   /** @brief Capture/Compare 1 output polarity */
  static const uint32_t G2_TIM1x_CCER_CC1NE_MSK          = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
  static const uint32_t G2_TIM1x_CCER_CC1P_MSK           = 0x00000002U;   /** @brief Capture/Compare 1 output polarity */
  static const uint32_t G2_TIM1x_CCER_CC1E_MSK           = 0x00000001U;   /** @brief Capture/Compare 1 output enable */
  static const uint32_t G2_TIM1x_CNT_CNT_MSK             = 0x0000FFFFU;   /** @brief Counter value */
  static const uint32_t G2_TIM1x_CNT_UIFCPY_MSK          = 0x80000000U;   /** @brief UIF copy */
  static const uint32_t G2_TIM1x_PSC_PSC_MSK             = 0x0000FFFFU;   /** @brief Prescaler value */
  static const uint32_t G2_TIM1x_ARR_ARR_MSK             = 0x0000FFFFU;   /** @brief Auto-reload value */
  static const uint32_t G2_TIM1x_RCR_REP_MSK             = 0x000000FFU;   /** @brief Repetition counter value */
  static const uint32_t G2_TIM1x_CCR1_CCR1_MSK           = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
  static const uint32_t G2_TIM1x_BDTR_DTG_MSK            = 0x000000FFU;   /** @brief Dead-time generator setup */
  static const uint32_t G2_TIM1x_BDTR_LOCK_MSK           = 0x00000300U;   /** @brief Lock configuration */
  static const uint32_t G2_TIM1x_BDTR_OSSI_MSK           = 0x00000400U;   /** @brief Off-state selection for idle mode */
  static const uint32_t G2_TIM1x_BDTR_OSSR_MSK           = 0x00000800U;   /** @brief Off-state selection for run mode */
  static const uint32_t G2_TIM1x_BDTR_BKE_MSK            = 0x00001000U;   /** @brief Break enable */
  static const uint32_t G2_TIM1x_BDTR_BKP_MSK            = 0x00002000U;   /** @brief Break polarity */
  static const uint32_t G2_TIM1x_BDTR_AOE_MSK            = 0x00004000U;   /** @brief Automatic output enable */
  static const uint32_t G2_TIM1x_BDTR_MOE_MSK            = 0x00008000U;   /** @brief Main output enable */
  static const uint32_t G2_TIM1x_BDTR_BKF_MSK            = 0x000F0000U;   /** @brief Break filter */
  static const uint32_t G2_TIM1x_DCR_DBL_MSK             = 0x00001F00U;   /** @brief DMA burst length */
  static const uint32_t G2_TIM1x_DCR_DBA_MSK             = 0x0000001FU;   /** @brief DMA base address */
  static const uint32_t G2_TIM1x_DMAR_DMAB_MSK           = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
  static const uint32_t G2_TIM1x_TIM16_AF1_BKINE_MSK     = 0x00000001U;   /** @brief BRK BKIN input enable */
  static const uint32_t G2_TIM1x_TIM16_AF1_BKDFBK1E_MSK  = 0x00000100U;   /** @brief BRK dfsdm1_break[1] enable */
  static const uint32_t G2_TIM1x_TIM16_AF1_BKINP_MSK     = 0x00000200U;   /** @brief BRK BKIN input polarity */
  static const uint32_t G2_TIM1x_TIM16_TISEL_TI1SEL_MSK  = 0x0000000FU;   /** @brief Selects TI1[0] to TI1[15] input */

  /**** @subsection Enumerated G2_TIM1x Register Field Masks ****/

  static const uint32_t G2_TIM1x_TIM16_AF1_BKCMPxE_MSK[3] = {
    [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
    [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
  };

  static const uint32_t G2_TIM1x_TIM16_AF1_BKCMPxP_MSK[3] = {
    [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
    [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
  };

  /**** @subsection G2_TIM1x Register Field Positions ****/

  static const int32_t G2_TIM1x_CRx_CEN_POS             = 0;    /** @brief Counter enable */
  static const int32_t G2_TIM1x_CRx_UDIS_POS            = 1;    /** @brief Update disable */
  static const int32_t G2_TIM1x_CRx_URS_POS             = 2;    /** @brief Update request source */
  static const int32_t G2_TIM1x_CRx_OPM_POS             = 3;    /** @brief One-pulse mode */
  static const int32_t G2_TIM1x_CRx_ARPE_POS            = 7;    /** @brief Auto-reload preload enable */
  static const int32_t G2_TIM1x_CRx_CKD_POS             = 8;    /** @brief Clock division */
  static const int32_t G2_TIM1x_CRx_UIFREMAP_POS        = 11;   /** @brief UIF status bit remapping */
  static const int32_t G2_TIM1x_DIER_UIE_POS            = 0;    /** @brief Update interrupt enable */
  static const int32_t G2_TIM1x_DIER_CC1IE_POS          = 1;    /** @brief Capture/Compare 1 interrupt enable */
  static const int32_t G2_TIM1x_DIER_COMIE_POS          = 5;    /** @brief COM interrupt enable */
  static const int32_t G2_TIM1x_DIER_BIE_POS            = 7;    /** @brief Break interrupt enable */
  static const int32_t G2_TIM1x_DIER_UDE_POS            = 8;    /** @brief Update DMA request enable */
  static const int32_t G2_TIM1x_DIER_CC1DE_POS          = 9;    /** @brief Capture/Compare 1 DMA request enable */
  static const int32_t G2_TIM1x_DIER_COMDE_POS          = 13;   /** @brief COM DMA request enable */
  static const int32_t G2_TIM1x_SR_CC1OF_POS            = 9;    /** @brief Capture/Compare 1 overcapture flag */
  static const int32_t G2_TIM1x_SR_BIF_POS              = 7;    /** @brief Break interrupt flag */
  static const int32_t G2_TIM1x_SR_COMIF_POS            = 5;    /** @brief COM interrupt flag */
  static const int32_t G2_TIM1x_SR_CC1IF_POS            = 1;    /** @brief Capture/compare 1 interrupt flag */
  static const int32_t G2_TIM1x_SR_UIF_POS              = 0;    /** @brief Update interrupt flag */
  static const int32_t G2_TIM1x_EGR_BG_POS              = 7;    /** @brief Break generation */
  static const int32_t G2_TIM1x_EGR_COMG_POS            = 5;    /** @brief Capture/Compare control update generation */
  static const int32_t G2_TIM1x_EGR_CC1G_POS            = 1;    /** @brief Capture/compare 1 generation */
  static const int32_t G2_TIM1x_EGR_UG_POS              = 0;    /** @brief Update generation */
  static const int32_t G2_TIM1x_CCMR1_OUTPUT_CC1S_POS   = 0;    /** @brief Capture/Compare 1 selection */
  static const int32_t G2_TIM1x_CCMR1_OUTPUT_OC1FE_POS  = 2;    /** @brief Output compare 1 fast enable */
  static const int32_t G2_TIM1x_CCMR1_OUTPUT_OC1PE_POS  = 3;    /** @brief Output compare 1 preload enable */
  static const int32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_POS   = 4;    /** @brief Output compare 1 mode */
  static const int32_t G2_TIM1x_CCMR1_OUTPUT_OC1M_3_POS = 16;   /** @brief Output compare 1 mode */
  static const int32_t G2_TIM1x_CCMR1_INPUT_IC1F_POS    = 4;    /** @brief Input capture 1 filter */
  static const int32_t G2_TIM1x_CCMR1_INPUT_IC1PSC_POS  = 2;    /** @brief Input capture 1 prescaler */
  static const int32_t G2_TIM1x_CCMR1_INPUT_CC1S_POS    = 0;    /** @brief Capture/Compare 1 selection */
  static const int32_t G2_TIM1x_CCER_CC1NP_POS          = 3;    /** @brief Capture/Compare 1 output polarity */
  static const int32_t G2_TIM1x_CCER_CC1NE_POS          = 2;    /** @brief Capture/Compare 1 complementary output enable */
  static const int32_t G2_TIM1x_CCER_CC1P_POS           = 1;    /** @brief Capture/Compare 1 output polarity */
  static const int32_t G2_TIM1x_CCER_CC1E_POS           = 0;    /** @brief Capture/Compare 1 output enable */
  static const int32_t G2_TIM1x_CNT_CNT_POS             = 0;    /** @brief Counter value */
  static const int32_t G2_TIM1x_CNT_UIFCPY_POS          = 31;   /** @brief UIF copy */
  static const int32_t G2_TIM1x_PSC_PSC_POS             = 0;    /** @brief Prescaler value */
  static const int32_t G2_TIM1x_ARR_ARR_POS             = 0;    /** @brief Auto-reload value */
  static const int32_t G2_TIM1x_RCR_REP_POS             = 0;    /** @brief Repetition counter value */
  static const int32_t G2_TIM1x_CCR1_CCR1_POS           = 0;    /** @brief Capture/Compare 1 value */
  static const int32_t G2_TIM1x_BDTR_DTG_POS            = 0;    /** @brief Dead-time generator setup */
  static const int32_t G2_TIM1x_BDTR_LOCK_POS           = 8;    /** @brief Lock configuration */
  static const int32_t G2_TIM1x_BDTR_OSSI_POS           = 10;   /** @brief Off-state selection for idle mode */
  static const int32_t G2_TIM1x_BDTR_OSSR_POS           = 11;   /** @brief Off-state selection for run mode */
  static const int32_t G2_TIM1x_BDTR_BKE_POS            = 12;   /** @brief Break enable */
  static const int32_t G2_TIM1x_BDTR_BKP_POS            = 13;   /** @brief Break polarity */
  static const int32_t G2_TIM1x_BDTR_AOE_POS            = 14;   /** @brief Automatic output enable */
  static const int32_t G2_TIM1x_BDTR_MOE_POS            = 15;   /** @brief Main output enable */
  static const int32_t G2_TIM1x_BDTR_BKF_POS            = 16;   /** @brief Break filter */
  static const int32_t G2_TIM1x_DCR_DBL_POS             = 8;    /** @brief DMA burst length */
  static const int32_t G2_TIM1x_DCR_DBA_POS             = 0;    /** @brief DMA base address */
  static const int32_t G2_TIM1x_DMAR_DMAB_POS           = 0;    /** @brief DMA register for burst accesses */
  static const int32_t G2_TIM1x_TIM16_AF1_BKINE_POS     = 0;    /** @brief BRK BKIN input enable */
  static const int32_t G2_TIM1x_TIM16_AF1_BKDFBK1E_POS  = 8;    /** @brief BRK dfsdm1_break[1] enable */
  static const int32_t G2_TIM1x_TIM16_AF1_BKINP_POS     = 9;    /** @brief BRK BKIN input polarity */
  static const int32_t G2_TIM1x_TIM16_TISEL_TI1SEL_POS  = 0;    /** @brief Selects TI1[0] to TI1[15] input */

  /**** @subsection Enumerated G2_TIM1x Register Field Positions ****/

  static const int32_t G2_TIM1x_TIM16_AF1_BKCMPxE_POS[3] = {
    [1] = 1,   /** @brief BRK COMP1 enable */
    [2] = 2,   /** @brief BRK COMP2 enable */
  };

  static const int32_t G2_TIM1x_TIM16_AF1_BKCMPxP_POS[3] = {
    [1] = 10,   /** @brief BRK COMP1 input polarity */
    [2] = 11,   /** @brief BRK COMP2 input polarity */
  };

  /**********************************************************************************************
   * @section TIM15 Register Information
   **********************************************************************************************/

  /**** @subsection TIM15 Register Pointers ****/

  static RW_ uint32_t* const TIM15_SMCR_PTR         = (RW_ uint32_t* const)0x40014008U;   /** @brief Slave mode control register */
  static RW_ uint32_t* const TIM15_DIER_PTR         = (RW_ uint32_t* const)0x4001400CU;   /** @brief DMA/Interrupt enable register */
  static RW_ uint32_t* const TIM15_SR_PTR           = (RW_ uint32_t* const)0x40014010U;   /** @brief Status register */
  static WO_ uint32_t* const TIM15_EGR_PTR          = (WO_ uint32_t* const)0x40014014U;   /** @brief Event generation register */
  static RW_ uint32_t* const TIM15_CCMR1_OUTPUT_PTR = (RW_ uint32_t* const)0x40014018U;   /** @brief Capture/compare mode register (output mode) */
  static RW_ uint32_t* const TIM15_CCMR1_INPUT_PTR  = (RW_ uint32_t* const)0x40014018U;   /** @brief Capture/compare mode register 1 (input mode) */
  static RW_ uint32_t* const TIM15_CCER_PTR         = (RW_ uint32_t* const)0x40014020U;   /** @brief Capture/compare enable register */
  static RW_ uint32_t* const TIM15_CNT_PTR          = (RW_ uint32_t* const)0x40014024U;   /** @brief Counter */
  static RW_ uint32_t* const TIM15_PSC_PTR          = (RW_ uint32_t* const)0x40014028U;   /** @brief Prescaler */
  static RW_ uint32_t* const TIM15_ARR_PTR          = (RW_ uint32_t* const)0x4001402CU;   /** @brief Auto-reload register */
  static RW_ uint32_t* const TIM15_RCR_PTR          = (RW_ uint32_t* const)0x40014030U;   /** @brief Repetition counter register */
  static RW_ uint32_t* const TIM15_BDTR_PTR         = (RW_ uint32_t* const)0x40014044U;   /** @brief Break and dead-time register */
  static RW_ uint32_t* const TIM15_DCR_PTR          = (RW_ uint32_t* const)0x40014048U;   /** @brief DMA control register */
  static RW_ uint32_t* const TIM15_DMAR_PTR         = (RW_ uint32_t* const)0x4001404CU;   /** @brief DMA address for full transfer */
  static RW_ uint32_t* const TIM15_AF1_PTR          = (RW_ uint32_t* const)0x40014060U;   /** @brief TIM15 alternate fdfsdm1_breakon register 1 */
  static RW_ uint32_t* const TIM15_TISEL_PTR        = (RW_ uint32_t* const)0x40014068U;   /** @brief TIM15 input selection register */

  /**** @subsection Enumerated TIM15 Register Pointers ****/

  static RW_ uint32_t* const TIM15_CRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40014000U,   /** @brief Control register 1 */
    [2] = (RW_ uint32_t* const)0x40014004U,   /** @brief Control register 2 */
  };

  static RW_ uint32_t* const TIM15_CCRx_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40014034U,   /** @brief Capture/compare register 1 */
    [2] = (RW_ uint32_t* const)0x40014038U,   /** @brief Capture/compare register 2 */
  };

  /**** @subsection TIM15 Register Field Masks ****/

  static const uint32_t TIM15_CRx_CEN_MSK       = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t TIM15_CRx_UDIS_MSK      = 0x00000002U;   /** @brief Update disable */
  static const uint32_t TIM15_CRx_URS_MSK       = 0x00000004U;   /** @brief Update request source */
  static const uint32_t TIM15_CRx_OPM_MSK       = 0x00000008U;   /** @brief One-pulse mode */
  static const uint32_t TIM15_CRx_ARPE_MSK      = 0x00000080U;   /** @brief Auto-reload preload enable */
  static const uint32_t TIM15_CRx_CKD_MSK       = 0x00000300U;   /** @brief Clock division */
  static const uint32_t TIM15_CRx_UIFREMAP_MSK  = 0x00000800U;   /** @brief UIF status bit remapping */
  static const uint32_t TIM15_SMCR_SMS_MSK      = 0x00000007U;   /** @brief Slave mode selection */
  static const uint32_t TIM15_SMCR_TS_2_0_MSK   = 0x00000070U;   /** @brief Trigger selection */
  static const uint32_t TIM15_SMCR_MSM_MSK      = 0x00000080U;   /** @brief Master/Slave mode */
  static const uint32_t TIM15_SMCR_SMS_3_MSK    = 0x00010000U;   /** @brief Slave mode selection bit 3 */
  static const uint32_t TIM15_SMCR_TS_4_3_MSK   = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
  static const uint32_t TIM15_DIER_UIE_MSK      = 0x00000001U;   /** @brief Update interrupt enable */
  static const uint32_t TIM15_DIER_COMIE_MSK    = 0x00000020U;   /** @brief COM interrupt enable */
  static const uint32_t TIM15_DIER_TIE_MSK      = 0x00000040U;   /** @brief Trigger interrupt enable */
  static const uint32_t TIM15_DIER_BIE_MSK      = 0x00000080U;   /** @brief Break interrupt enable */
  static const uint32_t TIM15_DIER_UDE_MSK      = 0x00000100U;   /** @brief Update DMA request enable */
  static const uint32_t TIM15_DIER_COMDE_MSK    = 0x00002000U;   /** @brief COM DMA request enable */
  static const uint32_t TIM15_DIER_TDE_MSK      = 0x00004000U;   /** @brief Trigger DMA request enable */
  static const uint32_t TIM15_SR_BIF_MSK        = 0x00000080U;   /** @brief Break interrupt flag */
  static const uint32_t TIM15_SR_TIF_MSK        = 0x00000040U;   /** @brief Trigger interrupt flag */
  static const uint32_t TIM15_SR_COMIF_MSK      = 0x00000020U;   /** @brief COM interrupt flag */
  static const uint32_t TIM15_SR_UIF_MSK        = 0x00000001U;   /** @brief Update interrupt flag */
  static const uint32_t TIM15_EGR_BG_MSK        = 0x00000080U;   /** @brief Break generation */
  static const uint32_t TIM15_EGR_TG_MSK        = 0x00000040U;   /** @brief Trigger generation */
  static const uint32_t TIM15_EGR_COMG_MSK      = 0x00000020U;   /** @brief Capture/Compare control update generation */
  static const uint32_t TIM15_EGR_UG_MSK        = 0x00000001U;   /** @brief Update generation */
  static const uint32_t TIM15_CCER_CC1NE_MSK    = 0x00000004U;   /** @brief Capture/Compare 1 complementary output enable */
  static const uint32_t TIM15_CNT_CNT_MSK       = 0x0000FFFFU;   /** @brief Counter value */
  static const uint32_t TIM15_CNT_UIFCPY_MSK    = 0x80000000U;   /** @brief UIF copy */
  static const uint32_t TIM15_PSC_PSC_MSK       = 0x0000FFFFU;   /** @brief Prescaler value */
  static const uint32_t TIM15_ARR_ARR_MSK       = 0x0000FFFFU;   /** @brief Auto-reload value */
  static const uint32_t TIM15_RCR_REP_MSK       = 0x000000FFU;   /** @brief Repetition counter value */
  static const uint32_t TIM15_CCRx_CCR1_MSK     = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
  static const uint32_t TIM15_BDTR_MOE_MSK      = 0x00008000U;   /** @brief Main output enable */
  static const uint32_t TIM15_BDTR_AOE_MSK      = 0x00004000U;   /** @brief Automatic output enable */
  static const uint32_t TIM15_BDTR_BKP_MSK      = 0x00002000U;   /** @brief Break polarity */
  static const uint32_t TIM15_BDTR_BKE_MSK      = 0x00001000U;   /** @brief Break enable */
  static const uint32_t TIM15_BDTR_OSSR_MSK     = 0x00000800U;   /** @brief Off-state selection for run mode */
  static const uint32_t TIM15_BDTR_OSSI_MSK     = 0x00000400U;   /** @brief Off-state selection for idle mode */
  static const uint32_t TIM15_BDTR_LOCK_MSK     = 0x00000300U;   /** @brief Lock configuration */
  static const uint32_t TIM15_BDTR_DTG_MSK      = 0x000000FFU;   /** @brief Dead-time generator setup */
  static const uint32_t TIM15_BDTR_BKF_MSK      = 0x000F0000U;   /** @brief Break filter */
  static const uint32_t TIM15_DCR_DBL_MSK       = 0x00001F00U;   /** @brief DMA burst length */
  static const uint32_t TIM15_DCR_DBA_MSK       = 0x0000001FU;   /** @brief DMA base address */
  static const uint32_t TIM15_DMAR_DMAB_MSK     = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
  static const uint32_t TIM15_AF1_BKINE_MSK     = 0x00000001U;   /** @brief BRK BKIN input enable */
  static const uint32_t TIM15_AF1_BKDF1BK0E_MSK = 0x00000100U;   /** @brief BRK dfsdm1_break[0] enable */
  static const uint32_t TIM15_AF1_BKINP_MSK     = 0x00000200U;   /** @brief BRK BKIN input polarity */

  /**** @subsection Enumerated TIM15 Register Field Masks ****/

  static const uint32_t TIM15_DIER_CCxIE_MSK[3] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
  };

  static const uint32_t TIM15_DIER_CCxDE_MSK[3] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
    [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
  };

  static const uint32_t TIM15_SR_CCxOF_MSK[3] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
    [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
  };

  static const uint32_t TIM15_SR_CCxIF_MSK[3] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
  };

  static const uint32_t TIM15_EGR_CCxG_MSK[3] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
    [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
  };

  static const uint32_t TIM15_CCMR1_OUTPUT_CCxS_MSK[3] = {
    [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
    [2] = 0x00000300U,   /** @brief Capture/Compare 2 selection */
  };

  static const uint32_t TIM15_CCMR1_OUTPUT_OCxFE_MSK[3] = {
    [1] = 0x00000004U,   /** @brief Output compare 1 fast enable */
    [2] = 0x00000400U,   /** @brief Output compare 2 fast enable */
  };

  static const uint32_t TIM15_CCMR1_OUTPUT_OCxPE_MSK[3] = {
    [1] = 0x00000008U,   /** @brief Output compare 1 preload enable */
    [2] = 0x00000800U,   /** @brief Output compare 2 preload enable */
  };

  static const uint32_t TIM15_CCMR1_OUTPUT_OCxM_MSK[3] = {
    [1] = 0x00000070U,   /** @brief Output compare 1 mode */
    [2] = 0x00007000U,   /** @brief Output compare 2 mode */
  };

  static const uint32_t TIM15_CCMR1_OUTPUT_OCxM_3_MSK[3] = {
    [1] = 0x00010000U,   /** @brief Output compare 1 mode bit 3 */
    [2] = 0x01000000U,   /** @brief Output compare 2 mode bit 3 */
  };

  static const uint32_t TIM15_CCMR1_INPUT_ICxF_MSK[3] = {
    [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
    [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
  };

  static const uint32_t TIM15_CCMR1_INPUT_ICxPSC_MSK[3] = {
    [1] = 0x0000000CU,   /** @brief Input capture 1 prescaler */
    [2] = 0x00000C00U,   /** @brief Input capture 2 prescaler */
  };

  static const uint32_t TIM15_CCER_CCxNP_MSK[3] = {
    [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
  };

  static const uint32_t TIM15_CCER_CCxP_MSK[3] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
  };

  static const uint32_t TIM15_CCER_CCxE_MSK[3] = {
    [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
    [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
  };

  static const uint32_t TIM15_AF1_BKCMPxE_MSK[3] = {
    [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
    [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
  };

  static const uint32_t TIM15_AF1_BKCMPxP_MSK[3] = {
    [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
    [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
  };

  static const uint32_t TIM15_TISEL_TIxSEL_MSK[3] = {
    [1] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
    [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
  };

  /**** @subsection TIM15 Register Field Positions ****/

  static const int32_t TIM15_CRx_CEN_POS       = 0;    /** @brief Counter enable */
  static const int32_t TIM15_CRx_UDIS_POS      = 1;    /** @brief Update disable */
  static const int32_t TIM15_CRx_URS_POS       = 2;    /** @brief Update request source */
  static const int32_t TIM15_CRx_OPM_POS       = 3;    /** @brief One-pulse mode */
  static const int32_t TIM15_CRx_ARPE_POS      = 7;    /** @brief Auto-reload preload enable */
  static const int32_t TIM15_CRx_CKD_POS       = 8;    /** @brief Clock division */
  static const int32_t TIM15_CRx_UIFREMAP_POS  = 11;   /** @brief UIF status bit remapping */
  static const int32_t TIM15_SMCR_SMS_POS      = 0;    /** @brief Slave mode selection */
  static const int32_t TIM15_SMCR_TS_2_0_POS   = 4;    /** @brief Trigger selection */
  static const int32_t TIM15_SMCR_MSM_POS      = 7;    /** @brief Master/Slave mode */
  static const int32_t TIM15_SMCR_SMS_3_POS    = 16;   /** @brief Slave mode selection bit 3 */
  static const int32_t TIM15_SMCR_TS_4_3_POS   = 20;   /** @brief Trigger selection - bit 4:3 */
  static const int32_t TIM15_DIER_UIE_POS      = 0;    /** @brief Update interrupt enable */
  static const int32_t TIM15_DIER_COMIE_POS    = 5;    /** @brief COM interrupt enable */
  static const int32_t TIM15_DIER_TIE_POS      = 6;    /** @brief Trigger interrupt enable */
  static const int32_t TIM15_DIER_BIE_POS      = 7;    /** @brief Break interrupt enable */
  static const int32_t TIM15_DIER_UDE_POS      = 8;    /** @brief Update DMA request enable */
  static const int32_t TIM15_DIER_COMDE_POS    = 13;   /** @brief COM DMA request enable */
  static const int32_t TIM15_DIER_TDE_POS      = 14;   /** @brief Trigger DMA request enable */
  static const int32_t TIM15_SR_BIF_POS        = 7;    /** @brief Break interrupt flag */
  static const int32_t TIM15_SR_TIF_POS        = 6;    /** @brief Trigger interrupt flag */
  static const int32_t TIM15_SR_COMIF_POS      = 5;    /** @brief COM interrupt flag */
  static const int32_t TIM15_SR_UIF_POS        = 0;    /** @brief Update interrupt flag */
  static const int32_t TIM15_EGR_BG_POS        = 7;    /** @brief Break generation */
  static const int32_t TIM15_EGR_TG_POS        = 6;    /** @brief Trigger generation */
  static const int32_t TIM15_EGR_COMG_POS      = 5;    /** @brief Capture/Compare control update generation */
  static const int32_t TIM15_EGR_UG_POS        = 0;    /** @brief Update generation */
  static const int32_t TIM15_CCER_CC1NE_POS    = 2;    /** @brief Capture/Compare 1 complementary output enable */
  static const int32_t TIM15_CNT_CNT_POS       = 0;    /** @brief Counter value */
  static const int32_t TIM15_CNT_UIFCPY_POS    = 31;   /** @brief UIF copy */
  static const int32_t TIM15_PSC_PSC_POS       = 0;    /** @brief Prescaler value */
  static const int32_t TIM15_ARR_ARR_POS       = 0;    /** @brief Auto-reload value */
  static const int32_t TIM15_RCR_REP_POS       = 0;    /** @brief Repetition counter value */
  static const int32_t TIM15_CCRx_CCR1_POS     = 0;    /** @brief Capture/Compare 1 value */
  static const int32_t TIM15_BDTR_MOE_POS      = 15;   /** @brief Main output enable */
  static const int32_t TIM15_BDTR_AOE_POS      = 14;   /** @brief Automatic output enable */
  static const int32_t TIM15_BDTR_BKP_POS      = 13;   /** @brief Break polarity */
  static const int32_t TIM15_BDTR_BKE_POS      = 12;   /** @brief Break enable */
  static const int32_t TIM15_BDTR_OSSR_POS     = 11;   /** @brief Off-state selection for run mode */
  static const int32_t TIM15_BDTR_OSSI_POS     = 10;   /** @brief Off-state selection for idle mode */
  static const int32_t TIM15_BDTR_LOCK_POS     = 8;    /** @brief Lock configuration */
  static const int32_t TIM15_BDTR_DTG_POS      = 0;    /** @brief Dead-time generator setup */
  static const int32_t TIM15_BDTR_BKF_POS      = 16;   /** @brief Break filter */
  static const int32_t TIM15_DCR_DBL_POS       = 8;    /** @brief DMA burst length */
  static const int32_t TIM15_DCR_DBA_POS       = 0;    /** @brief DMA base address */
  static const int32_t TIM15_DMAR_DMAB_POS     = 0;    /** @brief DMA register for burst accesses */
  static const int32_t TIM15_AF1_BKINE_POS     = 0;    /** @brief BRK BKIN input enable */
  static const int32_t TIM15_AF1_BKDF1BK0E_POS = 8;    /** @brief BRK dfsdm1_break[0] enable */
  static const int32_t TIM15_AF1_BKINP_POS     = 9;    /** @brief BRK BKIN input polarity */

  /**** @subsection Enumerated TIM15 Register Field Positions ****/

  static const int32_t TIM15_DIER_CCxIE_POS[3] = {
    [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
  };

  static const int32_t TIM15_DIER_CCxDE_POS[3] = {
    [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
    [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
  };

  static const int32_t TIM15_SR_CCxOF_POS[3] = {
    [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
    [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
  };

  static const int32_t TIM15_SR_CCxIF_POS[3] = {
    [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
    [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
  };

  static const int32_t TIM15_EGR_CCxG_POS[3] = {
    [1] = 1,   /** @brief Capture/compare 1 generation */
    [2] = 2,   /** @brief Capture/compare 2 generation */
  };

  static const int32_t TIM15_CCMR1_OUTPUT_CCxS_POS[3] = {
    [1] = 0,   /** @brief Capture/Compare 1 selection */
    [2] = 8,   /** @brief Capture/Compare 2 selection */
  };

  static const int32_t TIM15_CCMR1_OUTPUT_OCxFE_POS[3] = {
    [1] = 2,    /** @brief Output compare 1 fast enable */
    [2] = 10,   /** @brief Output compare 2 fast enable */
  };

  static const int32_t TIM15_CCMR1_OUTPUT_OCxPE_POS[3] = {
    [1] = 3,    /** @brief Output compare 1 preload enable */
    [2] = 11,   /** @brief Output compare 2 preload enable */
  };

  static const int32_t TIM15_CCMR1_OUTPUT_OCxM_POS[3] = {
    [1] = 4,    /** @brief Output compare 1 mode */
    [2] = 12,   /** @brief Output compare 2 mode */
  };

  static const int32_t TIM15_CCMR1_OUTPUT_OCxM_3_POS[3] = {
    [1] = 16,   /** @brief Output compare 1 mode bit 3 */
    [2] = 24,   /** @brief Output compare 2 mode bit 3 */
  };

  static const int32_t TIM15_CCMR1_INPUT_ICxF_POS[3] = {
    [1] = 4,    /** @brief Input capture 1 filter */
    [2] = 12,   /** @brief Input capture 2 filter */
  };

  static const int32_t TIM15_CCMR1_INPUT_ICxPSC_POS[3] = {
    [1] = 2,    /** @brief Input capture 1 prescaler */
    [2] = 10,   /** @brief Input capture 2 prescaler */
  };

  static const int32_t TIM15_CCER_CCxNP_POS[3] = {
    [1] = 3,   /** @brief Capture/Compare 1 output polarity */
    [2] = 7,   /** @brief Capture/Compare 2 output polarity */
  };

  static const int32_t TIM15_CCER_CCxP_POS[3] = {
    [1] = 1,   /** @brief Capture/Compare 1 output polarity */
    [2] = 5,   /** @brief Capture/Compare 2 output polarity */
  };

  static const int32_t TIM15_CCER_CCxE_POS[3] = {
    [1] = 0,   /** @brief Capture/Compare 1 output enable */
    [2] = 4,   /** @brief Capture/Compare 2 output enable */
  };

  static const int32_t TIM15_AF1_BKCMPxE_POS[3] = {
    [1] = 1,   /** @brief BRK COMP1 enable */
    [2] = 2,   /** @brief BRK COMP2 enable */
  };

  static const int32_t TIM15_AF1_BKCMPxP_POS[3] = {
    [1] = 10,   /** @brief BRK COMP1 input polarity */
    [2] = 11,   /** @brief BRK COMP2 input polarity */
  };

  static const int32_t TIM15_TISEL_TIxSEL_POS[3] = {
    [1] = 0,   /** @brief Selects TI1[0] to TI1[15] input */
    [2] = 8,   /** @brief Selects TI2[0] to TI2[15] input */
  };

  /**********************************************************************************************
   * @section USARTx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated USARTx Register Pointers ****/

  static RW_ uint32_t* const USARTx_CRx_PTR[7][4] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40011000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40011004U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40011008U,   /** @brief Control register 3 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40004400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40004404U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40004408U,   /** @brief Control register 3 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40004800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40004804U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40004808U,   /** @brief Control register 3 */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x40011400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40011404U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40011408U,   /** @brief Control register 3 */
    },
  };

  static RW_ uint32_t* const USARTx_BRR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x4001100CU,   /** @brief Baud rate register */
    [2] = (RW_ uint32_t* const)0x4000440CU,   /** @brief Baud rate register */
    [3] = (RW_ uint32_t* const)0x4000480CU,   /** @brief Baud rate register */
    [6] = (RW_ uint32_t* const)0x4001140CU,   /** @brief Baud rate register */
  };

  static RW_ uint32_t* const USARTx_GTPR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40011010U,   /** @brief Guard time and prescaler register */
    [2] = (RW_ uint32_t* const)0x40004410U,   /** @brief Guard time and prescaler register */
    [3] = (RW_ uint32_t* const)0x40004810U,   /** @brief Guard time and prescaler register */
    [6] = (RW_ uint32_t* const)0x40011410U,   /** @brief Guard time and prescaler register */
  };

  static RW_ uint32_t* const USARTx_RTOR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40011014U,   /** @brief Receiver timeout register */
    [2] = (RW_ uint32_t* const)0x40004414U,   /** @brief Receiver timeout register */
    [3] = (RW_ uint32_t* const)0x40004814U,   /** @brief Receiver timeout register */
    [6] = (RW_ uint32_t* const)0x40011414U,   /** @brief Receiver timeout register */
  };

  static WO_ uint32_t* const USARTx_RQR_PTR[7] = {
    [1] = (WO_ uint32_t* const)0x40011018U,   /** @brief Request register */
    [2] = (WO_ uint32_t* const)0x40004418U,   /** @brief Request register */
    [3] = (WO_ uint32_t* const)0x40004818U,   /** @brief Request register */
    [6] = (WO_ uint32_t* const)0x40011418U,   /** @brief Request register */
  };

  static RO_ uint32_t* const USARTx_ISR_PTR[7] = {
    [1] = (RO_ uint32_t* const)0x4001101CU,   /** @brief Interrupt & status register */
    [2] = (RO_ uint32_t* const)0x4000441CU,   /** @brief Interrupt & status register */
    [3] = (RO_ uint32_t* const)0x4000481CU,   /** @brief Interrupt & status register */
    [6] = (RO_ uint32_t* const)0x4001141CU,   /** @brief Interrupt & status register */
  };

  static WO_ uint32_t* const USARTx_ICR_PTR[7] = {
    [1] = (WO_ uint32_t* const)0x40011020U,   /** @brief Interrupt flag clear register */
    [2] = (WO_ uint32_t* const)0x40004420U,   /** @brief Interrupt flag clear register */
    [3] = (WO_ uint32_t* const)0x40004820U,   /** @brief Interrupt flag clear register */
    [6] = (WO_ uint32_t* const)0x40011420U,   /** @brief Interrupt flag clear register */
  };

  static RO_ uint32_t* const USARTx_RDR_PTR[7] = {
    [1] = (RO_ uint32_t* const)0x40011024U,   /** @brief Receive data register */
    [2] = (RO_ uint32_t* const)0x40004424U,   /** @brief Receive data register */
    [3] = (RO_ uint32_t* const)0x40004824U,   /** @brief Receive data register */
    [6] = (RO_ uint32_t* const)0x40011424U,   /** @brief Receive data register */
  };

  static RW_ uint32_t* const USARTx_TDR_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x40011028U,   /** @brief Transmit data register */
    [2] = (RW_ uint32_t* const)0x40004428U,   /** @brief Transmit data register */
    [3] = (RW_ uint32_t* const)0x40004828U,   /** @brief Transmit data register */
    [6] = (RW_ uint32_t* const)0x40011428U,   /** @brief Transmit data register */
  };

  static RW_ uint32_t* const USARTx_PRESC_PTR[7] = {
    [1] = (RW_ uint32_t* const)0x4001102CU,   /** @brief USART prescaler register */
    [2] = (RW_ uint32_t* const)0x4000442CU,   /** @brief USART prescaler register */
    [3] = (RW_ uint32_t* const)0x4000482CU,   /** @brief USART prescaler register */
    [6] = (RW_ uint32_t* const)0x4001142CU,   /** @brief USART prescaler register */
  };

  /**** @subsection USARTx Register Field Masks ****/

  static const uint32_t USARTx_CRx_RXFFIE_MSK      = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
  static const uint32_t USARTx_CRx_TXFEIE_MSK      = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
  static const uint32_t USARTx_CRx_FIFOEN_MSK      = 0x20000000U;   /** @brief FIFO mode enable */
  static const uint32_t USARTx_CRx_EOBIE_MSK       = 0x08000000U;   /** @brief End of block interrupt enable */
  static const uint32_t USARTx_CRx_RTOIE_MSK       = 0x04000000U;   /** @brief Receiver timeout interrupt enable */
  static const uint32_t USARTx_CRx_OVER8_MSK       = 0x00008000U;   /** @brief Oversampling mode */
  static const uint32_t USARTx_CRx_CMIE_MSK        = 0x00004000U;   /** @brief Character match interrupt enable */
  static const uint32_t USARTx_CRx_MME_MSK         = 0x00002000U;   /** @brief Mute mode enable */
  static const uint32_t USARTx_CRx_WAKE_MSK        = 0x00000800U;   /** @brief Receiver wakeup method */
  static const uint32_t USARTx_CRx_PCE_MSK         = 0x00000400U;   /** @brief Parity control enable */
  static const uint32_t USARTx_CRx_PS_MSK          = 0x00000200U;   /** @brief Parity selection */
  static const uint32_t USARTx_CRx_PEIE_MSK        = 0x00000100U;   /** @brief PE interrupt enable */
  static const uint32_t USARTx_CRx_TXEIE_MSK       = 0x00000080U;   /** @brief Interrupt enable */
  static const uint32_t USARTx_CRx_TCIE_MSK        = 0x00000040U;   /** @brief Transmission complete interrupt enable */
  static const uint32_t USARTx_CRx_RXNEIE_MSK      = 0x00000020U;   /** @brief RXNE interrupt enable */
  static const uint32_t USARTx_CRx_IDLEIE_MSK      = 0x00000010U;   /** @brief IDLE interrupt enable */
  static const uint32_t USARTx_CRx_TE_MSK          = 0x00000008U;   /** @brief Transmitter enable */
  static const uint32_t USARTx_CRx_RE_MSK          = 0x00000004U;   /** @brief Receiver enable */
  static const uint32_t USARTx_CRx_UESM_MSK        = 0x00000002U;   /** @brief USART enable in stop mode */
  static const uint32_t USARTx_CRx_UE_MSK          = 0x00000001U;   /** @brief USART enable */
  static const uint32_t USARTx_BRR_BRR_4_15_MSK    = 0x0000FFF0U;   /** @brief DIV_Mantissa */
  static const uint32_t USARTx_BRR_BRR_0_3_MSK     = 0x0000000FU;   /** @brief DIV_Fraction */
  static const uint32_t USARTx_GTPR_GT_MSK         = 0x0000FF00U;   /** @brief Guard time value */
  static const uint32_t USARTx_GTPR_PSC_MSK        = 0x000000FFU;   /** @brief Prescaler value */
  static const uint32_t USARTx_RTOR_BLEN_MSK       = 0xFF000000U;   /** @brief Block length */
  static const uint32_t USARTx_RTOR_RTO_MSK        = 0x00FFFFFFU;   /** @brief Receiver timeout value */
  static const uint32_t USARTx_RQR_TXFRQ_MSK       = 0x00000010U;   /** @brief Transmit data flush request */
  static const uint32_t USARTx_RQR_RXFRQ_MSK       = 0x00000008U;   /** @brief Receive data flush request */
  static const uint32_t USARTx_RQR_MMRQ_MSK        = 0x00000004U;   /** @brief Mute mode request */
  static const uint32_t USARTx_RQR_SBKRQ_MSK       = 0x00000002U;   /** @brief Send break request */
  static const uint32_t USARTx_RQR_ABRRQ_MSK       = 0x00000001U;   /** @brief Auto baud rate request */
  static const uint32_t USARTx_ISR_TXFT_MSK        = 0x08000000U;   /** @brief TXFIFO threshold flag */
  static const uint32_t USARTx_ISR_RXFT_MSK        = 0x04000000U;   /** @brief RXFIFO threshold flag */
  static const uint32_t USARTx_ISR_TCBGT_MSK       = 0x02000000U;   /** @brief Transmission complete before guard time flag */
  static const uint32_t USARTx_ISR_RXFF_MSK        = 0x01000000U;   /** @brief RXFIFO full */
  static const uint32_t USARTx_ISR_TXFE_MSK        = 0x00800000U;   /** @brief TXFIFO empty */
  static const uint32_t USARTx_ISR_REACK_MSK       = 0x00400000U;   /** @brief REACK */
  static const uint32_t USARTx_ISR_TEACK_MSK       = 0x00200000U;   /** @brief TEACK */
  static const uint32_t USARTx_ISR_WUF_MSK         = 0x00100000U;   /** @brief WUF */
  static const uint32_t USARTx_ISR_RWU_MSK         = 0x00080000U;   /** @brief RWU */
  static const uint32_t USARTx_ISR_SBKF_MSK        = 0x00040000U;   /** @brief SBKF */
  static const uint32_t USARTx_ISR_CMF_MSK         = 0x00020000U;   /** @brief CMF */
  static const uint32_t USARTx_ISR_BUSY_MSK        = 0x00010000U;   /** @brief BUSY */
  static const uint32_t USARTx_ISR_ABRF_MSK        = 0x00008000U;   /** @brief ABRF */
  static const uint32_t USARTx_ISR_ABRE_MSK        = 0x00004000U;   /** @brief ABRE */
  static const uint32_t USARTx_ISR_UDR_MSK         = 0x00002000U;   /** @brief SPI slave underrun error flag */
  static const uint32_t USARTx_ISR_EOBF_MSK        = 0x00001000U;   /** @brief EOBF */
  static const uint32_t USARTx_ISR_RTOF_MSK        = 0x00000800U;   /** @brief RTOF */
  static const uint32_t USARTx_ISR_CTS_MSK         = 0x00000400U;   /** @brief CTS */
  static const uint32_t USARTx_ISR_CTSIF_MSK       = 0x00000200U;   /** @brief CTSIF */
  static const uint32_t USARTx_ISR_LBDF_MSK        = 0x00000100U;   /** @brief LBDF */
  static const uint32_t USARTx_ISR_TXE_MSK         = 0x00000080U;   /** @brief TXE */
  static const uint32_t USARTx_ISR_TC_MSK          = 0x00000040U;   /** @brief TC */
  static const uint32_t USARTx_ISR_RXNE_MSK        = 0x00000020U;   /** @brief RXNE */
  static const uint32_t USARTx_ISR_IDLE_MSK        = 0x00000010U;   /** @brief IDLE */
  static const uint32_t USARTx_ISR_ORE_MSK         = 0x00000008U;   /** @brief ORE */
  static const uint32_t USARTx_ISR_NF_MSK          = 0x00000004U;   /** @brief NF */
  static const uint32_t USARTx_ISR_FE_MSK          = 0x00000002U;   /** @brief FE */
  static const uint32_t USARTx_ISR_PE_MSK          = 0x00000001U;   /** @brief PE */
  static const uint32_t USARTx_ICR_WUCF_MSK        = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
  static const uint32_t USARTx_ICR_CMCF_MSK        = 0x00020000U;   /** @brief Character match clear flag */
  static const uint32_t USARTx_ICR_UDRCF_MSK       = 0x00002000U;   /** @brief SPI slave underrun clear flag */
  static const uint32_t USARTx_ICR_EOBCF_MSK       = 0x00001000U;   /** @brief End of block clear flag */
  static const uint32_t USARTx_ICR_RTOCF_MSK       = 0x00000800U;   /** @brief Receiver timeout clear flag */
  static const uint32_t USARTx_ICR_CTSCF_MSK       = 0x00000200U;   /** @brief CTS clear flag */
  static const uint32_t USARTx_ICR_LBDCF_MSK       = 0x00000100U;   /** @brief LIN break detection clear flag */
  static const uint32_t USARTx_ICR_TCBGTC_MSK      = 0x00000080U;   /** @brief Transmission complete before guard time clear flag */
  static const uint32_t USARTx_ICR_TCCF_MSK        = 0x00000040U;   /** @brief Transmission complete clear flag */
  static const uint32_t USARTx_ICR_TXFECF_MSK      = 0x00000020U;   /** @brief TXFIFO empty clear flag */
  static const uint32_t USARTx_ICR_IDLECF_MSK      = 0x00000010U;   /** @brief Idle line detected clear flag */
  static const uint32_t USARTx_ICR_ORECF_MSK       = 0x00000008U;   /** @brief Overrun error clear flag */
  static const uint32_t USARTx_ICR_NCF_MSK         = 0x00000004U;   /** @brief Noise detected clear flag */
  static const uint32_t USARTx_ICR_FECF_MSK        = 0x00000002U;   /** @brief Framing error clear flag */
  static const uint32_t USARTx_ICR_PECF_MSK        = 0x00000001U;   /** @brief Parity error clear flag */
  static const uint32_t USARTx_RDR_RDR_MSK         = 0x000001FFU;   /** @brief Receive data value */
  static const uint32_t USARTx_TDR_TDR_MSK         = 0x000001FFU;   /** @brief Transmit data value */
  static const uint32_t USARTx_PRESC_PRESCALER_MSK = 0x0000000FU;   /** @brief Clock prescaler */

  /**** @subsection Enumerated USARTx Register Field Masks ****/

  static const uint32_t USARTx_CRx_Mx_MSK[2] = {
    [0] = 0x00001000U,   /** @brief Word length */
    [1] = 0x10000000U,   /** @brief Word length */
  };

  static const uint32_t USARTx_CRx_DEATx_MSK[5] = {
    [0] = 0x00200000U,   /** @brief DEAT0 */
    [1] = 0x00400000U,   /** @brief DEAT1 */
    [2] = 0x00800000U,   /** @brief DEAT2 */
    [3] = 0x01000000U,   /** @brief DEAT3 */
    [4] = 0x02000000U,   /** @brief Driver enable assertion time */
  };

  static const uint32_t USARTx_CRx_DEDTx_MSK[5] = {
    [0] = 0x00010000U,   /** @brief DEDT0 */
    [1] = 0x00020000U,   /** @brief DEDT1 */
    [2] = 0x00040000U,   /** @brief DEDT2 */
    [3] = 0x00080000U,   /** @brief DEDT3 */
    [4] = 0x00100000U,   /** @brief Driver enable de-assertion time */
  };

  /**** @subsection USARTx Register Field Positions ****/

  static const int32_t USARTx_CRx_RXFFIE_POS      = 31;   /** @brief RXFIFO full interrupt enable */
  static const int32_t USARTx_CRx_TXFEIE_POS      = 30;   /** @brief TXFIFO empty interrupt enable */
  static const int32_t USARTx_CRx_FIFOEN_POS      = 29;   /** @brief FIFO mode enable */
  static const int32_t USARTx_CRx_EOBIE_POS       = 27;   /** @brief End of block interrupt enable */
  static const int32_t USARTx_CRx_RTOIE_POS       = 26;   /** @brief Receiver timeout interrupt enable */
  static const int32_t USARTx_CRx_OVER8_POS       = 15;   /** @brief Oversampling mode */
  static const int32_t USARTx_CRx_CMIE_POS        = 14;   /** @brief Character match interrupt enable */
  static const int32_t USARTx_CRx_MME_POS         = 13;   /** @brief Mute mode enable */
  static const int32_t USARTx_CRx_WAKE_POS        = 11;   /** @brief Receiver wakeup method */
  static const int32_t USARTx_CRx_PCE_POS         = 10;   /** @brief Parity control enable */
  static const int32_t USARTx_CRx_PS_POS          = 9;    /** @brief Parity selection */
  static const int32_t USARTx_CRx_PEIE_POS        = 8;    /** @brief PE interrupt enable */
  static const int32_t USARTx_CRx_TXEIE_POS       = 7;    /** @brief Interrupt enable */
  static const int32_t USARTx_CRx_TCIE_POS        = 6;    /** @brief Transmission complete interrupt enable */
  static const int32_t USARTx_CRx_RXNEIE_POS      = 5;    /** @brief RXNE interrupt enable */
  static const int32_t USARTx_CRx_IDLEIE_POS      = 4;    /** @brief IDLE interrupt enable */
  static const int32_t USARTx_CRx_TE_POS          = 3;    /** @brief Transmitter enable */
  static const int32_t USARTx_CRx_RE_POS          = 2;    /** @brief Receiver enable */
  static const int32_t USARTx_CRx_UESM_POS        = 1;    /** @brief USART enable in stop mode */
  static const int32_t USARTx_CRx_UE_POS          = 0;    /** @brief USART enable */
  static const int32_t USARTx_BRR_BRR_4_15_POS    = 4;    /** @brief DIV_Mantissa */
  static const int32_t USARTx_BRR_BRR_0_3_POS     = 0;    /** @brief DIV_Fraction */
  static const int32_t USARTx_GTPR_GT_POS         = 8;    /** @brief Guard time value */
  static const int32_t USARTx_GTPR_PSC_POS        = 0;    /** @brief Prescaler value */
  static const int32_t USARTx_RTOR_BLEN_POS       = 24;   /** @brief Block length */
  static const int32_t USARTx_RTOR_RTO_POS        = 0;    /** @brief Receiver timeout value */
  static const int32_t USARTx_RQR_TXFRQ_POS       = 4;    /** @brief Transmit data flush request */
  static const int32_t USARTx_RQR_RXFRQ_POS       = 3;    /** @brief Receive data flush request */
  static const int32_t USARTx_RQR_MMRQ_POS        = 2;    /** @brief Mute mode request */
  static const int32_t USARTx_RQR_SBKRQ_POS       = 1;    /** @brief Send break request */
  static const int32_t USARTx_RQR_ABRRQ_POS       = 0;    /** @brief Auto baud rate request */
  static const int32_t USARTx_ISR_TXFT_POS        = 27;   /** @brief TXFIFO threshold flag */
  static const int32_t USARTx_ISR_RXFT_POS        = 26;   /** @brief RXFIFO threshold flag */
  static const int32_t USARTx_ISR_TCBGT_POS       = 25;   /** @brief Transmission complete before guard time flag */
  static const int32_t USARTx_ISR_RXFF_POS        = 24;   /** @brief RXFIFO full */
  static const int32_t USARTx_ISR_TXFE_POS        = 23;   /** @brief TXFIFO empty */
  static const int32_t USARTx_ISR_REACK_POS       = 22;   /** @brief REACK */
  static const int32_t USARTx_ISR_TEACK_POS       = 21;   /** @brief TEACK */
  static const int32_t USARTx_ISR_WUF_POS         = 20;   /** @brief WUF */
  static const int32_t USARTx_ISR_RWU_POS         = 19;   /** @brief RWU */
  static const int32_t USARTx_ISR_SBKF_POS        = 18;   /** @brief SBKF */
  static const int32_t USARTx_ISR_CMF_POS         = 17;   /** @brief CMF */
  static const int32_t USARTx_ISR_BUSY_POS        = 16;   /** @brief BUSY */
  static const int32_t USARTx_ISR_ABRF_POS        = 15;   /** @brief ABRF */
  static const int32_t USARTx_ISR_ABRE_POS        = 14;   /** @brief ABRE */
  static const int32_t USARTx_ISR_UDR_POS         = 13;   /** @brief SPI slave underrun error flag */
  static const int32_t USARTx_ISR_EOBF_POS        = 12;   /** @brief EOBF */
  static const int32_t USARTx_ISR_RTOF_POS        = 11;   /** @brief RTOF */
  static const int32_t USARTx_ISR_CTS_POS         = 10;   /** @brief CTS */
  static const int32_t USARTx_ISR_CTSIF_POS       = 9;    /** @brief CTSIF */
  static const int32_t USARTx_ISR_LBDF_POS        = 8;    /** @brief LBDF */
  static const int32_t USARTx_ISR_TXE_POS         = 7;    /** @brief TXE */
  static const int32_t USARTx_ISR_TC_POS          = 6;    /** @brief TC */
  static const int32_t USARTx_ISR_RXNE_POS        = 5;    /** @brief RXNE */
  static const int32_t USARTx_ISR_IDLE_POS        = 4;    /** @brief IDLE */
  static const int32_t USARTx_ISR_ORE_POS         = 3;    /** @brief ORE */
  static const int32_t USARTx_ISR_NF_POS          = 2;    /** @brief NF */
  static const int32_t USARTx_ISR_FE_POS          = 1;    /** @brief FE */
  static const int32_t USARTx_ISR_PE_POS          = 0;    /** @brief PE */
  static const int32_t USARTx_ICR_WUCF_POS        = 20;   /** @brief Wakeup from stop mode clear flag */
  static const int32_t USARTx_ICR_CMCF_POS        = 17;   /** @brief Character match clear flag */
  static const int32_t USARTx_ICR_UDRCF_POS       = 13;   /** @brief SPI slave underrun clear flag */
  static const int32_t USARTx_ICR_EOBCF_POS       = 12;   /** @brief End of block clear flag */
  static const int32_t USARTx_ICR_RTOCF_POS       = 11;   /** @brief Receiver timeout clear flag */
  static const int32_t USARTx_ICR_CTSCF_POS       = 9;    /** @brief CTS clear flag */
  static const int32_t USARTx_ICR_LBDCF_POS       = 8;    /** @brief LIN break detection clear flag */
  static const int32_t USARTx_ICR_TCBGTC_POS      = 7;    /** @brief Transmission complete before guard time clear flag */
  static const int32_t USARTx_ICR_TCCF_POS        = 6;    /** @brief Transmission complete clear flag */
  static const int32_t USARTx_ICR_TXFECF_POS      = 5;    /** @brief TXFIFO empty clear flag */
  static const int32_t USARTx_ICR_IDLECF_POS      = 4;    /** @brief Idle line detected clear flag */
  static const int32_t USARTx_ICR_ORECF_POS       = 3;    /** @brief Overrun error clear flag */
  static const int32_t USARTx_ICR_NCF_POS         = 2;    /** @brief Noise detected clear flag */
  static const int32_t USARTx_ICR_FECF_POS        = 1;    /** @brief Framing error clear flag */
  static const int32_t USARTx_ICR_PECF_POS        = 0;    /** @brief Parity error clear flag */
  static const int32_t USARTx_RDR_RDR_POS         = 0;    /** @brief Receive data value */
  static const int32_t USARTx_TDR_TDR_POS         = 0;    /** @brief Transmit data value */
  static const int32_t USARTx_PRESC_PRESCALER_POS = 0;    /** @brief Clock prescaler */

  /**** @subsection Enumerated USARTx Register Field Positions ****/

  static const int32_t USARTx_CRx_Mx_POS[2] = {
    [0] = 12,   /** @brief Word length */
    [1] = 28,   /** @brief Word length */
  };

  static const int32_t USARTx_CRx_DEATx_POS[5] = {
    [0] = 21,   /** @brief DEAT0 */
    [1] = 22,   /** @brief DEAT1 */
    [2] = 23,   /** @brief DEAT2 */
    [3] = 24,   /** @brief DEAT3 */
    [4] = 25,   /** @brief Driver enable assertion time */
  };

  static const int32_t USARTx_CRx_DEDTx_POS[5] = {
    [0] = 16,   /** @brief DEDT0 */
    [1] = 17,   /** @brief DEDT1 */
    [2] = 18,   /** @brief DEDT2 */
    [3] = 19,   /** @brief DEDT3 */
    [4] = 20,   /** @brief Driver enable de-assertion time */
  };

  /**********************************************************************************************
   * @section UARTx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated UARTx Register Pointers ****/

  static RW_ uint32_t* const UARTx_CRx_PTR[9][4] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40004C00U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40004C04U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40004C08U,   /** @brief Control register 3 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40005000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40005004U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40005008U,   /** @brief Control register 3 */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x40007800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40007804U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40007808U,   /** @brief Control register 3 */
    },
    [3] = {
      [1] = (RW_ uint32_t* const)0x40007C00U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40007C04U,   /** @brief Control register 2 */
      [3] = (RW_ uint32_t* const)0x40007C08U,   /** @brief Control register 3 */
    },
  };

  static RW_ uint32_t* const UARTx_BRR_PTR[9] = {
    [4] = (RW_ uint32_t* const)0x40004C0CU,   /** @brief Baud rate register */
    [5] = (RW_ uint32_t* const)0x4000500CU,   /** @brief Baud rate register */
    [7] = (RW_ uint32_t* const)0x4000780CU,   /** @brief Baud rate register */
    [8] = (RW_ uint32_t* const)0x40007C0CU,   /** @brief Baud rate register */
  };

  static RW_ uint32_t* const UARTx_GTPR_PTR[9] = {
    [4] = (RW_ uint32_t* const)0x40004C10U,   /** @brief Guard time and prescaler register */
    [5] = (RW_ uint32_t* const)0x40005010U,   /** @brief Guard time and prescaler register */
    [7] = (RW_ uint32_t* const)0x40007810U,   /** @brief Guard time and prescaler register */
    [8] = (RW_ uint32_t* const)0x40007C10U,   /** @brief Guard time and prescaler register */
  };

  static RW_ uint32_t* const UARTx_RTOR_PTR[9] = {
    [4] = (RW_ uint32_t* const)0x40004C14U,   /** @brief Receiver timeout register */
    [5] = (RW_ uint32_t* const)0x40005014U,   /** @brief Receiver timeout register */
    [7] = (RW_ uint32_t* const)0x40007814U,   /** @brief Receiver timeout register */
    [8] = (RW_ uint32_t* const)0x40007C14U,   /** @brief Receiver timeout register */
  };

  static WO_ uint32_t* const UARTx_RQR_PTR[9] = {
    [4] = (WO_ uint32_t* const)0x40004C18U,   /** @brief Request register */
    [5] = (WO_ uint32_t* const)0x40005018U,   /** @brief Request register */
    [7] = (WO_ uint32_t* const)0x40007818U,   /** @brief Request register */
    [8] = (WO_ uint32_t* const)0x40007C18U,   /** @brief Request register */
  };

  static RO_ uint32_t* const UARTx_ISR_PTR[9] = {
    [4] = (RO_ uint32_t* const)0x40004C1CU,   /** @brief Interrupt & status register */
    [5] = (RO_ uint32_t* const)0x4000501CU,   /** @brief Interrupt & status register */
    [7] = (RO_ uint32_t* const)0x4000781CU,   /** @brief Interrupt & status register */
    [8] = (RO_ uint32_t* const)0x40007C1CU,   /** @brief Interrupt & status register */
  };

  static WO_ uint32_t* const UARTx_ICR_PTR[9] = {
    [4] = (WO_ uint32_t* const)0x40004C20U,   /** @brief Interrupt flag clear register */
    [5] = (WO_ uint32_t* const)0x40005020U,   /** @brief Interrupt flag clear register */
    [7] = (WO_ uint32_t* const)0x40007820U,   /** @brief Interrupt flag clear register */
    [8] = (WO_ uint32_t* const)0x40007C20U,   /** @brief Interrupt flag clear register */
  };

  static RO_ uint32_t* const UARTx_RDR_PTR[9] = {
    [4] = (RO_ uint32_t* const)0x40004C24U,   /** @brief Receive data register */
    [5] = (RO_ uint32_t* const)0x40005024U,   /** @brief Receive data register */
    [7] = (RO_ uint32_t* const)0x40007824U,   /** @brief Receive data register */
    [8] = (RO_ uint32_t* const)0x40007C24U,   /** @brief Receive data register */
  };

  static RW_ uint32_t* const UARTx_TDR_PTR[9] = {
    [4] = (RW_ uint32_t* const)0x40004C28U,   /** @brief Transmit data register */
    [5] = (RW_ uint32_t* const)0x40005028U,   /** @brief Transmit data register */
    [7] = (RW_ uint32_t* const)0x40007828U,   /** @brief Transmit data register */
    [8] = (RW_ uint32_t* const)0x40007C28U,   /** @brief Transmit data register */
  };

  static RW_ uint32_t* const UARTx_PRESC_PTR[9] = {
    [4] = (RW_ uint32_t* const)0x40004C2CU,   /** @brief USART prescaler register */
    [5] = (RW_ uint32_t* const)0x4000502CU,   /** @brief USART prescaler register */
    [7] = (RW_ uint32_t* const)0x4000782CU,   /** @brief USART prescaler register */
    [8] = (RW_ uint32_t* const)0x40007C2CU,   /** @brief USART prescaler register */
  };

  /**** @subsection UARTx Register Field Masks ****/

  static const uint32_t UARTx_CRx_RXFFIE_MSK      = 0x80000000U;   /** @brief RXFIFO full interrupt enable */
  static const uint32_t UARTx_CRx_TXFEIE_MSK      = 0x40000000U;   /** @brief TXFIFO empty interrupt enable */
  static const uint32_t UARTx_CRx_FIFOEN_MSK      = 0x20000000U;   /** @brief FIFO mode enable */
  static const uint32_t UARTx_CRx_EOBIE_MSK       = 0x08000000U;   /** @brief End of block interrupt enable */
  static const uint32_t UARTx_CRx_RTOIE_MSK       = 0x04000000U;   /** @brief Receiver timeout interrupt enable */
  static const uint32_t UARTx_CRx_OVER8_MSK       = 0x00008000U;   /** @brief Oversampling mode */
  static const uint32_t UARTx_CRx_CMIE_MSK        = 0x00004000U;   /** @brief Character match interrupt enable */
  static const uint32_t UARTx_CRx_MME_MSK         = 0x00002000U;   /** @brief Mute mode enable */
  static const uint32_t UARTx_CRx_WAKE_MSK        = 0x00000800U;   /** @brief Receiver wakeup method */
  static const uint32_t UARTx_CRx_PCE_MSK         = 0x00000400U;   /** @brief Parity control enable */
  static const uint32_t UARTx_CRx_PS_MSK          = 0x00000200U;   /** @brief Parity selection */
  static const uint32_t UARTx_CRx_PEIE_MSK        = 0x00000100U;   /** @brief PE interrupt enable */
  static const uint32_t UARTx_CRx_TXEIE_MSK       = 0x00000080U;   /** @brief Interrupt enable */
  static const uint32_t UARTx_CRx_TCIE_MSK        = 0x00000040U;   /** @brief Transmission complete interrupt enable */
  static const uint32_t UARTx_CRx_RXNEIE_MSK      = 0x00000020U;   /** @brief RXNE interrupt enable */
  static const uint32_t UARTx_CRx_IDLEIE_MSK      = 0x00000010U;   /** @brief IDLE interrupt enable */
  static const uint32_t UARTx_CRx_TE_MSK          = 0x00000008U;   /** @brief Transmitter enable */
  static const uint32_t UARTx_CRx_RE_MSK          = 0x00000004U;   /** @brief Receiver enable */
  static const uint32_t UARTx_CRx_UESM_MSK        = 0x00000002U;   /** @brief USART enable in stop mode */
  static const uint32_t UARTx_CRx_UE_MSK          = 0x00000001U;   /** @brief USART enable */
  static const uint32_t UARTx_BRR_BRR_4_15_MSK    = 0x0000FFF0U;   /** @brief DIV_Mantissa */
  static const uint32_t UARTx_BRR_BRR_0_3_MSK     = 0x0000000FU;   /** @brief DIV_Fraction */
  static const uint32_t UARTx_GTPR_GT_MSK         = 0x0000FF00U;   /** @brief Guard time value */
  static const uint32_t UARTx_GTPR_PSC_MSK        = 0x000000FFU;   /** @brief Prescaler value */
  static const uint32_t UARTx_RTOR_BLEN_MSK       = 0xFF000000U;   /** @brief Block length */
  static const uint32_t UARTx_RTOR_RTO_MSK        = 0x00FFFFFFU;   /** @brief Receiver timeout value */
  static const uint32_t UARTx_RQR_TXFRQ_MSK       = 0x00000010U;   /** @brief Transmit data flush request */
  static const uint32_t UARTx_RQR_RXFRQ_MSK       = 0x00000008U;   /** @brief Receive data flush request */
  static const uint32_t UARTx_RQR_MMRQ_MSK        = 0x00000004U;   /** @brief Mute mode request */
  static const uint32_t UARTx_RQR_SBKRQ_MSK       = 0x00000002U;   /** @brief Send break request */
  static const uint32_t UARTx_RQR_ABRRQ_MSK       = 0x00000001U;   /** @brief Auto baud rate request */
  static const uint32_t UARTx_ISR_TXFT_MSK        = 0x08000000U;   /** @brief TXFIFO threshold flag */
  static const uint32_t UARTx_ISR_RXFT_MSK        = 0x04000000U;   /** @brief RXFIFO threshold flag */
  static const uint32_t UARTx_ISR_TCBGT_MSK       = 0x02000000U;   /** @brief Transmission complete before guard time flag */
  static const uint32_t UARTx_ISR_RXFF_MSK        = 0x01000000U;   /** @brief RXFIFO full */
  static const uint32_t UARTx_ISR_TXFE_MSK        = 0x00800000U;   /** @brief TXFIFO empty */
  static const uint32_t UARTx_ISR_REACK_MSK       = 0x00400000U;   /** @brief REACK */
  static const uint32_t UARTx_ISR_TEACK_MSK       = 0x00200000U;   /** @brief TEACK */
  static const uint32_t UARTx_ISR_WUF_MSK         = 0x00100000U;   /** @brief WUF */
  static const uint32_t UARTx_ISR_RWU_MSK         = 0x00080000U;   /** @brief RWU */
  static const uint32_t UARTx_ISR_SBKF_MSK        = 0x00040000U;   /** @brief SBKF */
  static const uint32_t UARTx_ISR_CMF_MSK         = 0x00020000U;   /** @brief CMF */
  static const uint32_t UARTx_ISR_BUSY_MSK        = 0x00010000U;   /** @brief BUSY */
  static const uint32_t UARTx_ISR_ABRF_MSK        = 0x00008000U;   /** @brief ABRF */
  static const uint32_t UARTx_ISR_ABRE_MSK        = 0x00004000U;   /** @brief ABRE */
  static const uint32_t UARTx_ISR_UDR_MSK         = 0x00002000U;   /** @brief SPI slave underrun error flag */
  static const uint32_t UARTx_ISR_EOBF_MSK        = 0x00001000U;   /** @brief EOBF */
  static const uint32_t UARTx_ISR_RTOF_MSK        = 0x00000800U;   /** @brief RTOF */
  static const uint32_t UARTx_ISR_CTS_MSK         = 0x00000400U;   /** @brief CTS */
  static const uint32_t UARTx_ISR_CTSIF_MSK       = 0x00000200U;   /** @brief CTSIF */
  static const uint32_t UARTx_ISR_LBDF_MSK        = 0x00000100U;   /** @brief LBDF */
  static const uint32_t UARTx_ISR_TXE_MSK         = 0x00000080U;   /** @brief TXE */
  static const uint32_t UARTx_ISR_TC_MSK          = 0x00000040U;   /** @brief TC */
  static const uint32_t UARTx_ISR_RXNE_MSK        = 0x00000020U;   /** @brief RXNE */
  static const uint32_t UARTx_ISR_IDLE_MSK        = 0x00000010U;   /** @brief IDLE */
  static const uint32_t UARTx_ISR_ORE_MSK         = 0x00000008U;   /** @brief ORE */
  static const uint32_t UARTx_ISR_NF_MSK          = 0x00000004U;   /** @brief NF */
  static const uint32_t UARTx_ISR_FE_MSK          = 0x00000002U;   /** @brief FE */
  static const uint32_t UARTx_ISR_PE_MSK          = 0x00000001U;   /** @brief PE */
  static const uint32_t UARTx_ICR_WUCF_MSK        = 0x00100000U;   /** @brief Wakeup from stop mode clear flag */
  static const uint32_t UARTx_ICR_CMCF_MSK        = 0x00020000U;   /** @brief Character match clear flag */
  static const uint32_t UARTx_ICR_UDRCF_MSK       = 0x00002000U;   /** @brief SPI slave underrun clear flag */
  static const uint32_t UARTx_ICR_EOBCF_MSK       = 0x00001000U;   /** @brief End of block clear flag */
  static const uint32_t UARTx_ICR_RTOCF_MSK       = 0x00000800U;   /** @brief Receiver timeout clear flag */
  static const uint32_t UARTx_ICR_CTSCF_MSK       = 0x00000200U;   /** @brief CTS clear flag */
  static const uint32_t UARTx_ICR_LBDCF_MSK       = 0x00000100U;   /** @brief LIN break detection clear flag */
  static const uint32_t UARTx_ICR_TCBGTC_MSK      = 0x00000080U;   /** @brief Transmission complete before guard time clear flag */
  static const uint32_t UARTx_ICR_TCCF_MSK        = 0x00000040U;   /** @brief Transmission complete clear flag */
  static const uint32_t UARTx_ICR_TXFECF_MSK      = 0x00000020U;   /** @brief TXFIFO empty clear flag */
  static const uint32_t UARTx_ICR_IDLECF_MSK      = 0x00000010U;   /** @brief Idle line detected clear flag */
  static const uint32_t UARTx_ICR_ORECF_MSK       = 0x00000008U;   /** @brief Overrun error clear flag */
  static const uint32_t UARTx_ICR_NCF_MSK         = 0x00000004U;   /** @brief Noise detected clear flag */
  static const uint32_t UARTx_ICR_FECF_MSK        = 0x00000002U;   /** @brief Framing error clear flag */
  static const uint32_t UARTx_ICR_PECF_MSK        = 0x00000001U;   /** @brief Parity error clear flag */
  static const uint32_t UARTx_RDR_RDR_MSK         = 0x000001FFU;   /** @brief Receive data value */
  static const uint32_t UARTx_TDR_TDR_MSK         = 0x000001FFU;   /** @brief Transmit data value */
  static const uint32_t UARTx_PRESC_PRESCALER_MSK = 0x0000000FU;   /** @brief Clock prescaler */

  /**** @subsection Enumerated UARTx Register Field Masks ****/

  static const uint32_t UARTx_CRx_Mx_MSK[2] = {
    [0] = 0x00001000U,   /** @brief Word length */
    [1] = 0x10000000U,   /** @brief Word length */
  };

  static const uint32_t UARTx_CRx_DEATx_MSK[5] = {
    [0] = 0x00200000U,   /** @brief DEAT0 */
    [1] = 0x00400000U,   /** @brief DEAT1 */
    [2] = 0x00800000U,   /** @brief DEAT2 */
    [3] = 0x01000000U,   /** @brief DEAT3 */
    [4] = 0x02000000U,   /** @brief Driver enable assertion time */
  };

  static const uint32_t UARTx_CRx_DEDTx_MSK[5] = {
    [0] = 0x00010000U,   /** @brief DEDT0 */
    [1] = 0x00020000U,   /** @brief DEDT1 */
    [2] = 0x00040000U,   /** @brief DEDT2 */
    [3] = 0x00080000U,   /** @brief DEDT3 */
    [4] = 0x00100000U,   /** @brief Driver enable de-assertion time */
  };

  /**** @subsection UARTx Register Field Positions ****/

  static const int32_t UARTx_CRx_RXFFIE_POS      = 31;   /** @brief RXFIFO full interrupt enable */
  static const int32_t UARTx_CRx_TXFEIE_POS      = 30;   /** @brief TXFIFO empty interrupt enable */
  static const int32_t UARTx_CRx_FIFOEN_POS      = 29;   /** @brief FIFO mode enable */
  static const int32_t UARTx_CRx_EOBIE_POS       = 27;   /** @brief End of block interrupt enable */
  static const int32_t UARTx_CRx_RTOIE_POS       = 26;   /** @brief Receiver timeout interrupt enable */
  static const int32_t UARTx_CRx_OVER8_POS       = 15;   /** @brief Oversampling mode */
  static const int32_t UARTx_CRx_CMIE_POS        = 14;   /** @brief Character match interrupt enable */
  static const int32_t UARTx_CRx_MME_POS         = 13;   /** @brief Mute mode enable */
  static const int32_t UARTx_CRx_WAKE_POS        = 11;   /** @brief Receiver wakeup method */
  static const int32_t UARTx_CRx_PCE_POS         = 10;   /** @brief Parity control enable */
  static const int32_t UARTx_CRx_PS_POS          = 9;    /** @brief Parity selection */
  static const int32_t UARTx_CRx_PEIE_POS        = 8;    /** @brief PE interrupt enable */
  static const int32_t UARTx_CRx_TXEIE_POS       = 7;    /** @brief Interrupt enable */
  static const int32_t UARTx_CRx_TCIE_POS        = 6;    /** @brief Transmission complete interrupt enable */
  static const int32_t UARTx_CRx_RXNEIE_POS      = 5;    /** @brief RXNE interrupt enable */
  static const int32_t UARTx_CRx_IDLEIE_POS      = 4;    /** @brief IDLE interrupt enable */
  static const int32_t UARTx_CRx_TE_POS          = 3;    /** @brief Transmitter enable */
  static const int32_t UARTx_CRx_RE_POS          = 2;    /** @brief Receiver enable */
  static const int32_t UARTx_CRx_UESM_POS        = 1;    /** @brief USART enable in stop mode */
  static const int32_t UARTx_CRx_UE_POS          = 0;    /** @brief USART enable */
  static const int32_t UARTx_BRR_BRR_4_15_POS    = 4;    /** @brief DIV_Mantissa */
  static const int32_t UARTx_BRR_BRR_0_3_POS     = 0;    /** @brief DIV_Fraction */
  static const int32_t UARTx_GTPR_GT_POS         = 8;    /** @brief Guard time value */
  static const int32_t UARTx_GTPR_PSC_POS        = 0;    /** @brief Prescaler value */
  static const int32_t UARTx_RTOR_BLEN_POS       = 24;   /** @brief Block length */
  static const int32_t UARTx_RTOR_RTO_POS        = 0;    /** @brief Receiver timeout value */
  static const int32_t UARTx_RQR_TXFRQ_POS       = 4;    /** @brief Transmit data flush request */
  static const int32_t UARTx_RQR_RXFRQ_POS       = 3;    /** @brief Receive data flush request */
  static const int32_t UARTx_RQR_MMRQ_POS        = 2;    /** @brief Mute mode request */
  static const int32_t UARTx_RQR_SBKRQ_POS       = 1;    /** @brief Send break request */
  static const int32_t UARTx_RQR_ABRRQ_POS       = 0;    /** @brief Auto baud rate request */
  static const int32_t UARTx_ISR_TXFT_POS        = 27;   /** @brief TXFIFO threshold flag */
  static const int32_t UARTx_ISR_RXFT_POS        = 26;   /** @brief RXFIFO threshold flag */
  static const int32_t UARTx_ISR_TCBGT_POS       = 25;   /** @brief Transmission complete before guard time flag */
  static const int32_t UARTx_ISR_RXFF_POS        = 24;   /** @brief RXFIFO full */
  static const int32_t UARTx_ISR_TXFE_POS        = 23;   /** @brief TXFIFO empty */
  static const int32_t UARTx_ISR_REACK_POS       = 22;   /** @brief REACK */
  static const int32_t UARTx_ISR_TEACK_POS       = 21;   /** @brief TEACK */
  static const int32_t UARTx_ISR_WUF_POS         = 20;   /** @brief WUF */
  static const int32_t UARTx_ISR_RWU_POS         = 19;   /** @brief RWU */
  static const int32_t UARTx_ISR_SBKF_POS        = 18;   /** @brief SBKF */
  static const int32_t UARTx_ISR_CMF_POS         = 17;   /** @brief CMF */
  static const int32_t UARTx_ISR_BUSY_POS        = 16;   /** @brief BUSY */
  static const int32_t UARTx_ISR_ABRF_POS        = 15;   /** @brief ABRF */
  static const int32_t UARTx_ISR_ABRE_POS        = 14;   /** @brief ABRE */
  static const int32_t UARTx_ISR_UDR_POS         = 13;   /** @brief SPI slave underrun error flag */
  static const int32_t UARTx_ISR_EOBF_POS        = 12;   /** @brief EOBF */
  static const int32_t UARTx_ISR_RTOF_POS        = 11;   /** @brief RTOF */
  static const int32_t UARTx_ISR_CTS_POS         = 10;   /** @brief CTS */
  static const int32_t UARTx_ISR_CTSIF_POS       = 9;    /** @brief CTSIF */
  static const int32_t UARTx_ISR_LBDF_POS        = 8;    /** @brief LBDF */
  static const int32_t UARTx_ISR_TXE_POS         = 7;    /** @brief TXE */
  static const int32_t UARTx_ISR_TC_POS          = 6;    /** @brief TC */
  static const int32_t UARTx_ISR_RXNE_POS        = 5;    /** @brief RXNE */
  static const int32_t UARTx_ISR_IDLE_POS        = 4;    /** @brief IDLE */
  static const int32_t UARTx_ISR_ORE_POS         = 3;    /** @brief ORE */
  static const int32_t UARTx_ISR_NF_POS          = 2;    /** @brief NF */
  static const int32_t UARTx_ISR_FE_POS          = 1;    /** @brief FE */
  static const int32_t UARTx_ISR_PE_POS          = 0;    /** @brief PE */
  static const int32_t UARTx_ICR_WUCF_POS        = 20;   /** @brief Wakeup from stop mode clear flag */
  static const int32_t UARTx_ICR_CMCF_POS        = 17;   /** @brief Character match clear flag */
  static const int32_t UARTx_ICR_UDRCF_POS       = 13;   /** @brief SPI slave underrun clear flag */
  static const int32_t UARTx_ICR_EOBCF_POS       = 12;   /** @brief End of block clear flag */
  static const int32_t UARTx_ICR_RTOCF_POS       = 11;   /** @brief Receiver timeout clear flag */
  static const int32_t UARTx_ICR_CTSCF_POS       = 9;    /** @brief CTS clear flag */
  static const int32_t UARTx_ICR_LBDCF_POS       = 8;    /** @brief LIN break detection clear flag */
  static const int32_t UARTx_ICR_TCBGTC_POS      = 7;    /** @brief Transmission complete before guard time clear flag */
  static const int32_t UARTx_ICR_TCCF_POS        = 6;    /** @brief Transmission complete clear flag */
  static const int32_t UARTx_ICR_TXFECF_POS      = 5;    /** @brief TXFIFO empty clear flag */
  static const int32_t UARTx_ICR_IDLECF_POS      = 4;    /** @brief Idle line detected clear flag */
  static const int32_t UARTx_ICR_ORECF_POS       = 3;    /** @brief Overrun error clear flag */
  static const int32_t UARTx_ICR_NCF_POS         = 2;    /** @brief Noise detected clear flag */
  static const int32_t UARTx_ICR_FECF_POS        = 1;    /** @brief Framing error clear flag */
  static const int32_t UARTx_ICR_PECF_POS        = 0;    /** @brief Parity error clear flag */
  static const int32_t UARTx_RDR_RDR_POS         = 0;    /** @brief Receive data value */
  static const int32_t UARTx_TDR_TDR_POS         = 0;    /** @brief Transmit data value */
  static const int32_t UARTx_PRESC_PRESCALER_POS = 0;    /** @brief Clock prescaler */

  /**** @subsection Enumerated UARTx Register Field Positions ****/

  static const int32_t UARTx_CRx_Mx_POS[2] = {
    [0] = 12,   /** @brief Word length */
    [1] = 28,   /** @brief Word length */
  };

  static const int32_t UARTx_CRx_DEATx_POS[5] = {
    [0] = 21,   /** @brief DEAT0 */
    [1] = 22,   /** @brief DEAT1 */
    [2] = 23,   /** @brief DEAT2 */
    [3] = 24,   /** @brief DEAT3 */
    [4] = 25,   /** @brief Driver enable assertion time */
  };

  static const int32_t UARTx_CRx_DEDTx_POS[5] = {
    [0] = 16,   /** @brief DEDT0 */
    [1] = 17,   /** @brief DEDT1 */
    [2] = 18,   /** @brief DEDT2 */
    [3] = 19,   /** @brief DEDT3 */
    [4] = 20,   /** @brief Driver enable de-assertion time */
  };

  /**********************************************************************************************
   * @section A_TIMx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated A_TIMx Register Pointers ****/

  static RW_ uint32_t* const A_TIMx_CRx_PTR[9][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40010000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40010004U,   /** @brief Control register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40010400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40010404U,   /** @brief Control register 2 */
    },
  };

  static RW_ uint32_t* const A_TIMx_SMCR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010008U,   /** @brief Slave mode control register */
    [8] = (RW_ uint32_t* const)0x40010408U,   /** @brief Slave mode control register */
  };

  static RW_ uint32_t* const A_TIMx_DIER_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x4001000CU,   /** @brief DMA/Interrupt enable register */
    [8] = (RW_ uint32_t* const)0x4001040CU,   /** @brief DMA/Interrupt enable register */
  };

  static RW_ uint32_t* const A_TIMx_SR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010010U,   /** @brief Status register */
    [8] = (RW_ uint32_t* const)0x40010410U,   /** @brief Status register */
  };

  static WO_ uint32_t* const A_TIMx_EGR_PTR[9] = {
    [1] = (WO_ uint32_t* const)0x40010014U,   /** @brief Event generation register */
    [8] = (WO_ uint32_t* const)0x40010414U,   /** @brief Event generation register */
  };

  static RW_ uint32_t* const A_TIMx_CCMRx_OUTPUT_PTR[9][4] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40010018U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4001001CU,   /** @brief Capture/compare mode register 2 (output mode) */
      [3] = (RW_ uint32_t* const)0x40010054U,   /** @brief Capture/compare mode register 3 (output mode) */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40010418U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4001041CU,   /** @brief Capture/compare mode register 2 (output mode) */
      [3] = (RW_ uint32_t* const)0x40010454U,   /** @brief Capture/compare mode register 3 (output mode) */
    },
  };

  static RW_ uint32_t* const A_TIMx_CCMRx_INPUT_PTR[9][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40010018U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4001001CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40010418U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4001041CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
  };

  static RW_ uint32_t* const A_TIMx_CCER_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010020U,   /** @brief Capture/compare enable register */
    [8] = (RW_ uint32_t* const)0x40010420U,   /** @brief Capture/compare enable register */
  };

  static RW_ uint32_t* const A_TIMx_CNT_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010024U,   /** @brief Counter */
    [8] = (RW_ uint32_t* const)0x40010424U,   /** @brief Counter */
  };

  static RW_ uint32_t* const A_TIMx_PSC_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010028U,   /** @brief Prescaler */
    [8] = (RW_ uint32_t* const)0x40010428U,   /** @brief Prescaler */
  };

  static RW_ uint32_t* const A_TIMx_ARR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x4001002CU,   /** @brief Auto-reload register */
    [8] = (RW_ uint32_t* const)0x4001042CU,   /** @brief Auto-reload register */
  };

  static RW_ uint32_t* const A_TIMx_CCRx_PTR[9][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40010034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40010038U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4001003CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40010040U,   /** @brief Capture/compare register 4 */
      [5] = (RW_ uint32_t* const)0x40010058U,   /** @brief Capture/compare register 5 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40010434U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40010438U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4001043CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40010440U,   /** @brief Capture/compare register 4 */
      [5] = (RW_ uint32_t* const)0x40010458U,   /** @brief Capture/compare register 5 */
    },
  };

  static RW_ uint32_t* const A_TIMx_DCR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010048U,   /** @brief DMA control register */
    [8] = (RW_ uint32_t* const)0x40010448U,   /** @brief DMA control register */
  };

  static RW_ uint32_t* const A_TIMx_DMAR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x4001004CU,   /** @brief DMA address for full transfer */
    [8] = (RW_ uint32_t* const)0x4001044CU,   /** @brief DMA address for full transfer */
  };

  static RW_ uint32_t* const A_TIMx_RCR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010030U,   /** @brief Repetition counter register */
    [8] = (RW_ uint32_t* const)0x40010430U,   /** @brief Repetition counter register */
  };

  static RW_ uint32_t* const A_TIMx_BDTR_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010044U,   /** @brief Break and dead-time register */
    [8] = (RW_ uint32_t* const)0x40010444U,   /** @brief Break and dead-time register */
  };

  static RW_ uint32_t* const A_TIMx_CRR6_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x4001005CU,   /** @brief Capture/compare register 6 */
    [8] = (RW_ uint32_t* const)0x4001045CU,   /** @brief Capture/compare register 6 */
  };

  static RW_ uint32_t* const A_TIMx_AFx_PTR[9][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40010060U,   /** @brief TIM1 alternate function option register 1 */
      [2] = (RW_ uint32_t* const)0x40010064U,   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40010460U,   /** @brief TIM1 alternate function option register 1 */
      [2] = (RW_ uint32_t* const)0x40010464U,   /** @brief TIM1 alternate function odfsdm1_breakster 2 */
    },
  };

  static RW_ uint32_t* const A_TIMx_TISEL_PTR[9] = {
    [1] = (RW_ uint32_t* const)0x40010068U,   /** @brief TIM1 timer input selection register */
    [8] = (RW_ uint32_t* const)0x40010468U,   /** @brief TIM1 timer input selection register */
  };

  /**** @subsection A_TIMx Register Field Masks ****/

  static const uint32_t A_TIMx_CRx_CEN_MSK            = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t A_TIMx_CRx_UDIS_MSK           = 0x00000002U;   /** @brief Update disable */
  static const uint32_t A_TIMx_CRx_URS_MSK            = 0x00000004U;   /** @brief Update request source */
  static const uint32_t A_TIMx_CRx_OPM_MSK            = 0x00000008U;   /** @brief One-pulse mode */
  static const uint32_t A_TIMx_CRx_DIR_MSK            = 0x00000010U;   /** @brief Direction */
  static const uint32_t A_TIMx_CRx_CMS_MSK            = 0x00000060U;   /** @brief Center-aligned mode selection */
  static const uint32_t A_TIMx_CRx_ARPE_MSK           = 0x00000080U;   /** @brief Auto-reload preload enable */
  static const uint32_t A_TIMx_CRx_CKD_MSK            = 0x00000300U;   /** @brief Clock division */
  static const uint32_t A_TIMx_CRx_UIFREMAP_MSK       = 0x00000800U;   /** @brief UIF status bit remapping */
  static const uint32_t A_TIMx_SMCR_SMS_MSK           = 0x00000007U;   /** @brief Slave mode selection */
  static const uint32_t A_TIMx_SMCR_TS_MSK            = 0x00000070U;   /** @brief Trigger selection */
  static const uint32_t A_TIMx_SMCR_MSM_MSK           = 0x00000080U;   /** @brief Master/Slave mode */
  static const uint32_t A_TIMx_SMCR_ETF_MSK           = 0x00000F00U;   /** @brief External trigger filter */
  static const uint32_t A_TIMx_SMCR_ETPS_MSK          = 0x00003000U;   /** @brief External trigger prescaler */
  static const uint32_t A_TIMx_SMCR_ECE_MSK           = 0x00004000U;   /** @brief External clock enable */
  static const uint32_t A_TIMx_SMCR_ETP_MSK           = 0x00008000U;   /** @brief External trigger polarity */
  static const uint32_t A_TIMx_SMCR_SMS_3_MSK         = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
  static const uint32_t A_TIMx_SMCR_TS_4_3_MSK        = 0x00300000U;   /** @brief Trigger selection - bit 4:3 */
  static const uint32_t A_TIMx_DIER_TDE_MSK           = 0x00004000U;   /** @brief Trigger DMA request enable */
  static const uint32_t A_TIMx_DIER_COMDE_MSK         = 0x00002000U;   /** @brief COM DMA request enable */
  static const uint32_t A_TIMx_DIER_UDE_MSK           = 0x00000100U;   /** @brief Update DMA request enable */
  static const uint32_t A_TIMx_DIER_TIE_MSK           = 0x00000040U;   /** @brief Trigger interrupt enable */
  static const uint32_t A_TIMx_DIER_UIE_MSK           = 0x00000001U;   /** @brief Update interrupt enable */
  static const uint32_t A_TIMx_DIER_BIE_MSK           = 0x00000080U;   /** @brief Break interrupt enable */
  static const uint32_t A_TIMx_DIER_COMIE_MSK         = 0x00000020U;   /** @brief COM interrupt enable */
  static const uint32_t A_TIMx_SR_SBIF_MSK            = 0x00002000U;   /** @brief System break interrupt flag */
  static const uint32_t A_TIMx_SR_B2IF_MSK            = 0x00000100U;   /** @brief Break 2 interrupt flag */
  static const uint32_t A_TIMx_SR_BIF_MSK             = 0x00000080U;   /** @brief Break interrupt flag */
  static const uint32_t A_TIMx_SR_TIF_MSK             = 0x00000040U;   /** @brief Trigger interrupt flag */
  static const uint32_t A_TIMx_SR_COMIF_MSK           = 0x00000020U;   /** @brief COM interrupt flag */
  static const uint32_t A_TIMx_SR_UIF_MSK             = 0x00000001U;   /** @brief Update interrupt flag */
  static const uint32_t A_TIMx_EGR_UG_MSK             = 0x00000001U;   /** @brief Update generation */
  static const uint32_t A_TIMx_EGR_COMG_MSK           = 0x00000020U;   /** @brief Capture/Compare control update generation */
  static const uint32_t A_TIMx_EGR_TG_MSK             = 0x00000040U;   /** @brief Trigger generation */
  static const uint32_t A_TIMx_EGR_BG_MSK             = 0x00000080U;   /** @brief Break generation */
  static const uint32_t A_TIMx_EGR_B2G_MSK            = 0x00000100U;   /** @brief Break 2 generation */
  static const uint32_t A_TIMx_CCMRx_INPUT_IC2PCS_MSK = 0x00000C00U;   /** @brief Input capture 2 prescaler */
  static const uint32_t A_TIMx_CCMRx_INPUT_ICPCS_MSK  = 0x0000000CU;   /** @brief Input capture 1 prescaler */
  static const uint32_t A_TIMx_CNT_CNT_MSK            = 0x0000FFFFU;   /** @brief Counter value */
  static const uint32_t A_TIMx_CNT_UIFCPY_MSK         = 0x80000000U;   /** @brief UIF copy */
  static const uint32_t A_TIMx_PSC_PSC_MSK            = 0x0000FFFFU;   /** @brief Prescaler value */
  static const uint32_t A_TIMx_ARR_ARR_MSK            = 0x0000FFFFU;   /** @brief Auto-reload value */
  static const uint32_t A_TIMx_CCRx_CCR1_MSK          = 0x0000FFFFU;   /** @brief Capture/Compare 1 value */
  static const uint32_t A_TIMx_DCR_DBL_MSK            = 0x00001F00U;   /** @brief DMA burst length */
  static const uint32_t A_TIMx_DCR_DBA_MSK            = 0x0000001FU;   /** @brief DMA base address */
  static const uint32_t A_TIMx_DMAR_DMAB_MSK          = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
  static const uint32_t A_TIMx_RCR_REP_MSK            = 0x000000FFU;   /** @brief Repetition counter value */
  static const uint32_t A_TIMx_BDTR_DTG_MSK           = 0x000000FFU;   /** @brief Dead-time generator setup */
  static const uint32_t A_TIMx_BDTR_LOCK_MSK          = 0x00000300U;   /** @brief Lock configuration */
  static const uint32_t A_TIMx_BDTR_OSSI_MSK          = 0x00000400U;   /** @brief Off-state selection for idle mode */
  static const uint32_t A_TIMx_BDTR_OSSR_MSK          = 0x00000800U;   /** @brief Off-state selection for run mode */
  static const uint32_t A_TIMx_BDTR_BKE_MSK           = 0x00001000U;   /** @brief Break enable */
  static const uint32_t A_TIMx_BDTR_BKP_MSK           = 0x00002000U;   /** @brief Break polarity */
  static const uint32_t A_TIMx_BDTR_AOE_MSK           = 0x00004000U;   /** @brief Automatic output enable */
  static const uint32_t A_TIMx_BDTR_MOE_MSK           = 0x00008000U;   /** @brief Main output enable */
  static const uint32_t A_TIMx_BDTR_BKF_MSK           = 0x000F0000U;   /** @brief Break filter */
  static const uint32_t A_TIMx_BDTR_BK2F_MSK          = 0x00F00000U;   /** @brief Break 2 filter */
  static const uint32_t A_TIMx_BDTR_BK2E_MSK          = 0x01000000U;   /** @brief Break 2 enable */
  static const uint32_t A_TIMx_BDTR_BK2P_MSK          = 0x02000000U;   /** @brief Break 2 polarity */
  static const uint32_t A_TIMx_CRR6_CCR6_MSK          = 0x0000FFFFU;   /** @brief Capture/Compare 6 value */
  static const uint32_t A_TIMx_AFx_BKINE_MSK          = 0x00000001U;   /** @brief BRK BKIN input enable */
  static const uint32_t A_TIMx_AFx_BKDF1BK0E_MSK      = 0x00000100U;   /** @brief BRK dfsdm1_break[0] enable */
  static const uint32_t A_TIMx_AFx_BKINP_MSK          = 0x00000200U;   /** @brief BRK BKIN input polarity */
  static const uint32_t A_TIMx_AFx_ETRSEL_MSK         = 0x0003C000U;   /** @brief ETR source selection */

  /**** @subsection Enumerated A_TIMx Register Field Masks ****/

  static const uint32_t A_TIMx_DIER_CCxDE_MSK[5] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
    [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
  };

  static const uint32_t A_TIMx_DIER_CCxIE_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
    [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
    [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
  };

  static const uint32_t A_TIMx_SR_CCxIF_MSK[7] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
    [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
    [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
    [5] = 0x00010000U,   /** @brief Compare 5 interrupt flag */
    [6] = 0x00020000U,   /** @brief Compare 6 interrupt flag */
  };

  static const uint32_t A_TIMx_SR_CCxOF_MSK[5] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
    [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
  };

  static const uint32_t A_TIMx_EGR_CCxG_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
    [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
    [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
    [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_CCxS_MSK[3] = {
    [1] = 0x00000003U,   /** @brief Capture/Compare 1 selection */
    [2] = 0x00000300U,   /** @brief Capture/Compare 2 selection */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxFE_MSK[3] = {
    [1] = 0x00000004U,   /** @brief Output compare 1 fast enable */
    [2] = 0x00000400U,   /** @brief Output compare 2 fast enable */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxPE_MSK[3] = {
    [1] = 0x00000008U,   /** @brief Output compare 1 preload enable */
    [2] = 0x00000800U,   /** @brief Output compare 2 preload enable */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxM_MSK[3] = {
    [1] = 0x00000070U,   /** @brief Output compare 1 mode */
    [2] = 0x00007000U,   /** @brief Output compare 2 mode */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxCE_MSK[3] = {
    [1] = 0x00000080U,   /** @brief Output compare 1 clear enable */
    [2] = 0x00008000U,   /** @brief Output compare 2 clear enable */
  };

  static const uint32_t A_TIMx_CCMRx_OUTPUT_OCxM_3_MSK[3] = {
    [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
    [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
  };

  static const uint32_t A_TIMx_CCMRx_INPUT_ICxF_MSK[3] = {
    [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
    [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
  };

  static const uint32_t A_TIMx_CCER_CCxE_MSK[7] = {
    [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
    [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
    [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
    [5] = 0x00010000U,   /** @brief Capture/Compare 5 output enable */
    [6] = 0x00100000U,   /** @brief Capture/Compare 6 output enable */
  };

  static const uint32_t A_TIMx_CCER_CCxP_MSK[7] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
    [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
    [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
    [5] = 0x00020000U,   /** @brief Capture/Compare 5 output polarity */
    [6] = 0x00200000U,   /** @brief Capture/Compare 6 output polarity */
  };

  static const uint32_t A_TIMx_CCER_CCxNE_MSK[4] = {
    [1] = 0x00000004U,   /** @brief Capture/Compare 1 complementary output enable */
    [2] = 0x00000040U,   /** @brief Capture/Compare 2 complementary output enable */
    [3] = 0x00000400U,   /** @brief Capture/Compare 3 complementary output enable */
  };

  static const uint32_t A_TIMx_CCER_CCxNP_MSK[5] = {
    [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
    [4] = 0x00008000U,   /** @brief Capture/Compare 4 complementary output polarity */
  };

  static const uint32_t A_TIMx_AFx_BKCMPxE_MSK[3] = {
    [1] = 0x00000002U,   /** @brief BRK COMP1 enable */
    [2] = 0x00000004U,   /** @brief BRK COMP2 enable */
  };

  static const uint32_t A_TIMx_AFx_BKCMPxP_MSK[3] = {
    [1] = 0x00000400U,   /** @brief BRK COMP1 input polarity */
    [2] = 0x00000800U,   /** @brief BRK COMP2 input polarity */
  };

  static const uint32_t A_TIMx_TISEL_TIxSEL_MSK[5] = {
    [1] = 0x0000000FU,   /** @brief Selects TI1[0] to TI1[15] input */
    [2] = 0x00000F00U,   /** @brief Selects TI2[0] to TI2[15] input */
    [3] = 0x000F0000U,   /** @brief Selects TI3[0] to TI3[15] input */
    [4] = 0x0F000000U,   /** @brief Selects TI4[0] to TI4[15] input */
  };

  /**** @subsection A_TIMx Register Field Positions ****/

  static const int32_t A_TIMx_CRx_CEN_POS            = 0;    /** @brief Counter enable */
  static const int32_t A_TIMx_CRx_UDIS_POS           = 1;    /** @brief Update disable */
  static const int32_t A_TIMx_CRx_URS_POS            = 2;    /** @brief Update request source */
  static const int32_t A_TIMx_CRx_OPM_POS            = 3;    /** @brief One-pulse mode */
  static const int32_t A_TIMx_CRx_DIR_POS            = 4;    /** @brief Direction */
  static const int32_t A_TIMx_CRx_CMS_POS            = 5;    /** @brief Center-aligned mode selection */
  static const int32_t A_TIMx_CRx_ARPE_POS           = 7;    /** @brief Auto-reload preload enable */
  static const int32_t A_TIMx_CRx_CKD_POS            = 8;    /** @brief Clock division */
  static const int32_t A_TIMx_CRx_UIFREMAP_POS       = 11;   /** @brief UIF status bit remapping */
  static const int32_t A_TIMx_SMCR_SMS_POS           = 0;    /** @brief Slave mode selection */
  static const int32_t A_TIMx_SMCR_TS_POS            = 4;    /** @brief Trigger selection */
  static const int32_t A_TIMx_SMCR_MSM_POS           = 7;    /** @brief Master/Slave mode */
  static const int32_t A_TIMx_SMCR_ETF_POS           = 8;    /** @brief External trigger filter */
  static const int32_t A_TIMx_SMCR_ETPS_POS          = 12;   /** @brief External trigger prescaler */
  static const int32_t A_TIMx_SMCR_ECE_POS           = 14;   /** @brief External clock enable */
  static const int32_t A_TIMx_SMCR_ETP_POS           = 15;   /** @brief External trigger polarity */
  static const int32_t A_TIMx_SMCR_SMS_3_POS         = 16;   /** @brief Slave mode selection - bit 3 */
  static const int32_t A_TIMx_SMCR_TS_4_3_POS        = 20;   /** @brief Trigger selection - bit 4:3 */
  static const int32_t A_TIMx_DIER_TDE_POS           = 14;   /** @brief Trigger DMA request enable */
  static const int32_t A_TIMx_DIER_COMDE_POS         = 13;   /** @brief COM DMA request enable */
  static const int32_t A_TIMx_DIER_UDE_POS           = 8;    /** @brief Update DMA request enable */
  static const int32_t A_TIMx_DIER_TIE_POS           = 6;    /** @brief Trigger interrupt enable */
  static const int32_t A_TIMx_DIER_UIE_POS           = 0;    /** @brief Update interrupt enable */
  static const int32_t A_TIMx_DIER_BIE_POS           = 7;    /** @brief Break interrupt enable */
  static const int32_t A_TIMx_DIER_COMIE_POS         = 5;    /** @brief COM interrupt enable */
  static const int32_t A_TIMx_SR_SBIF_POS            = 13;   /** @brief System break interrupt flag */
  static const int32_t A_TIMx_SR_B2IF_POS            = 8;    /** @brief Break 2 interrupt flag */
  static const int32_t A_TIMx_SR_BIF_POS             = 7;    /** @brief Break interrupt flag */
  static const int32_t A_TIMx_SR_TIF_POS             = 6;    /** @brief Trigger interrupt flag */
  static const int32_t A_TIMx_SR_COMIF_POS           = 5;    /** @brief COM interrupt flag */
  static const int32_t A_TIMx_SR_UIF_POS             = 0;    /** @brief Update interrupt flag */
  static const int32_t A_TIMx_EGR_UG_POS             = 0;    /** @brief Update generation */
  static const int32_t A_TIMx_EGR_COMG_POS           = 5;    /** @brief Capture/Compare control update generation */
  static const int32_t A_TIMx_EGR_TG_POS             = 6;    /** @brief Trigger generation */
  static const int32_t A_TIMx_EGR_BG_POS             = 7;    /** @brief Break generation */
  static const int32_t A_TIMx_EGR_B2G_POS            = 8;    /** @brief Break 2 generation */
  static const int32_t A_TIMx_CCMRx_INPUT_IC2PCS_POS = 10;   /** @brief Input capture 2 prescaler */
  static const int32_t A_TIMx_CCMRx_INPUT_ICPCS_POS  = 2;    /** @brief Input capture 1 prescaler */
  static const int32_t A_TIMx_CNT_CNT_POS            = 0;    /** @brief Counter value */
  static const int32_t A_TIMx_CNT_UIFCPY_POS         = 31;   /** @brief UIF copy */
  static const int32_t A_TIMx_PSC_PSC_POS            = 0;    /** @brief Prescaler value */
  static const int32_t A_TIMx_ARR_ARR_POS            = 0;    /** @brief Auto-reload value */
  static const int32_t A_TIMx_CCRx_CCR1_POS          = 0;    /** @brief Capture/Compare 1 value */
  static const int32_t A_TIMx_DCR_DBL_POS            = 8;    /** @brief DMA burst length */
  static const int32_t A_TIMx_DCR_DBA_POS            = 0;    /** @brief DMA base address */
  static const int32_t A_TIMx_DMAR_DMAB_POS          = 0;    /** @brief DMA register for burst accesses */
  static const int32_t A_TIMx_RCR_REP_POS            = 0;    /** @brief Repetition counter value */
  static const int32_t A_TIMx_BDTR_DTG_POS           = 0;    /** @brief Dead-time generator setup */
  static const int32_t A_TIMx_BDTR_LOCK_POS          = 8;    /** @brief Lock configuration */
  static const int32_t A_TIMx_BDTR_OSSI_POS          = 10;   /** @brief Off-state selection for idle mode */
  static const int32_t A_TIMx_BDTR_OSSR_POS          = 11;   /** @brief Off-state selection for run mode */
  static const int32_t A_TIMx_BDTR_BKE_POS           = 12;   /** @brief Break enable */
  static const int32_t A_TIMx_BDTR_BKP_POS           = 13;   /** @brief Break polarity */
  static const int32_t A_TIMx_BDTR_AOE_POS           = 14;   /** @brief Automatic output enable */
  static const int32_t A_TIMx_BDTR_MOE_POS           = 15;   /** @brief Main output enable */
  static const int32_t A_TIMx_BDTR_BKF_POS           = 16;   /** @brief Break filter */
  static const int32_t A_TIMx_BDTR_BK2F_POS          = 20;   /** @brief Break 2 filter */
  static const int32_t A_TIMx_BDTR_BK2E_POS          = 24;   /** @brief Break 2 enable */
  static const int32_t A_TIMx_BDTR_BK2P_POS          = 25;   /** @brief Break 2 polarity */
  static const int32_t A_TIMx_CRR6_CCR6_POS          = 0;    /** @brief Capture/Compare 6 value */
  static const int32_t A_TIMx_AFx_BKINE_POS          = 0;    /** @brief BRK BKIN input enable */
  static const int32_t A_TIMx_AFx_BKDF1BK0E_POS      = 8;    /** @brief BRK dfsdm1_break[0] enable */
  static const int32_t A_TIMx_AFx_BKINP_POS          = 9;    /** @brief BRK BKIN input polarity */
  static const int32_t A_TIMx_AFx_ETRSEL_POS         = 14;   /** @brief ETR source selection */

  /**** @subsection Enumerated A_TIMx Register Field Positions ****/

  static const int32_t A_TIMx_DIER_CCxDE_POS[5] = {
    [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
    [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
    [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
    [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
  };

  static const int32_t A_TIMx_DIER_CCxIE_POS[5] = {
    [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
    [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
    [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
  };

  static const int32_t A_TIMx_SR_CCxIF_POS[7] = {
    [1] = 1,    /** @brief Capture/compare 1 interrupt flag */
    [2] = 2,    /** @brief Capture/Compare 2 interrupt flag */
    [3] = 3,    /** @brief Capture/Compare 3 interrupt flag */
    [4] = 4,    /** @brief Capture/Compare 4 interrupt flag */
    [5] = 16,   /** @brief Compare 5 interrupt flag */
    [6] = 17,   /** @brief Compare 6 interrupt flag */
  };

  static const int32_t A_TIMx_SR_CCxOF_POS[5] = {
    [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
    [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
    [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
    [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
  };

  static const int32_t A_TIMx_EGR_CCxG_POS[5] = {
    [1] = 1,   /** @brief Capture/compare 1 generation */
    [2] = 2,   /** @brief Capture/compare 2 generation */
    [3] = 3,   /** @brief Capture/compare 3 generation */
    [4] = 4,   /** @brief Capture/compare 4 generation */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_CCxS_POS[3] = {
    [1] = 0,   /** @brief Capture/Compare 1 selection */
    [2] = 8,   /** @brief Capture/Compare 2 selection */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_OCxFE_POS[3] = {
    [1] = 2,    /** @brief Output compare 1 fast enable */
    [2] = 10,   /** @brief Output compare 2 fast enable */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_OCxPE_POS[3] = {
    [1] = 3,    /** @brief Output compare 1 preload enable */
    [2] = 11,   /** @brief Output compare 2 preload enable */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_OCxM_POS[3] = {
    [1] = 4,    /** @brief Output compare 1 mode */
    [2] = 12,   /** @brief Output compare 2 mode */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_OCxCE_POS[3] = {
    [1] = 7,    /** @brief Output compare 1 clear enable */
    [2] = 15,   /** @brief Output compare 2 clear enable */
  };

  static const int32_t A_TIMx_CCMRx_OUTPUT_OCxM_3_POS[3] = {
    [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
    [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
  };

  static const int32_t A_TIMx_CCMRx_INPUT_ICxF_POS[3] = {
    [1] = 4,    /** @brief Input capture 1 filter */
    [2] = 12,   /** @brief Input capture 2 filter */
  };

  static const int32_t A_TIMx_CCER_CCxE_POS[7] = {
    [1] = 0,    /** @brief Capture/Compare 1 output enable */
    [2] = 4,    /** @brief Capture/Compare 2 output enable */
    [3] = 8,    /** @brief Capture/Compare 3 output enable */
    [4] = 12,   /** @brief Capture/Compare 4 output enable */
    [5] = 16,   /** @brief Capture/Compare 5 output enable */
    [6] = 20,   /** @brief Capture/Compare 6 output enable */
  };

  static const int32_t A_TIMx_CCER_CCxP_POS[7] = {
    [1] = 1,    /** @brief Capture/Compare 1 output polarity */
    [2] = 5,    /** @brief Capture/Compare 2 output polarity */
    [3] = 9,    /** @brief Capture/Compare 3 output polarity */
    [4] = 13,   /** @brief Capture/Compare 3 output polarity */
    [5] = 17,   /** @brief Capture/Compare 5 output polarity */
    [6] = 21,   /** @brief Capture/Compare 6 output polarity */
  };

  static const int32_t A_TIMx_CCER_CCxNE_POS[4] = {
    [1] = 2,    /** @brief Capture/Compare 1 complementary output enable */
    [2] = 6,    /** @brief Capture/Compare 2 complementary output enable */
    [3] = 10,   /** @brief Capture/Compare 3 complementary output enable */
  };

  static const int32_t A_TIMx_CCER_CCxNP_POS[5] = {
    [1] = 3,    /** @brief Capture/Compare 1 output polarity */
    [2] = 7,    /** @brief Capture/Compare 2 output polarity */
    [3] = 11,   /** @brief Capture/Compare 3 output polarity */
    [4] = 15,   /** @brief Capture/Compare 4 complementary output polarity */
  };

  static const int32_t A_TIMx_AFx_BKCMPxE_POS[3] = {
    [1] = 1,   /** @brief BRK COMP1 enable */
    [2] = 2,   /** @brief BRK COMP2 enable */
  };

  static const int32_t A_TIMx_AFx_BKCMPxP_POS[3] = {
    [1] = 10,   /** @brief BRK COMP1 input polarity */
    [2] = 11,   /** @brief BRK COMP2 input polarity */
  };

  static const int32_t A_TIMx_TISEL_TIxSEL_POS[5] = {
    [1] = 0,    /** @brief Selects TI1[0] to TI1[15] input */
    [2] = 8,    /** @brief Selects TI2[0] to TI2[15] input */
    [3] = 16,   /** @brief Selects TI3[0] to TI3[15] input */
    [4] = 24,   /** @brief Selects TI4[0] to TI4[15] input */
  };

  /**********************************************************************************************
   * @section FDCANx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated FDCANx Register Pointers ****/

  static RO_ uint32_t* const FDCANx_FDCAN_CREL_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A000U,   /** @brief FDCAN core release register */
    [2] = (RO_ uint32_t* const)0x4000A400U,   /** @brief FDCAN core release register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_ENDN_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A004U,   /** @brief FDCAN core release register */
    [2] = (RO_ uint32_t* const)0x4000A404U,   /** @brief FDCAN core release register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_DBTP_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A00CU,   /** @brief FDCAN data bit timing and prescaler register */
    [2] = (RO_ uint32_t* const)0x4000A40CU,   /** @brief FDCAN data bit timing and prescaler register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TEST_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A010U,   /** @brief FDCAN test register */
    [2] = (RO_ uint32_t* const)0x4000A410U,   /** @brief FDCAN test register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_RWD_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A014U,   /** @brief FDCAN RAM watchdog register */
    [2] = (RO_ uint32_t* const)0x4000A414U,   /** @brief FDCAN RAM watchdog register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_CCCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A018U,   /** @brief FDCAN CC control register */
    [2] = (RW_ uint32_t* const)0x4000A418U,   /** @brief FDCAN CC control register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_NBTP_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A01CU,   /** @brief FDCAN nominal bit timing and prescaler register */
    [2] = (RW_ uint32_t* const)0x4000A41CU,   /** @brief FDCAN nominal bit timing and prescaler register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TSCC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A020U,   /** @brief FDCAN timestamp counter configuration register */
    [2] = (RW_ uint32_t* const)0x4000A420U,   /** @brief FDCAN timestamp counter configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TSCV_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A024U,   /** @brief FDCAN timestamp counter value register */
    [2] = (RW_ uint32_t* const)0x4000A424U,   /** @brief FDCAN timestamp counter value register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TOCC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A028U,   /** @brief FDCAN timeout counter configuration register */
    [2] = (RW_ uint32_t* const)0x4000A428U,   /** @brief FDCAN timeout counter configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TOCV_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A02CU,   /** @brief FDCAN timeout counter value register */
    [2] = (RW_ uint32_t* const)0x4000A42CU,   /** @brief FDCAN timeout counter value register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_ECR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A040U,   /** @brief FDCAN error counter register */
    [2] = (RW_ uint32_t* const)0x4000A440U,   /** @brief FDCAN error counter register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_PSR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A044U,   /** @brief FDCAN protocol status register */
    [2] = (RW_ uint32_t* const)0x4000A444U,   /** @brief FDCAN protocol status register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TDCR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A048U,   /** @brief FDCAN transmitter delay compensation register */
    [2] = (RO_ uint32_t* const)0x4000A448U,   /** @brief FDCAN transmitter delay compensation register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_IR_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A050U,   /** @brief FDCAN interrupt register */
    [2] = (RO_ uint32_t* const)0x4000A450U,   /** @brief FDCAN interrupt register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_IE_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A054U,   /** @brief FDCAN interrupt enable register */
    [2] = (RO_ uint32_t* const)0x4000A454U,   /** @brief FDCAN interrupt enable register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_ILS_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A058U,   /** @brief FDCAN interrupt line select register */
    [2] = (RO_ uint32_t* const)0x4000A458U,   /** @brief FDCAN interrupt line select register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_ILE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A05CU,   /** @brief FDCAN interrupt line enable register */
    [2] = (RW_ uint32_t* const)0x4000A45CU,   /** @brief FDCAN interrupt line enable register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_GFC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A080U,   /** @brief FDCAN global filter configuration register */
    [2] = (RW_ uint32_t* const)0x4000A480U,   /** @brief FDCAN global filter configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_SIDFC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A084U,   /** @brief FDCAN standard ID filter configuration register */
    [2] = (RW_ uint32_t* const)0x4000A484U,   /** @brief FDCAN standard ID filter configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_XIDFC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A088U,   /** @brief FDCAN extended ID filter configuration register */
    [2] = (RW_ uint32_t* const)0x4000A488U,   /** @brief FDCAN extended ID filter configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_XIDAM_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A090U,   /** @brief FDCAN extended ID and mask register */
    [2] = (RW_ uint32_t* const)0x4000A490U,   /** @brief FDCAN extended ID and mask register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_HPMS_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A094U,   /** @brief FDCAN high priority message status register */
    [2] = (RO_ uint32_t* const)0x4000A494U,   /** @brief FDCAN high priority message status register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_NDATx_PTR[3][3] = {
    [0] = {
      [1] = (RO_ uint32_t* const)0x4000A098U,   /** @brief FDCAN new data 1 register */
      [2] = (RO_ uint32_t* const)0x4000A09CU,   /** @brief FDCAN new data 2 register */
    },
    [1] = {
      [1] = (RO_ uint32_t* const)0x4000A498U,   /** @brief FDCAN new data 1 register */
      [2] = (RO_ uint32_t* const)0x4000A49CU,   /** @brief FDCAN new data 2 register */
    },
  };

  static RW_ uint32_t* const FDCANx_FDCAN_RXFxC_PTR[3][2] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x4000A0A0U,   /** @brief FDCAN rx FIFO 0 configuration register */
      [1] = (RW_ uint32_t* const)0x4000A0B0U,   /** @brief FDCAN rx FIFO 1 configuration register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x4000A4A0U,   /** @brief FDCAN rx FIFO 0 configuration register */
      [1] = (RW_ uint32_t* const)0x4000A4B0U,   /** @brief FDCAN rx FIFO 1 configuration register */
    },
  };

  static RW_ uint32_t* const FDCANx_FDCAN_RXFxS_PTR[3][2] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x4000A0A4U,   /** @brief FDCAN rx FIFO 0 status register */
      [1] = (RW_ uint32_t* const)0x4000A0B4U,   /** @brief FDCAN rx FIFO 1 status register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x4000A4A4U,   /** @brief FDCAN rx FIFO 0 status register */
      [1] = (RW_ uint32_t* const)0x4000A4B4U,   /** @brief FDCAN rx FIFO 1 status register */
    },
  };

  static RW_ uint32_t* const FDCANx_FDCAN_RXFxA_PTR[3][2] = {
    [0] = {
      [0] = (RW_ uint32_t* const)0x4000A0A8U,   /** @brief CAN rx FIFO 0 acknowledge register */
      [1] = (RW_ uint32_t* const)0x4000A0B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register */
    },
    [1] = {
      [0] = (RW_ uint32_t* const)0x4000A4A8U,   /** @brief CAN rx FIFO 0 acknowledge register */
      [1] = (RW_ uint32_t* const)0x4000A4B8U,   /** @brief FDCAN rx FIFO 1 acknowledge register */
    },
  };

  static RW_ uint32_t* const FDCANx_FDCAN_RXBC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0ACU,   /** @brief FDCAN rx buffer configuration register */
    [2] = (RW_ uint32_t* const)0x4000A4ACU,   /** @brief FDCAN rx buffer configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_RXESC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0BCU,   /** @brief FDCAN rx buffer element size configuration register */
    [2] = (RW_ uint32_t* const)0x4000A4BCU,   /** @brief FDCAN rx buffer element size configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0C0U,   /** @brief FDCAN tx buffer configuration register */
    [2] = (RW_ uint32_t* const)0x4000A4C0U,   /** @brief FDCAN tx buffer configuration register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TXFQS_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A0C4U,   /** @brief FDCAN tx fifo/queue status register */
    [2] = (RO_ uint32_t* const)0x4000A4C4U,   /** @brief FDCAN tx fifo/queue status register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXESC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0C8U,   /** @brief FDCAN tx buffer element size configuration register */
    [2] = (RW_ uint32_t* const)0x4000A4C8U,   /** @brief FDCAN tx buffer element size configuration register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TXBRP_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A0CCU,   /** @brief FDCAN tx buffer request pending register */
    [2] = (RO_ uint32_t* const)0x4000A4CCU,   /** @brief FDCAN tx buffer request pending register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBAR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0D0U,   /** @brief FDCAN tx buffer add request register */
    [2] = (RW_ uint32_t* const)0x4000A4D0U,   /** @brief FDCAN tx buffer add request register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBCR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0D4U,   /** @brief FDCAN tx buffer cancellation request register */
    [2] = (RW_ uint32_t* const)0x4000A4D4U,   /** @brief FDCAN tx buffer cancellation request register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBTO_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0D8U,   /** @brief FDCAN tx buffer transmission occurred register */
    [2] = (RW_ uint32_t* const)0x4000A4D8U,   /** @brief FDCAN tx buffer transmission occurred register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TXBCF_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A0DCU,   /** @brief FDCAN tx buffer cancellation finished register */
    [2] = (RO_ uint32_t* const)0x4000A4DCU,   /** @brief FDCAN tx buffer cancellation finished register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBTIE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
    [2] = (RW_ uint32_t* const)0x4000A4E0U,   /** @brief FDCAN tx buffer transmission interrupt enable register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXBCIE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
    [2] = (RW_ uint32_t* const)0x4000A4E4U,   /** @brief FDCAN tx buffer cancellation finished interrupt enable register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXEFC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0F0U,   /** @brief FDCAN tx event FIFO configuration register */
    [2] = (RW_ uint32_t* const)0x4000A4F0U,   /** @brief FDCAN tx event FIFO configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXEFS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0F4U,   /** @brief FDCAN tx event FIFO status register */
    [2] = (RW_ uint32_t* const)0x4000A4F4U,   /** @brief FDCAN tx event FIFO status register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TXEFA_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A0F8U,   /** @brief FDCAN tx event FIFO acknowledge register */
    [2] = (RW_ uint32_t* const)0x4000A4F8U,   /** @brief FDCAN tx event FIFO acknowledge register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTTMC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A100U,   /** @brief FDCAN TT trigger memory configuration register */
    [2] = (RW_ uint32_t* const)0x4000A500U,   /** @brief FDCAN TT trigger memory configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTRMC_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A104U,   /** @brief FDCAN TT reference message configuration register */
    [2] = (RW_ uint32_t* const)0x4000A504U,   /** @brief FDCAN TT reference message configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTOCF_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A108U,   /** @brief FDCAN TT operation configuration register */
    [2] = (RW_ uint32_t* const)0x4000A508U,   /** @brief FDCAN TT operation configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTMLM_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A10CU,   /** @brief FDCAN TT matrix limits register */
    [2] = (RW_ uint32_t* const)0x4000A50CU,   /** @brief FDCAN TT matrix limits register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TURCF_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A110U,   /** @brief FDCAN TUR configuration register */
    [2] = (RW_ uint32_t* const)0x4000A510U,   /** @brief FDCAN TUR configuration register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTOCN_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A114U,   /** @brief FDCAN TT operation control register */
    [2] = (RW_ uint32_t* const)0x4000A514U,   /** @brief FDCAN TT operation control register */
  };

  static RW_ uint32_t* const FDCANx_CAN_TTGTP_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A118U,   /** @brief FDCAN TT global time preset register */
    [2] = (RW_ uint32_t* const)0x4000A518U,   /** @brief FDCAN TT global time preset register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTTMK_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A11CU,   /** @brief FDCAN TT time mark register */
    [2] = (RW_ uint32_t* const)0x4000A51CU,   /** @brief FDCAN TT time mark register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTIR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A120U,   /** @brief FDCAN TT interrupt register */
    [2] = (RW_ uint32_t* const)0x4000A520U,   /** @brief FDCAN TT interrupt register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTIE_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A124U,   /** @brief FDCAN TT interrupt enable register */
    [2] = (RW_ uint32_t* const)0x4000A524U,   /** @brief FDCAN TT interrupt enable register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTILS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A128U,   /** @brief FDCAN TT interrupt line select register */
    [2] = (RW_ uint32_t* const)0x4000A528U,   /** @brief FDCAN TT interrupt line select register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTOST_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A12CU,   /** @brief FDCAN TT operation status register */
    [2] = (RW_ uint32_t* const)0x4000A52CU,   /** @brief FDCAN TT operation status register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TURNA_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A130U,   /** @brief FDCAN TUR numerator actual register */
    [2] = (RO_ uint32_t* const)0x4000A530U,   /** @brief FDCAN TUR numerator actual register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TTLGT_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A134U,   /** @brief FDCAN TT local and global time register */
    [2] = (RO_ uint32_t* const)0x4000A534U,   /** @brief FDCAN TT local and global time register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TTCTC_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A138U,   /** @brief FDCAN TT cycle time and count register */
    [2] = (RO_ uint32_t* const)0x4000A538U,   /** @brief FDCAN TT cycle time and count register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TTCPT_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A13CU,   /** @brief FDCAN TT capture time register */
    [2] = (RO_ uint32_t* const)0x4000A53CU,   /** @brief FDCAN TT capture time register */
  };

  static RO_ uint32_t* const FDCANx_FDCAN_TTCSM_PTR[3] = {
    [1] = (RO_ uint32_t* const)0x4000A140U,   /** @brief FDCAN TT cycle sync mark register */
    [2] = (RO_ uint32_t* const)0x4000A540U,   /** @brief FDCAN TT cycle sync mark register */
  };

  static RW_ uint32_t* const FDCANx_FDCAN_TTTS_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x4000A300U,   /** @brief FDCAN TT trigger select register */
    [2] = (RW_ uint32_t* const)0x4000A700U,   /** @brief FDCAN TT trigger select register */
  };

  /**** @subsection FDCANx Register Field Masks ****/

  static const uint32_t FDCANx_FDCAN_CREL_REL_MSK     = 0xF0000000U;   /** @brief Core release */
  static const uint32_t FDCANx_FDCAN_CREL_STEP_MSK    = 0x0F000000U;   /** @brief Step of core release */
  static const uint32_t FDCANx_FDCAN_CREL_SUBSTEP_MSK = 0x00F00000U;   /** @brief Sub-step of core release */
  static const uint32_t FDCANx_FDCAN_CREL_YEAR_MSK    = 0x000F0000U;   /** @brief Timestamp year */
  static const uint32_t FDCANx_FDCAN_CREL_MON_MSK     = 0x0000FF00U;   /** @brief Timestamp month */
  static const uint32_t FDCANx_FDCAN_CREL_DAY_MSK     = 0x000000FFU;   /** @brief Timestamp day */
  static const uint32_t FDCANx_FDCAN_DBTP_DSJW_MSK    = 0x0000000FU;   /** @brief Synchronization jump width */
  static const uint32_t FDCANx_FDCAN_DBTP_DBRP_MSK    = 0x001F0000U;   /** @brief Data bit rate prescaler */
  static const uint32_t FDCANx_FDCAN_DBTP_TDC_MSK     = 0x00800000U;   /** @brief Transceiver delay compensation */
  static const uint32_t FDCANx_FDCAN_TEST_LBCK_MSK    = 0x00000010U;   /** @brief Loop back mode */
  static const uint32_t FDCANx_FDCAN_TEST_TX_MSK      = 0x00000060U;   /** @brief Loop back mode */
  static const uint32_t FDCANx_FDCAN_TEST_RX_MSK      = 0x00000080U;   /** @brief Control of transmit pin */
  static const uint32_t FDCANx_FDCAN_RWD_WDV_MSK      = 0x0000FF00U;   /** @brief Watchdog value */
  static const uint32_t FDCANx_FDCAN_RWD_WDC_MSK      = 0x000000FFU;   /** @brief Watchdog configuration */
  static const uint32_t FDCANx_FDCAN_CCCR_INIT_MSK    = 0x00000001U;   /** @brief Initialization */
  static const uint32_t FDCANx_FDCAN_CCCR_CCE_MSK     = 0x00000002U;   /** @brief Configuration change enable */
  static const uint32_t FDCANx_FDCAN_CCCR_ASM_MSK     = 0x00000004U;   /** @brief ASM restricted operation mode */
  static const uint32_t FDCANx_FDCAN_CCCR_CSA_MSK     = 0x00000008U;   /** @brief Clock stop acknowledge */
  static const uint32_t FDCANx_FDCAN_CCCR_CSR_MSK     = 0x00000010U;   /** @brief Clock stop request */
  static const uint32_t FDCANx_FDCAN_CCCR_MON_MSK     = 0x00000020U;   /** @brief Bus monitoring mode */
  static const uint32_t FDCANx_FDCAN_CCCR_DAR_MSK     = 0x00000040U;   /** @brief Disable automatic retransmission */
  static const uint32_t FDCANx_FDCAN_CCCR_TEST_MSK    = 0x00000080U;   /** @brief Test mode enable */
  static const uint32_t FDCANx_FDCAN_CCCR_FDOE_MSK    = 0x00000100U;   /** @brief FD operation enable */
  static const uint32_t FDCANx_FDCAN_CCCR_BSE_MSK     = 0x00000200U;   /** @brief FDCAN bit rate switching */
  static const uint32_t FDCANx_FDCAN_CCCR_PXHD_MSK    = 0x00001000U;   /** @brief Protocol exception handling disable */
  static const uint32_t FDCANx_FDCAN_CCCR_EFBI_MSK    = 0x00002000U;   /** @brief Edge filtering during bus integration */
  static const uint32_t FDCANx_FDCAN_CCCR_TXP_MSK     = 0x00004000U;   /** @brief TXP */
  static const uint32_t FDCANx_FDCAN_CCCR_NISO_MSK    = 0x00008000U;   /** @brief Non ISO operation */
  static const uint32_t FDCANx_FDCAN_NBTP_NSJW_MSK    = 0xFE000000U;   /** @brief NSJW: nominal (re)synchronization jump width */
  static const uint32_t FDCANx_FDCAN_NBTP_NBRP_MSK    = 0x01FF0000U;   /** @brief Bit rate prescaler */
  static const uint32_t FDCANx_FDCAN_NBTP_NTSEG1_MSK  = 0x0000FF00U;   /** @brief Nominal time segment before sample point */
  static const uint32_t FDCANx_FDCAN_NBTP_TSEG2_MSK   = 0x0000007FU;   /** @brief Nominal time segment after sample point */
  static const uint32_t FDCANx_FDCAN_TSCC_TCP_MSK     = 0x000F0000U;   /** @brief Timestamp counter prescaler */
  static const uint32_t FDCANx_FDCAN_TSCC_TSS_MSK     = 0x00000003U;   /** @brief Timestamp select */
  static const uint32_t FDCANx_FDCAN_TSCV_TSC_MSK     = 0x0000FFFFU;   /** @brief Timestamp counter */
  static const uint32_t FDCANx_FDCAN_TOCC_ETOC_MSK    = 0x00000001U;   /** @brief Enable timeout counter */
  static const uint32_t FDCANx_FDCAN_TOCC_TOS_MSK     = 0x00000006U;   /** @brief Timeout select */
  static const uint32_t FDCANx_FDCAN_TOCC_TOP_MSK     = 0xFFFF0000U;   /** @brief Timeout period */
  static const uint32_t FDCANx_FDCAN_TOCV_TOC_MSK     = 0x0000FFFFU;   /** @brief Timeout counter */
  static const uint32_t FDCANx_FDCAN_ECR_CEL_MSK      = 0x00FF0000U;   /** @brief AN error logging */
  static const uint32_t FDCANx_FDCAN_ECR_RP_MSK       = 0x00008000U;   /** @brief Receive error passive */
  static const uint32_t FDCANx_FDCAN_ECR_TREC_MSK     = 0x00007F00U;   /** @brief Receive error counter */
  static const uint32_t FDCANx_FDCAN_ECR_TEC_MSK      = 0x000000FFU;   /** @brief Transmit error counter */
  static const uint32_t FDCANx_FDCAN_PSR_LEC_MSK      = 0x00000007U;   /** @brief Last error code */
  static const uint32_t FDCANx_FDCAN_PSR_ACT_MSK      = 0x00000018U;   /** @brief Activity */
  static const uint32_t FDCANx_FDCAN_PSR_EP_MSK       = 0x00000020U;   /** @brief Error passive */
  static const uint32_t FDCANx_FDCAN_PSR_EW_MSK       = 0x00000040U;   /** @brief Warning status */
  static const uint32_t FDCANx_FDCAN_PSR_BO_MSK       = 0x00000080U;   /** @brief Bus_Off status */
  static const uint32_t FDCANx_FDCAN_PSR_DLEC_MSK     = 0x00000700U;   /** @brief Data last error code */
  static const uint32_t FDCANx_FDCAN_PSR_RESI_MSK     = 0x00000800U;   /** @brief ESI flag of last received FDCAN message */
  static const uint32_t FDCANx_FDCAN_PSR_RBRS_MSK     = 0x00001000U;   /** @brief BRS flag of last received FDCAN message */
  static const uint32_t FDCANx_FDCAN_PSR_REDL_MSK     = 0x00002000U;   /** @brief Received FDCAN message */
  static const uint32_t FDCANx_FDCAN_PSR_PXE_MSK      = 0x00004000U;   /** @brief Protocol exception event */
  static const uint32_t FDCANx_FDCAN_PSR_TDCV_MSK     = 0x007F0000U;   /** @brief Transmitter delay compensation value */
  static const uint32_t FDCANx_FDCAN_TDCR_TDCF_MSK    = 0x0000007FU;   /** @brief Transmitter delay compensation filter window length */
  static const uint32_t FDCANx_FDCAN_TDCR_TDCO_MSK    = 0x00007F00U;   /** @brief Transmitter delay compensation offset */
  static const uint32_t FDCANx_FDCAN_IR_HPM_MSK       = 0x00000100U;   /** @brief High priority message */
  static const uint32_t FDCANx_FDCAN_IR_TC_MSK        = 0x00000200U;   /** @brief Transmission completed */
  static const uint32_t FDCANx_FDCAN_IR_TCF_MSK       = 0x00000400U;   /** @brief Transmission cancellation finished */
  static const uint32_t FDCANx_FDCAN_IR_TEF_MSK       = 0x00000800U;   /** @brief Tx FIFO empty */
  static const uint32_t FDCANx_FDCAN_IR_TEFN_MSK      = 0x00001000U;   /** @brief Tx event FIFO new entry */
  static const uint32_t FDCANx_FDCAN_IR_TEFW_MSK      = 0x00002000U;   /** @brief Tx event FIFO watermark reached */
  static const uint32_t FDCANx_FDCAN_IR_TEFF_MSK      = 0x00004000U;   /** @brief Tx event FIFO full */
  static const uint32_t FDCANx_FDCAN_IR_TEFL_MSK      = 0x00008000U;   /** @brief Tx event FIFO element lost */
  static const uint32_t FDCANx_FDCAN_IR_TSW_MSK       = 0x00010000U;   /** @brief Timestamp wraparound */
  static const uint32_t FDCANx_FDCAN_IR_MRAF_MSK      = 0x00020000U;   /** @brief Message RAM access failure */
  static const uint32_t FDCANx_FDCAN_IR_TOO_MSK       = 0x00040000U;   /** @brief Timeout occurred */
  static const uint32_t FDCANx_FDCAN_IR_DRX_MSK       = 0x00080000U;   /** @brief Message stored to dedicated rx buffer */
  static const uint32_t FDCANx_FDCAN_IR_ELO_MSK       = 0x00400000U;   /** @brief Error logging overflow */
  static const uint32_t FDCANx_FDCAN_IR_EP_MSK        = 0x00800000U;   /** @brief Error passive */
  static const uint32_t FDCANx_FDCAN_IR_EW_MSK        = 0x01000000U;   /** @brief Warning status */
  static const uint32_t FDCANx_FDCAN_IR_BO_MSK        = 0x02000000U;   /** @brief Bus_Off status */
  static const uint32_t FDCANx_FDCAN_IR_WDI_MSK       = 0x04000000U;   /** @brief Watchdog interrupt */
  static const uint32_t FDCANx_FDCAN_IR_PEA_MSK       = 0x08000000U;   /** @brief Protocol error in arbitration phase (nominal bit time is used) */
  static const uint32_t FDCANx_FDCAN_IR_PED_MSK       = 0x10000000U;   /** @brief Protocol error in data phase (data bit time is used) */
  static const uint32_t FDCANx_FDCAN_IR_ARA_MSK       = 0x20000000U;   /** @brief Access to reserved address */
  static const uint32_t FDCANx_FDCAN_IE_HPME_MSK      = 0x00000100U;   /** @brief High priority message enable */
  static const uint32_t FDCANx_FDCAN_IE_TCE_MSK       = 0x00000200U;   /** @brief Transmission completed enable */
  static const uint32_t FDCANx_FDCAN_IE_TCFE_MSK      = 0x00000400U;   /** @brief Transmission cancellation finished enable */
  static const uint32_t FDCANx_FDCAN_IE_TEFE_MSK      = 0x00000800U;   /** @brief Tx FIFO empty enable */
  static const uint32_t FDCANx_FDCAN_IE_TEFNE_MSK     = 0x00001000U;   /** @brief Tx event FIFO new entry enable */
  static const uint32_t FDCANx_FDCAN_IE_TEFWE_MSK     = 0x00002000U;   /** @brief Tx event FIFO watermark reached enable */
  static const uint32_t FDCANx_FDCAN_IE_TEFFE_MSK     = 0x00004000U;   /** @brief Tx event FIFO full enable */
  static const uint32_t FDCANx_FDCAN_IE_TEFLE_MSK     = 0x00008000U;   /** @brief Tx event FIFO element lost enable */
  static const uint32_t FDCANx_FDCAN_IE_TSWE_MSK      = 0x00010000U;   /** @brief Timestamp wraparound enable */
  static const uint32_t FDCANx_FDCAN_IE_MRAFE_MSK     = 0x00020000U;   /** @brief Message RAM access failure enable */
  static const uint32_t FDCANx_FDCAN_IE_TOOE_MSK      = 0x00040000U;   /** @brief Timeout occurred enable */
  static const uint32_t FDCANx_FDCAN_IE_DRXE_MSK      = 0x00080000U;   /** @brief Message stored to dedicated rx buffer enable */
  static const uint32_t FDCANx_FDCAN_IE_BECE_MSK      = 0x00100000U;   /** @brief Bit error corrected interrupt enable */
  static const uint32_t FDCANx_FDCAN_IE_BEUE_MSK      = 0x00200000U;   /** @brief Bit error uncorrected interrupt enable */
  static const uint32_t FDCANx_FDCAN_IE_ELOE_MSK      = 0x00400000U;   /** @brief Error logging overflow enable */
  static const uint32_t FDCANx_FDCAN_IE_EPE_MSK       = 0x00800000U;   /** @brief Error passive enable */
  static const uint32_t FDCANx_FDCAN_IE_EWE_MSK       = 0x01000000U;   /** @brief Warning status enable */
  static const uint32_t FDCANx_FDCAN_IE_BOE_MSK       = 0x02000000U;   /** @brief Bus_Off status enable */
  static const uint32_t FDCANx_FDCAN_IE_WDIE_MSK      = 0x04000000U;   /** @brief Watchdog interrupt enable */
  static const uint32_t FDCANx_FDCAN_IE_PEAE_MSK      = 0x08000000U;   /** @brief Protocol error in arbitration phase enable */
  static const uint32_t FDCANx_FDCAN_IE_PEDE_MSK      = 0x10000000U;   /** @brief Protocol error in data phase enable */
  static const uint32_t FDCANx_FDCAN_IE_ARAE_MSK      = 0x20000000U;   /** @brief Access to reserved address enable */
  static const uint32_t FDCANx_FDCAN_ILS_HPML_MSK     = 0x00000100U;   /** @brief High priority message interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TCL_MSK      = 0x00000200U;   /** @brief Transmission completed interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TCFL_MSK     = 0x00000400U;   /** @brief Transmission cancellation finished interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TEFL_MSK     = 0x00000800U;   /** @brief Tx FIFO empty interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TEFNL_MSK    = 0x00001000U;   /** @brief Tx event FIFO new entry interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TEFWL_MSK    = 0x00002000U;   /** @brief Tx event FIFO watermark reached interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TEFFL_MSK    = 0x00004000U;   /** @brief Tx event FIFO full interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TEFLL_MSK    = 0x00008000U;   /** @brief Tx event FIFO element lost interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TSWL_MSK     = 0x00010000U;   /** @brief Timestamp wraparound interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_MRAFL_MSK    = 0x00020000U;   /** @brief Message RAM access failure interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_TOOL_MSK     = 0x00040000U;   /** @brief Timeout occurred interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_DRXL_MSK     = 0x00080000U;   /** @brief Message stored to dedicated rx buffer interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_BECL_MSK     = 0x00100000U;   /** @brief Bit error corrected interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_BEUL_MSK     = 0x00200000U;   /** @brief Bit error uncorrected interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_ELOL_MSK     = 0x00400000U;   /** @brief Error logging overflow interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_EPL_MSK      = 0x00800000U;   /** @brief Error passive interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_EWL_MSK      = 0x01000000U;   /** @brief Warning status interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_BOL_MSK      = 0x02000000U;   /** @brief Bus_Off status */
  static const uint32_t FDCANx_FDCAN_ILS_WDIL_MSK     = 0x04000000U;   /** @brief Watchdog interrupt line */
  static const uint32_t FDCANx_FDCAN_ILS_PEAL_MSK     = 0x08000000U;   /** @brief Protocol error in arbitration phase line */
  static const uint32_t FDCANx_FDCAN_ILS_PEDL_MSK     = 0x10000000U;   /** @brief Protocol error in data phase line */
  static const uint32_t FDCANx_FDCAN_ILS_ARAL_MSK     = 0x20000000U;   /** @brief Access to reserved address line */
  static const uint32_t FDCANx_FDCAN_GFC_RRFE_MSK     = 0x00000001U;   /** @brief Reject remote frames extended */
  static const uint32_t FDCANx_FDCAN_GFC_RRFS_MSK     = 0x00000002U;   /** @brief Reject remote frames standard */
  static const uint32_t FDCANx_FDCAN_GFC_ANFE_MSK     = 0x0000000CU;   /** @brief Accept non-matching frames extended */
  static const uint32_t FDCANx_FDCAN_GFC_ANFS_MSK     = 0x00000030U;   /** @brief Accept non-matching frames standard */
  static const uint32_t FDCANx_FDCAN_SIDFC_FLSSA_MSK  = 0x0000FFFCU;   /** @brief Filter list standard start address */
  static const uint32_t FDCANx_FDCAN_SIDFC_LSS_MSK    = 0x00FF0000U;   /** @brief List size standard */
  static const uint32_t FDCANx_FDCAN_XIDFC_FLESA_MSK  = 0x0000FFFCU;   /** @brief Filter list standard start address */
  static const uint32_t FDCANx_FDCAN_XIDFC_LSE_MSK    = 0x00FF0000U;   /** @brief List size extended */
  static const uint32_t FDCANx_FDCAN_XIDAM_EIDM_MSK   = 0x1FFFFFFFU;   /** @brief Extended ID mask */
  static const uint32_t FDCANx_FDCAN_HPMS_BIDX_MSK    = 0x0000003FU;   /** @brief Buffer index */
  static const uint32_t FDCANx_FDCAN_HPMS_MSI_MSK     = 0x000000C0U;   /** @brief Message storage indicator */
  static const uint32_t FDCANx_FDCAN_HPMS_FIDX_MSK    = 0x00007F00U;   /** @brief Filter index */
  static const uint32_t FDCANx_FDCAN_HPMS_FLST_MSK    = 0x00008000U;   /** @brief Filter list */
  static const uint32_t FDCANx_FDCAN_RXFxC_F0SA_MSK   = 0x0000FFFCU;   /** @brief Rx FIFO 0 start address */
  static const uint32_t FDCANx_FDCAN_RXFxC_F0S_MSK    = 0x00FF0000U;   /** @brief Rx FIFO 0 size */
  static const uint32_t FDCANx_FDCAN_RXFxC_F0WM_MSK   = 0xFF000000U;   /** @brief FIFO 0 watermark */
  static const uint32_t FDCANx_FDCAN_RXFxS_F0FL_MSK   = 0x0000007FU;   /** @brief Rx FIFO 0 fill level */
  static const uint32_t FDCANx_FDCAN_RXFxS_F0G_MSK    = 0x00003F00U;   /** @brief Rx FIFO 0 get index */
  static const uint32_t FDCANx_FDCAN_RXFxS_F0P_MSK    = 0x003F0000U;   /** @brief Rx FIFO 0 put index */
  static const uint32_t FDCANx_FDCAN_RXFxS_F0F_MSK    = 0x01000000U;   /** @brief Rx FIFO 0 full */
  static const uint32_t FDCANx_FDCAN_RXFxS_RF0L_MSK   = 0x02000000U;   /** @brief Rx FIFO 0 message lost */
  static const uint32_t FDCANx_FDCAN_RXFxA_FA01_MSK   = 0x0000003FU;   /** @brief Rx FIFO 0 acknowledge index */
  static const uint32_t FDCANx_FDCAN_RXBC_RBSA_MSK    = 0x0000FFFCU;   /** @brief Rx buffer start address */
  static const uint32_t FDCANx_FDCAN_RXESC_RBDS_MSK   = 0x00000700U;   /** @brief Rx buffer data field size: */
  static const uint32_t FDCANx_FDCAN_TXBC_TBSA_MSK    = 0x0000FFFCU;   /** @brief Tx buffers start address */
  static const uint32_t FDCANx_FDCAN_TXBC_NDTB_MSK    = 0x003F0000U;   /** @brief Number of dedicated transmit buffers */
  static const uint32_t FDCANx_FDCAN_TXBC_TFQS_MSK    = 0x3F000000U;   /** @brief Transmit fifo/queue size */
  static const uint32_t FDCANx_FDCAN_TXBC_TFQM_MSK    = 0x40000000U;   /** @brief Tx fifo/queue mode */
  static const uint32_t FDCANx_FDCAN_TXFQS_TFFL_MSK   = 0x0000003FU;   /** @brief Tx FIFO free level */
  static const uint32_t FDCANx_FDCAN_TXFQS_TFGI_MSK   = 0x00001F00U;   /** @brief TFGI */
  static const uint32_t FDCANx_FDCAN_TXFQS_TFQPI_MSK  = 0x001F0000U;   /** @brief Tx fifo/queue put index */
  static const uint32_t FDCANx_FDCAN_TXFQS_TFQF_MSK   = 0x00200000U;   /** @brief Tx fifo/queue full */
  static const uint32_t FDCANx_FDCAN_TXESC_TBDS_MSK   = 0x00000007U;   /** @brief Tx buffer data field size: */
  static const uint32_t FDCANx_FDCAN_TXEFC_EFSA_MSK   = 0x0000FFFCU;   /** @brief Event FIFO start address */
  static const uint32_t FDCANx_FDCAN_TXEFC_EFS_MSK    = 0x003F0000U;   /** @brief Event FIFO size */
  static const uint32_t FDCANx_FDCAN_TXEFC_EFWM_MSK   = 0x3F000000U;   /** @brief Event FIFO watermark */
  static const uint32_t FDCANx_FDCAN_TXEFS_EFFL_MSK   = 0x0000003FU;   /** @brief Event FIFO fill level */
  static const uint32_t FDCANx_FDCAN_TXEFS_EFGI_MSK   = 0x00001F00U;   /** @brief Event FIFO get index. */
  static const uint32_t FDCANx_FDCAN_TXEFS_EFF_MSK    = 0x01000000U;   /** @brief Event FIFO full. */
  static const uint32_t FDCANx_FDCAN_TXEFS_TEFL_MSK   = 0x02000000U;   /** @brief Tx event FIFO element lost. */
  static const uint32_t FDCANx_FDCAN_TXEFA_EFAI_MSK   = 0x0000001FU;   /** @brief Event FIFO acknowledge index */
  static const uint32_t FDCANx_FDCAN_TTTMC_TMSA_MSK   = 0x0000FFFCU;   /** @brief Trigger memory start address */
  static const uint32_t FDCANx_FDCAN_TTTMC_TME_MSK    = 0x007F0000U;   /** @brief Trigger memory elements */
  static const uint32_t FDCANx_FDCAN_TTRMC_RID_MSK    = 0x1FFFFFFFU;   /** @brief Reference identifier. */
  static const uint32_t FDCANx_FDCAN_TTRMC_XTD_MSK    = 0x40000000U;   /** @brief Extended identifier */
  static const uint32_t FDCANx_FDCAN_TTRMC_RMPS_MSK   = 0x80000000U;   /** @brief Reference message payload select */
  static const uint32_t FDCANx_FDCAN_TTOCF_OM_MSK     = 0x00000003U;   /** @brief Operation mode */
  static const uint32_t FDCANx_FDCAN_TTOCF_GEN_MSK    = 0x00000008U;   /** @brief Gap enable */
  static const uint32_t FDCANx_FDCAN_TTOCF_TM_MSK     = 0x00000010U;   /** @brief Time master */
  static const uint32_t FDCANx_FDCAN_TTOCF_LDSDL_MSK  = 0x000000E0U;   /** @brief LD of synchronization deviation limit */
  static const uint32_t FDCANx_FDCAN_TTOCF_IRTO_MSK   = 0x00007F00U;   /** @brief Initial reference trigger offset */
  static const uint32_t FDCANx_FDCAN_TTOCF_EECS_MSK   = 0x00008000U;   /** @brief Enable external clock synchronization */
  static const uint32_t FDCANx_FDCAN_TTOCF_AWL_MSK    = 0x00FF0000U;   /** @brief Application watchdog limit */
  static const uint32_t FDCANx_FDCAN_TTOCF_EGTF_MSK   = 0x01000000U;   /** @brief Enable global time filtering */
  static const uint32_t FDCANx_FDCAN_TTOCF_ECC_MSK    = 0x02000000U;   /** @brief Enable clock calibration */
  static const uint32_t FDCANx_FDCAN_TTOCF_EVTP_MSK   = 0x04000000U;   /** @brief Event trigger polarity */
  static const uint32_t FDCANx_FDCAN_TTMLM_CCM_MSK    = 0x0000003FU;   /** @brief Cycle count max */
  static const uint32_t FDCANx_FDCAN_TTMLM_CSS_MSK    = 0x000000C0U;   /** @brief Cycle start synchronization */
  static const uint32_t FDCANx_FDCAN_TTMLM_TXEW_MSK   = 0x00000F00U;   /** @brief Tx enable window */
  static const uint32_t FDCANx_FDCAN_TTMLM_ENTT_MSK   = 0x0FFF0000U;   /** @brief Expected number of tx triggers */
  static const uint32_t FDCANx_FDCAN_TURCF_NCL_MSK    = 0x0000FFFFU;   /** @brief Numerator configuration low. */
  static const uint32_t FDCANx_FDCAN_TURCF_DC_MSK     = 0x3FFF0000U;   /** @brief Denominator configuration. */
  static const uint32_t FDCANx_FDCAN_TURCF_ELT_MSK    = 0x80000000U;   /** @brief Enable local time */
  static const uint32_t FDCANx_FDCAN_TTOCN_SGT_MSK    = 0x00000001U;   /** @brief Set global time */
  static const uint32_t FDCANx_FDCAN_TTOCN_ECS_MSK    = 0x00000002U;   /** @brief External clock synchronization */
  static const uint32_t FDCANx_FDCAN_TTOCN_SWP_MSK    = 0x00000004U;   /** @brief Stop watch polarity */
  static const uint32_t FDCANx_FDCAN_TTOCN_SWS_MSK    = 0x00000018U;   /** @brief Stop watch source. */
  static const uint32_t FDCANx_FDCAN_TTOCN_RTIE_MSK   = 0x00000020U;   /** @brief Register time mark interrupt pulse enable */
  static const uint32_t FDCANx_FDCAN_TTOCN_TMC_MSK    = 0x000000C0U;   /** @brief Register time mark compare */
  static const uint32_t FDCANx_FDCAN_TTOCN_TTIE_MSK   = 0x00000100U;   /** @brief Trigger time mark interrupt pulse enable */
  static const uint32_t FDCANx_FDCAN_TTOCN_GCS_MSK    = 0x00000200U;   /** @brief Gap control select */
  static const uint32_t FDCANx_FDCAN_TTOCN_FGP_MSK    = 0x00000400U;   /** @brief Finish gap. */
  static const uint32_t FDCANx_FDCAN_TTOCN_TMG_MSK    = 0x00000800U;   /** @brief Time mark gap */
  static const uint32_t FDCANx_FDCAN_TTOCN_NIG_MSK    = 0x00001000U;   /** @brief Next is gap */
  static const uint32_t FDCANx_FDCAN_TTOCN_ESCN_MSK   = 0x00002000U;   /** @brief External synchronization control */
  static const uint32_t FDCANx_FDCAN_TTOCN_LCKC_MSK   = 0x00008000U;   /** @brief TT operation control register locked */
  static const uint32_t FDCANx_CAN_TTGTP_NCL_MSK      = 0x0000FFFFU;   /** @brief Time preset */
  static const uint32_t FDCANx_CAN_TTGTP_CTP_MSK      = 0xFFFF0000U;   /** @brief Cycle time target phase */
  static const uint32_t FDCANx_FDCAN_TTTMK_TM_MSK     = 0x0000FFFFU;   /** @brief Time mark */
  static const uint32_t FDCANx_FDCAN_TTTMK_TICC_MSK   = 0x007F0000U;   /** @brief Time mark cycle code */
  static const uint32_t FDCANx_FDCAN_TTTMK_LCKM_MSK   = 0x80000000U;   /** @brief TT time mark register locked */
  static const uint32_t FDCANx_FDCAN_TTIR_SBC_MSK     = 0x00000001U;   /** @brief Start of basic cycle */
  static const uint32_t FDCANx_FDCAN_TTIR_SMC_MSK     = 0x00000002U;   /** @brief Start of matrix cycle */
  static const uint32_t FDCANx_FDCAN_TTIR_CSM_MSK     = 0x00000004U;   /** @brief Change of synchronization mode */
  static const uint32_t FDCANx_FDCAN_TTIR_SOG_MSK     = 0x00000008U;   /** @brief Start of gap */
  static const uint32_t FDCANx_FDCAN_TTIR_RTMI_MSK    = 0x00000010U;   /** @brief Register time mark interrupt. */
  static const uint32_t FDCANx_FDCAN_TTIR_TTMI_MSK    = 0x00000020U;   /** @brief Trigger time mark event internal */
  static const uint32_t FDCANx_FDCAN_TTIR_SWE_MSK     = 0x00000040U;   /** @brief Stop watch event */
  static const uint32_t FDCANx_FDCAN_TTIR_GTW_MSK     = 0x00000080U;   /** @brief Global time wrap */
  static const uint32_t FDCANx_FDCAN_TTIR_GTD_MSK     = 0x00000100U;   /** @brief Global time discontinuity */
  static const uint32_t FDCANx_FDCAN_TTIR_GTE_MSK     = 0x00000200U;   /** @brief Global time error */
  static const uint32_t FDCANx_FDCAN_TTIR_TXU_MSK     = 0x00000400U;   /** @brief Tx count underflow */
  static const uint32_t FDCANx_FDCAN_TTIR_TXO_MSK     = 0x00000800U;   /** @brief Tx count overflow */
  static const uint32_t FDCANx_FDCAN_TTIR_ELC_MSK     = 0x00004000U;   /** @brief Error level changed. */
  static const uint32_t FDCANx_FDCAN_TTIR_IWTG_MSK    = 0x00008000U;   /** @brief Initialization watch trigger */
  static const uint32_t FDCANx_FDCAN_TTIR_WT_MSK      = 0x00010000U;   /** @brief Watch trigger */
  static const uint32_t FDCANx_FDCAN_TTIR_AW_MSK      = 0x00020000U;   /** @brief Application watchdog */
  static const uint32_t FDCANx_FDCAN_TTIR_CER_MSK     = 0x00040000U;   /** @brief Configuration error */
  static const uint32_t FDCANx_FDCAN_TTIE_SBCE_MSK    = 0x00000001U;   /** @brief Start of basic cycle interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_SMCE_MSK    = 0x00000002U;   /** @brief Start of matrix cycle interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_CSME_MSK    = 0x00000004U;   /** @brief Change of synchronization mode interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_SOGE_MSK    = 0x00000008U;   /** @brief Start of gap interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_RTMIE_MSK   = 0x00000010U;   /** @brief Register time mark interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_TTMIE_MSK   = 0x00000020U;   /** @brief Trigger time mark event internal interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_SWEE_MSK    = 0x00000040U;   /** @brief Stop watch event interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_GTWE_MSK    = 0x00000080U;   /** @brief Global time wrap interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_GTDE_MSK    = 0x00000100U;   /** @brief Global time discontinuity interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_GTEE_MSK    = 0x00000200U;   /** @brief Global time error interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_TXUE_MSK    = 0x00000400U;   /** @brief Tx count underflow interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_TXOE_MSK    = 0x00000800U;   /** @brief Tx count overflow interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_ELCE_MSK    = 0x00004000U;   /** @brief Change error level interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_IWTGE_MSK   = 0x00008000U;   /** @brief Initialization watch trigger interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_WTE_MSK     = 0x00010000U;   /** @brief Watch trigger interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_AWE_MSK     = 0x00020000U;   /** @brief Application watchdog interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTIE_CERE_MSK    = 0x00040000U;   /** @brief Configuration error interrupt enable */
  static const uint32_t FDCANx_FDCAN_TTILS_SBCL_MSK   = 0x00000001U;   /** @brief Start of basic cycle interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_SMCL_MSK   = 0x00000002U;   /** @brief Start of matrix cycle interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_CSML_MSK   = 0x00000004U;   /** @brief Change of synchronization mode interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_SOGL_MSK   = 0x00000008U;   /** @brief Start of gap interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_RTMIL_MSK  = 0x00000010U;   /** @brief Register time mark interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_TTMIL_MSK  = 0x00000020U;   /** @brief Trigger time mark event internal interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_SWEL_MSK   = 0x00000040U;   /** @brief Stop watch event interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_GTWL_MSK   = 0x00000080U;   /** @brief Global time wrap interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_GTDL_MSK   = 0x00000100U;   /** @brief Global time discontinuity interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_GTEL_MSK   = 0x00000200U;   /** @brief Global time error interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_TXUL_MSK   = 0x00000400U;   /** @brief Tx count underflow interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_TXOL_MSK   = 0x00000800U;   /** @brief Tx count overflow interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_ELCL_MSK   = 0x00004000U;   /** @brief Change error level interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_IWTGL_MSK  = 0x00008000U;   /** @brief Initialization watch trigger interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_WTL_MSK    = 0x00010000U;   /** @brief Watch trigger interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_AWL_MSK    = 0x00020000U;   /** @brief Application watchdog interrupt line */
  static const uint32_t FDCANx_FDCAN_TTILS_CERL_MSK   = 0x00040000U;   /** @brief Configuration error interrupt line */
  static const uint32_t FDCANx_FDCAN_TTOST_EL_MSK     = 0x00000003U;   /** @brief Error level */
  static const uint32_t FDCANx_FDCAN_TTOST_MS_MSK     = 0x0000000CU;   /** @brief Master state. */
  static const uint32_t FDCANx_FDCAN_TTOST_SYS_MSK    = 0x00000030U;   /** @brief Synchronization state */
  static const uint32_t FDCANx_FDCAN_TTOST_GTP_MSK    = 0x00000040U;   /** @brief Quality of global time phase */
  static const uint32_t FDCANx_FDCAN_TTOST_QCS_MSK    = 0x00000080U;   /** @brief Quality of clock speed */
  static const uint32_t FDCANx_FDCAN_TTOST_RTO_MSK    = 0x0000FF00U;   /** @brief Reference trigger offset */
  static const uint32_t FDCANx_FDCAN_TTOST_WGTD_MSK   = 0x00400000U;   /** @brief Wait for global time discontinuity */
  static const uint32_t FDCANx_FDCAN_TTOST_GFI_MSK    = 0x00800000U;   /** @brief Gap finished indicator. */
  static const uint32_t FDCANx_FDCAN_TTOST_TMP_MSK    = 0x07000000U;   /** @brief Time master priority */
  static const uint32_t FDCANx_FDCAN_TTOST_GSI_MSK    = 0x08000000U;   /** @brief Gap started indicator. */
  static const uint32_t FDCANx_FDCAN_TTOST_WFE_MSK    = 0x10000000U;   /** @brief Wait for event */
  static const uint32_t FDCANx_FDCAN_TTOST_AWE_MSK    = 0x20000000U;   /** @brief Application watchdog event */
  static const uint32_t FDCANx_FDCAN_TTOST_WECS_MSK   = 0x40000000U;   /** @brief Wait for external clock synchronization */
  static const uint32_t FDCANx_FDCAN_TTOST_SPL_MSK    = 0x80000000U;   /** @brief Schedule phase lock */
  static const uint32_t FDCANx_FDCAN_TURNA_NAV_MSK    = 0x0003FFFFU;   /** @brief Numerator actual value */
  static const uint32_t FDCANx_FDCAN_TTLGT_LT_MSK     = 0x0000FFFFU;   /** @brief Local time */
  static const uint32_t FDCANx_FDCAN_TTLGT_GT_MSK     = 0xFFFF0000U;   /** @brief Global time */
  static const uint32_t FDCANx_FDCAN_TTCTC_CT_MSK     = 0x0000FFFFU;   /** @brief Cycle time */
  static const uint32_t FDCANx_FDCAN_TTCTC_CC_MSK     = 0x003F0000U;   /** @brief Cycle count */
  static const uint32_t FDCANx_FDCAN_TTCPT_CT_MSK     = 0x0000003FU;   /** @brief Cycle count value */
  static const uint32_t FDCANx_FDCAN_TTCPT_SWV_MSK    = 0xFFFF0000U;   /** @brief Stop watch value */
  static const uint32_t FDCANx_FDCAN_TTCSM_CSM_MSK    = 0x0000FFFFU;   /** @brief Cycle sync mark */
  static const uint32_t FDCANx_FDCAN_TTTS_SWTDEL_MSK  = 0x00000003U;   /** @brief Stop watch trigger input selection */
  static const uint32_t FDCANx_FDCAN_TTTS_EVTSEL_MSK  = 0x00000030U;   /** @brief Event trigger input selection */

  /**** @subsection Enumerated FDCANx Register Field Masks ****/

  static const uint32_t FDCANx_FDCAN_DBTP_DTSEGx_MSK[3] = {
    [1] = 0x00001F00U,   /** @brief Data time segment after sample point */
    [2] = 0x000000F0U,   /** @brief Data time segment after sample point */
  };

  static const uint32_t FDCANx_FDCAN_IR_RFxN_MSK[2] = {
    [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message */
    [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message */
  };

  static const uint32_t FDCANx_FDCAN_IR_RFxW_MSK[2] = {
    [0] = 0x00000002U,   /** @brief Rx FIFO 0 full */
    [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached */
  };

  static const uint32_t FDCANx_FDCAN_IR_RFxF_MSK[2] = {
    [0] = 0x00000004U,   /** @brief Rx FIFO 0 full */
    [1] = 0x00000040U,   /** @brief Rx FIFO 1 watermark reached */
  };

  static const uint32_t FDCANx_FDCAN_IR_RFxL_MSK[2] = {
    [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost */
    [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost */
  };

  static const uint32_t FDCANx_FDCAN_IE_RFxNE_MSK[2] = {
    [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message enable */
    [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message enable */
  };

  static const uint32_t FDCANx_FDCAN_IE_RFxWE_MSK[2] = {
    [0] = 0x00000002U,   /** @brief Rx FIFO 0 full enable */
    [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached enable */
  };

  static const uint32_t FDCANx_FDCAN_IE_RFxFE_MSK[2] = {
    [0] = 0x00000004U,   /** @brief Rx FIFO 0 full enable */
    [1] = 0x00000040U,   /** @brief Rx FIFO 1 watermark reached enable */
  };

  static const uint32_t FDCANx_FDCAN_IE_RFxLE_MSK[2] = {
    [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost enable */
    [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost enable */
  };

  static const uint32_t FDCANx_FDCAN_ILS_RFxNL_MSK[2] = {
    [0] = 0x00000001U,   /** @brief Rx FIFO 0 new message interrupt line */
    [1] = 0x00000010U,   /** @brief Rx FIFO 1 new message interrupt line */
  };

  static const uint32_t FDCANx_FDCAN_ILS_RFxWL_MSK[2] = {
    [0] = 0x00000002U,   /** @brief Rx FIFO 0 watermark reached interrupt line */
    [1] = 0x00000020U,   /** @brief Rx FIFO 1 watermark reached interrupt line */
  };

  static const uint32_t FDCANx_FDCAN_ILS_RFxFL_MSK[2] = {
    [0] = 0x00000004U,   /** @brief Rx FIFO 0 full interrupt line */
    [1] = 0x00000040U,   /** @brief Rx FIFO 1 full interrupt line */
  };

  static const uint32_t FDCANx_FDCAN_ILS_RFxLL_MSK[2] = {
    [0] = 0x00000008U,   /** @brief Rx FIFO 0 message lost interrupt line */
    [1] = 0x00000080U,   /** @brief Rx FIFO 1 message lost interrupt line */
  };

  static const uint32_t FDCANx_FDCAN_ILE_EINTx_MSK[2] = {
    [0] = 0x00000001U,   /** @brief Enable interrupt line 0 */
    [1] = 0x00000002U,   /** @brief Enable interrupt line 1 */
  };

  static const uint32_t FDCANx_FDCAN_NDATx_NDx_MSK[32] = {
    [0]  = 0x00000001U,   /** @brief New data */
    [1]  = 0x00000002U,   /** @brief New data */
    [2]  = 0x00000004U,   /** @brief New data */
    [3]  = 0x00000008U,   /** @brief New data */
    [4]  = 0x00000010U,   /** @brief New data */
    [5]  = 0x00000020U,   /** @brief New data */
    [6]  = 0x00000040U,   /** @brief New data */
    [7]  = 0x00000080U,   /** @brief New data */
    [8]  = 0x00000100U,   /** @brief New data */
    [9]  = 0x00000200U,   /** @brief New data */
    [10] = 0x00000400U,   /** @brief New data */
    [11] = 0x00000800U,   /** @brief New data */
    [12] = 0x00001000U,   /** @brief New data */
    [13] = 0x00002000U,   /** @brief New data */
    [14] = 0x00004000U,   /** @brief New data */
    [15] = 0x00008000U,   /** @brief New data */
    [16] = 0x00010000U,   /** @brief New data */
    [17] = 0x00020000U,   /** @brief New data */
    [18] = 0x00040000U,   /** @brief New data */
    [19] = 0x00080000U,   /** @brief New data */
    [20] = 0x00100000U,   /** @brief New data */
    [21] = 0x00200000U,   /** @brief New data */
    [22] = 0x00400000U,   /** @brief New data */
    [23] = 0x00800000U,   /** @brief New data */
    [24] = 0x01000000U,   /** @brief New data */
    [25] = 0x02000000U,   /** @brief New data */
    [26] = 0x04000000U,   /** @brief New data */
    [27] = 0x08000000U,   /** @brief New data */
    [28] = 0x10000000U,   /** @brief New data */
    [29] = 0x20000000U,   /** @brief New data */
    [30] = 0x40000000U,   /** @brief New data */
    [31] = 0x80000000U,   /** @brief New data */
  };

  static const uint32_t FDCANx_FDCAN_RXESC_FxDS_MSK[2] = {
    [0] = 0x00000007U,   /** @brief Rx FIFO 1 data field size: */
    [1] = 0x00000070U,   /** @brief Rx FIFO 0 data field size: */
  };

  static const uint32_t FDCANx_FDCAN_TTIR_SEx_MSK[3] = {
    [1] = 0x00001000U,   /** @brief Scheduling error 1 */
    [2] = 0x00002000U,   /** @brief Scheduling error 2 */
  };

  static const uint32_t FDCANx_FDCAN_TTIE_SExE_MSK[3] = {
    [1] = 0x00001000U,   /** @brief Scheduling error 1 interrupt enable */
    [2] = 0x00002000U,   /** @brief Scheduling error 2 interrupt enable */
  };

  static const uint32_t FDCANx_FDCAN_TTILS_SExL_MSK[3] = {
    [1] = 0x00001000U,   /** @brief Scheduling error 1 interrupt line */
    [2] = 0x00002000U,   /** @brief Scheduling error 2 interrupt line */
  };

  /**** @subsection FDCANx Register Field Positions ****/

  static const int32_t FDCANx_FDCAN_CREL_REL_POS     = 28;   /** @brief Core release */
  static const int32_t FDCANx_FDCAN_CREL_STEP_POS    = 24;   /** @brief Step of core release */
  static const int32_t FDCANx_FDCAN_CREL_SUBSTEP_POS = 20;   /** @brief Sub-step of core release */
  static const int32_t FDCANx_FDCAN_CREL_YEAR_POS    = 16;   /** @brief Timestamp year */
  static const int32_t FDCANx_FDCAN_CREL_MON_POS     = 8;    /** @brief Timestamp month */
  static const int32_t FDCANx_FDCAN_CREL_DAY_POS     = 0;    /** @brief Timestamp day */
  static const int32_t FDCANx_FDCAN_DBTP_DSJW_POS    = 0;    /** @brief Synchronization jump width */
  static const int32_t FDCANx_FDCAN_DBTP_DBRP_POS    = 16;   /** @brief Data bit rate prescaler */
  static const int32_t FDCANx_FDCAN_DBTP_TDC_POS     = 23;   /** @brief Transceiver delay compensation */
  static const int32_t FDCANx_FDCAN_TEST_LBCK_POS    = 4;    /** @brief Loop back mode */
  static const int32_t FDCANx_FDCAN_TEST_TX_POS      = 5;    /** @brief Loop back mode */
  static const int32_t FDCANx_FDCAN_TEST_RX_POS      = 7;    /** @brief Control of transmit pin */
  static const int32_t FDCANx_FDCAN_RWD_WDV_POS      = 8;    /** @brief Watchdog value */
  static const int32_t FDCANx_FDCAN_RWD_WDC_POS      = 0;    /** @brief Watchdog configuration */
  static const int32_t FDCANx_FDCAN_CCCR_INIT_POS    = 0;    /** @brief Initialization */
  static const int32_t FDCANx_FDCAN_CCCR_CCE_POS     = 1;    /** @brief Configuration change enable */
  static const int32_t FDCANx_FDCAN_CCCR_ASM_POS     = 2;    /** @brief ASM restricted operation mode */
  static const int32_t FDCANx_FDCAN_CCCR_CSA_POS     = 3;    /** @brief Clock stop acknowledge */
  static const int32_t FDCANx_FDCAN_CCCR_CSR_POS     = 4;    /** @brief Clock stop request */
  static const int32_t FDCANx_FDCAN_CCCR_MON_POS     = 5;    /** @brief Bus monitoring mode */
  static const int32_t FDCANx_FDCAN_CCCR_DAR_POS     = 6;    /** @brief Disable automatic retransmission */
  static const int32_t FDCANx_FDCAN_CCCR_TEST_POS    = 7;    /** @brief Test mode enable */
  static const int32_t FDCANx_FDCAN_CCCR_FDOE_POS    = 8;    /** @brief FD operation enable */
  static const int32_t FDCANx_FDCAN_CCCR_BSE_POS     = 9;    /** @brief FDCAN bit rate switching */
  static const int32_t FDCANx_FDCAN_CCCR_PXHD_POS    = 12;   /** @brief Protocol exception handling disable */
  static const int32_t FDCANx_FDCAN_CCCR_EFBI_POS    = 13;   /** @brief Edge filtering during bus integration */
  static const int32_t FDCANx_FDCAN_CCCR_TXP_POS     = 14;   /** @brief TXP */
  static const int32_t FDCANx_FDCAN_CCCR_NISO_POS    = 15;   /** @brief Non ISO operation */
  static const int32_t FDCANx_FDCAN_NBTP_NSJW_POS    = 25;   /** @brief NSJW: nominal (re)synchronization jump width */
  static const int32_t FDCANx_FDCAN_NBTP_NBRP_POS    = 16;   /** @brief Bit rate prescaler */
  static const int32_t FDCANx_FDCAN_NBTP_NTSEG1_POS  = 8;    /** @brief Nominal time segment before sample point */
  static const int32_t FDCANx_FDCAN_NBTP_TSEG2_POS   = 0;    /** @brief Nominal time segment after sample point */
  static const int32_t FDCANx_FDCAN_TSCC_TCP_POS     = 16;   /** @brief Timestamp counter prescaler */
  static const int32_t FDCANx_FDCAN_TSCC_TSS_POS     = 0;    /** @brief Timestamp select */
  static const int32_t FDCANx_FDCAN_TSCV_TSC_POS     = 0;    /** @brief Timestamp counter */
  static const int32_t FDCANx_FDCAN_TOCC_ETOC_POS    = 0;    /** @brief Enable timeout counter */
  static const int32_t FDCANx_FDCAN_TOCC_TOS_POS     = 1;    /** @brief Timeout select */
  static const int32_t FDCANx_FDCAN_TOCC_TOP_POS     = 16;   /** @brief Timeout period */
  static const int32_t FDCANx_FDCAN_TOCV_TOC_POS     = 0;    /** @brief Timeout counter */
  static const int32_t FDCANx_FDCAN_ECR_CEL_POS      = 16;   /** @brief AN error logging */
  static const int32_t FDCANx_FDCAN_ECR_RP_POS       = 15;   /** @brief Receive error passive */
  static const int32_t FDCANx_FDCAN_ECR_TREC_POS     = 8;    /** @brief Receive error counter */
  static const int32_t FDCANx_FDCAN_ECR_TEC_POS      = 0;    /** @brief Transmit error counter */
  static const int32_t FDCANx_FDCAN_PSR_LEC_POS      = 0;    /** @brief Last error code */
  static const int32_t FDCANx_FDCAN_PSR_ACT_POS      = 3;    /** @brief Activity */
  static const int32_t FDCANx_FDCAN_PSR_EP_POS       = 5;    /** @brief Error passive */
  static const int32_t FDCANx_FDCAN_PSR_EW_POS       = 6;    /** @brief Warning status */
  static const int32_t FDCANx_FDCAN_PSR_BO_POS       = 7;    /** @brief Bus_Off status */
  static const int32_t FDCANx_FDCAN_PSR_DLEC_POS     = 8;    /** @brief Data last error code */
  static const int32_t FDCANx_FDCAN_PSR_RESI_POS     = 11;   /** @brief ESI flag of last received FDCAN message */
  static const int32_t FDCANx_FDCAN_PSR_RBRS_POS     = 12;   /** @brief BRS flag of last received FDCAN message */
  static const int32_t FDCANx_FDCAN_PSR_REDL_POS     = 13;   /** @brief Received FDCAN message */
  static const int32_t FDCANx_FDCAN_PSR_PXE_POS      = 14;   /** @brief Protocol exception event */
  static const int32_t FDCANx_FDCAN_PSR_TDCV_POS     = 16;   /** @brief Transmitter delay compensation value */
  static const int32_t FDCANx_FDCAN_TDCR_TDCF_POS    = 0;    /** @brief Transmitter delay compensation filter window length */
  static const int32_t FDCANx_FDCAN_TDCR_TDCO_POS    = 8;    /** @brief Transmitter delay compensation offset */
  static const int32_t FDCANx_FDCAN_IR_HPM_POS       = 8;    /** @brief High priority message */
  static const int32_t FDCANx_FDCAN_IR_TC_POS        = 9;    /** @brief Transmission completed */
  static const int32_t FDCANx_FDCAN_IR_TCF_POS       = 10;   /** @brief Transmission cancellation finished */
  static const int32_t FDCANx_FDCAN_IR_TEF_POS       = 11;   /** @brief Tx FIFO empty */
  static const int32_t FDCANx_FDCAN_IR_TEFN_POS      = 12;   /** @brief Tx event FIFO new entry */
  static const int32_t FDCANx_FDCAN_IR_TEFW_POS      = 13;   /** @brief Tx event FIFO watermark reached */
  static const int32_t FDCANx_FDCAN_IR_TEFF_POS      = 14;   /** @brief Tx event FIFO full */
  static const int32_t FDCANx_FDCAN_IR_TEFL_POS      = 15;   /** @brief Tx event FIFO element lost */
  static const int32_t FDCANx_FDCAN_IR_TSW_POS       = 16;   /** @brief Timestamp wraparound */
  static const int32_t FDCANx_FDCAN_IR_MRAF_POS      = 17;   /** @brief Message RAM access failure */
  static const int32_t FDCANx_FDCAN_IR_TOO_POS       = 18;   /** @brief Timeout occurred */
  static const int32_t FDCANx_FDCAN_IR_DRX_POS       = 19;   /** @brief Message stored to dedicated rx buffer */
  static const int32_t FDCANx_FDCAN_IR_ELO_POS       = 22;   /** @brief Error logging overflow */
  static const int32_t FDCANx_FDCAN_IR_EP_POS        = 23;   /** @brief Error passive */
  static const int32_t FDCANx_FDCAN_IR_EW_POS        = 24;   /** @brief Warning status */
  static const int32_t FDCANx_FDCAN_IR_BO_POS        = 25;   /** @brief Bus_Off status */
  static const int32_t FDCANx_FDCAN_IR_WDI_POS       = 26;   /** @brief Watchdog interrupt */
  static const int32_t FDCANx_FDCAN_IR_PEA_POS       = 27;   /** @brief Protocol error in arbitration phase (nominal bit time is used) */
  static const int32_t FDCANx_FDCAN_IR_PED_POS       = 28;   /** @brief Protocol error in data phase (data bit time is used) */
  static const int32_t FDCANx_FDCAN_IR_ARA_POS       = 29;   /** @brief Access to reserved address */
  static const int32_t FDCANx_FDCAN_IE_HPME_POS      = 8;    /** @brief High priority message enable */
  static const int32_t FDCANx_FDCAN_IE_TCE_POS       = 9;    /** @brief Transmission completed enable */
  static const int32_t FDCANx_FDCAN_IE_TCFE_POS      = 10;   /** @brief Transmission cancellation finished enable */
  static const int32_t FDCANx_FDCAN_IE_TEFE_POS      = 11;   /** @brief Tx FIFO empty enable */
  static const int32_t FDCANx_FDCAN_IE_TEFNE_POS     = 12;   /** @brief Tx event FIFO new entry enable */
  static const int32_t FDCANx_FDCAN_IE_TEFWE_POS     = 13;   /** @brief Tx event FIFO watermark reached enable */
  static const int32_t FDCANx_FDCAN_IE_TEFFE_POS     = 14;   /** @brief Tx event FIFO full enable */
  static const int32_t FDCANx_FDCAN_IE_TEFLE_POS     = 15;   /** @brief Tx event FIFO element lost enable */
  static const int32_t FDCANx_FDCAN_IE_TSWE_POS      = 16;   /** @brief Timestamp wraparound enable */
  static const int32_t FDCANx_FDCAN_IE_MRAFE_POS     = 17;   /** @brief Message RAM access failure enable */
  static const int32_t FDCANx_FDCAN_IE_TOOE_POS      = 18;   /** @brief Timeout occurred enable */
  static const int32_t FDCANx_FDCAN_IE_DRXE_POS      = 19;   /** @brief Message stored to dedicated rx buffer enable */
  static const int32_t FDCANx_FDCAN_IE_BECE_POS      = 20;   /** @brief Bit error corrected interrupt enable */
  static const int32_t FDCANx_FDCAN_IE_BEUE_POS      = 21;   /** @brief Bit error uncorrected interrupt enable */
  static const int32_t FDCANx_FDCAN_IE_ELOE_POS      = 22;   /** @brief Error logging overflow enable */
  static const int32_t FDCANx_FDCAN_IE_EPE_POS       = 23;   /** @brief Error passive enable */
  static const int32_t FDCANx_FDCAN_IE_EWE_POS       = 24;   /** @brief Warning status enable */
  static const int32_t FDCANx_FDCAN_IE_BOE_POS       = 25;   /** @brief Bus_Off status enable */
  static const int32_t FDCANx_FDCAN_IE_WDIE_POS      = 26;   /** @brief Watchdog interrupt enable */
  static const int32_t FDCANx_FDCAN_IE_PEAE_POS      = 27;   /** @brief Protocol error in arbitration phase enable */
  static const int32_t FDCANx_FDCAN_IE_PEDE_POS      = 28;   /** @brief Protocol error in data phase enable */
  static const int32_t FDCANx_FDCAN_IE_ARAE_POS      = 29;   /** @brief Access to reserved address enable */
  static const int32_t FDCANx_FDCAN_ILS_HPML_POS     = 8;    /** @brief High priority message interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TCL_POS      = 9;    /** @brief Transmission completed interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TCFL_POS     = 10;   /** @brief Transmission cancellation finished interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TEFL_POS     = 11;   /** @brief Tx FIFO empty interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TEFNL_POS    = 12;   /** @brief Tx event FIFO new entry interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TEFWL_POS    = 13;   /** @brief Tx event FIFO watermark reached interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TEFFL_POS    = 14;   /** @brief Tx event FIFO full interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TEFLL_POS    = 15;   /** @brief Tx event FIFO element lost interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TSWL_POS     = 16;   /** @brief Timestamp wraparound interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_MRAFL_POS    = 17;   /** @brief Message RAM access failure interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_TOOL_POS     = 18;   /** @brief Timeout occurred interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_DRXL_POS     = 19;   /** @brief Message stored to dedicated rx buffer interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_BECL_POS     = 20;   /** @brief Bit error corrected interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_BEUL_POS     = 21;   /** @brief Bit error uncorrected interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_ELOL_POS     = 22;   /** @brief Error logging overflow interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_EPL_POS      = 23;   /** @brief Error passive interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_EWL_POS      = 24;   /** @brief Warning status interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_BOL_POS      = 25;   /** @brief Bus_Off status */
  static const int32_t FDCANx_FDCAN_ILS_WDIL_POS     = 26;   /** @brief Watchdog interrupt line */
  static const int32_t FDCANx_FDCAN_ILS_PEAL_POS     = 27;   /** @brief Protocol error in arbitration phase line */
  static const int32_t FDCANx_FDCAN_ILS_PEDL_POS     = 28;   /** @brief Protocol error in data phase line */
  static const int32_t FDCANx_FDCAN_ILS_ARAL_POS     = 29;   /** @brief Access to reserved address line */
  static const int32_t FDCANx_FDCAN_GFC_RRFE_POS     = 0;    /** @brief Reject remote frames extended */
  static const int32_t FDCANx_FDCAN_GFC_RRFS_POS     = 1;    /** @brief Reject remote frames standard */
  static const int32_t FDCANx_FDCAN_GFC_ANFE_POS     = 2;    /** @brief Accept non-matching frames extended */
  static const int32_t FDCANx_FDCAN_GFC_ANFS_POS     = 4;    /** @brief Accept non-matching frames standard */
  static const int32_t FDCANx_FDCAN_SIDFC_FLSSA_POS  = 2;    /** @brief Filter list standard start address */
  static const int32_t FDCANx_FDCAN_SIDFC_LSS_POS    = 16;   /** @brief List size standard */
  static const int32_t FDCANx_FDCAN_XIDFC_FLESA_POS  = 2;    /** @brief Filter list standard start address */
  static const int32_t FDCANx_FDCAN_XIDFC_LSE_POS    = 16;   /** @brief List size extended */
  static const int32_t FDCANx_FDCAN_XIDAM_EIDM_POS   = 0;    /** @brief Extended ID mask */
  static const int32_t FDCANx_FDCAN_HPMS_BIDX_POS    = 0;    /** @brief Buffer index */
  static const int32_t FDCANx_FDCAN_HPMS_MSI_POS     = 6;    /** @brief Message storage indicator */
  static const int32_t FDCANx_FDCAN_HPMS_FIDX_POS    = 8;    /** @brief Filter index */
  static const int32_t FDCANx_FDCAN_HPMS_FLST_POS    = 15;   /** @brief Filter list */
  static const int32_t FDCANx_FDCAN_RXFxC_F0SA_POS   = 2;    /** @brief Rx FIFO 0 start address */
  static const int32_t FDCANx_FDCAN_RXFxC_F0S_POS    = 16;   /** @brief Rx FIFO 0 size */
  static const int32_t FDCANx_FDCAN_RXFxC_F0WM_POS   = 24;   /** @brief FIFO 0 watermark */
  static const int32_t FDCANx_FDCAN_RXFxS_F0FL_POS   = 0;    /** @brief Rx FIFO 0 fill level */
  static const int32_t FDCANx_FDCAN_RXFxS_F0G_POS    = 8;    /** @brief Rx FIFO 0 get index */
  static const int32_t FDCANx_FDCAN_RXFxS_F0P_POS    = 16;   /** @brief Rx FIFO 0 put index */
  static const int32_t FDCANx_FDCAN_RXFxS_F0F_POS    = 24;   /** @brief Rx FIFO 0 full */
  static const int32_t FDCANx_FDCAN_RXFxS_RF0L_POS   = 25;   /** @brief Rx FIFO 0 message lost */
  static const int32_t FDCANx_FDCAN_RXFxA_FA01_POS   = 0;    /** @brief Rx FIFO 0 acknowledge index */
  static const int32_t FDCANx_FDCAN_RXBC_RBSA_POS    = 2;    /** @brief Rx buffer start address */
  static const int32_t FDCANx_FDCAN_RXESC_RBDS_POS   = 8;    /** @brief Rx buffer data field size: */
  static const int32_t FDCANx_FDCAN_TXBC_TBSA_POS    = 2;    /** @brief Tx buffers start address */
  static const int32_t FDCANx_FDCAN_TXBC_NDTB_POS    = 16;   /** @brief Number of dedicated transmit buffers */
  static const int32_t FDCANx_FDCAN_TXBC_TFQS_POS    = 24;   /** @brief Transmit fifo/queue size */
  static const int32_t FDCANx_FDCAN_TXBC_TFQM_POS    = 30;   /** @brief Tx fifo/queue mode */
  static const int32_t FDCANx_FDCAN_TXFQS_TFFL_POS   = 0;    /** @brief Tx FIFO free level */
  static const int32_t FDCANx_FDCAN_TXFQS_TFGI_POS   = 8;    /** @brief TFGI */
  static const int32_t FDCANx_FDCAN_TXFQS_TFQPI_POS  = 16;   /** @brief Tx fifo/queue put index */
  static const int32_t FDCANx_FDCAN_TXFQS_TFQF_POS   = 21;   /** @brief Tx fifo/queue full */
  static const int32_t FDCANx_FDCAN_TXESC_TBDS_POS   = 0;    /** @brief Tx buffer data field size: */
  static const int32_t FDCANx_FDCAN_TXEFC_EFSA_POS   = 2;    /** @brief Event FIFO start address */
  static const int32_t FDCANx_FDCAN_TXEFC_EFS_POS    = 16;   /** @brief Event FIFO size */
  static const int32_t FDCANx_FDCAN_TXEFC_EFWM_POS   = 24;   /** @brief Event FIFO watermark */
  static const int32_t FDCANx_FDCAN_TXEFS_EFFL_POS   = 0;    /** @brief Event FIFO fill level */
  static const int32_t FDCANx_FDCAN_TXEFS_EFGI_POS   = 8;    /** @brief Event FIFO get index. */
  static const int32_t FDCANx_FDCAN_TXEFS_EFF_POS    = 24;   /** @brief Event FIFO full. */
  static const int32_t FDCANx_FDCAN_TXEFS_TEFL_POS   = 25;   /** @brief Tx event FIFO element lost. */
  static const int32_t FDCANx_FDCAN_TXEFA_EFAI_POS   = 0;    /** @brief Event FIFO acknowledge index */
  static const int32_t FDCANx_FDCAN_TTTMC_TMSA_POS   = 2;    /** @brief Trigger memory start address */
  static const int32_t FDCANx_FDCAN_TTTMC_TME_POS    = 16;   /** @brief Trigger memory elements */
  static const int32_t FDCANx_FDCAN_TTRMC_RID_POS    = 0;    /** @brief Reference identifier. */
  static const int32_t FDCANx_FDCAN_TTRMC_XTD_POS    = 30;   /** @brief Extended identifier */
  static const int32_t FDCANx_FDCAN_TTRMC_RMPS_POS   = 31;   /** @brief Reference message payload select */
  static const int32_t FDCANx_FDCAN_TTOCF_OM_POS     = 0;    /** @brief Operation mode */
  static const int32_t FDCANx_FDCAN_TTOCF_GEN_POS    = 3;    /** @brief Gap enable */
  static const int32_t FDCANx_FDCAN_TTOCF_TM_POS     = 4;    /** @brief Time master */
  static const int32_t FDCANx_FDCAN_TTOCF_LDSDL_POS  = 5;    /** @brief LD of synchronization deviation limit */
  static const int32_t FDCANx_FDCAN_TTOCF_IRTO_POS   = 8;    /** @brief Initial reference trigger offset */
  static const int32_t FDCANx_FDCAN_TTOCF_EECS_POS   = 15;   /** @brief Enable external clock synchronization */
  static const int32_t FDCANx_FDCAN_TTOCF_AWL_POS    = 16;   /** @brief Application watchdog limit */
  static const int32_t FDCANx_FDCAN_TTOCF_EGTF_POS   = 24;   /** @brief Enable global time filtering */
  static const int32_t FDCANx_FDCAN_TTOCF_ECC_POS    = 25;   /** @brief Enable clock calibration */
  static const int32_t FDCANx_FDCAN_TTOCF_EVTP_POS   = 26;   /** @brief Event trigger polarity */
  static const int32_t FDCANx_FDCAN_TTMLM_CCM_POS    = 0;    /** @brief Cycle count max */
  static const int32_t FDCANx_FDCAN_TTMLM_CSS_POS    = 6;    /** @brief Cycle start synchronization */
  static const int32_t FDCANx_FDCAN_TTMLM_TXEW_POS   = 8;    /** @brief Tx enable window */
  static const int32_t FDCANx_FDCAN_TTMLM_ENTT_POS   = 16;   /** @brief Expected number of tx triggers */
  static const int32_t FDCANx_FDCAN_TURCF_NCL_POS    = 0;    /** @brief Numerator configuration low. */
  static const int32_t FDCANx_FDCAN_TURCF_DC_POS     = 16;   /** @brief Denominator configuration. */
  static const int32_t FDCANx_FDCAN_TURCF_ELT_POS    = 31;   /** @brief Enable local time */
  static const int32_t FDCANx_FDCAN_TTOCN_SGT_POS    = 0;    /** @brief Set global time */
  static const int32_t FDCANx_FDCAN_TTOCN_ECS_POS    = 1;    /** @brief External clock synchronization */
  static const int32_t FDCANx_FDCAN_TTOCN_SWP_POS    = 2;    /** @brief Stop watch polarity */
  static const int32_t FDCANx_FDCAN_TTOCN_SWS_POS    = 3;    /** @brief Stop watch source. */
  static const int32_t FDCANx_FDCAN_TTOCN_RTIE_POS   = 5;    /** @brief Register time mark interrupt pulse enable */
  static const int32_t FDCANx_FDCAN_TTOCN_TMC_POS    = 6;    /** @brief Register time mark compare */
  static const int32_t FDCANx_FDCAN_TTOCN_TTIE_POS   = 8;    /** @brief Trigger time mark interrupt pulse enable */
  static const int32_t FDCANx_FDCAN_TTOCN_GCS_POS    = 9;    /** @brief Gap control select */
  static const int32_t FDCANx_FDCAN_TTOCN_FGP_POS    = 10;   /** @brief Finish gap. */
  static const int32_t FDCANx_FDCAN_TTOCN_TMG_POS    = 11;   /** @brief Time mark gap */
  static const int32_t FDCANx_FDCAN_TTOCN_NIG_POS    = 12;   /** @brief Next is gap */
  static const int32_t FDCANx_FDCAN_TTOCN_ESCN_POS   = 13;   /** @brief External synchronization control */
  static const int32_t FDCANx_FDCAN_TTOCN_LCKC_POS   = 15;   /** @brief TT operation control register locked */
  static const int32_t FDCANx_CAN_TTGTP_NCL_POS      = 0;    /** @brief Time preset */
  static const int32_t FDCANx_CAN_TTGTP_CTP_POS      = 16;   /** @brief Cycle time target phase */
  static const int32_t FDCANx_FDCAN_TTTMK_TM_POS     = 0;    /** @brief Time mark */
  static const int32_t FDCANx_FDCAN_TTTMK_TICC_POS   = 16;   /** @brief Time mark cycle code */
  static const int32_t FDCANx_FDCAN_TTTMK_LCKM_POS   = 31;   /** @brief TT time mark register locked */
  static const int32_t FDCANx_FDCAN_TTIR_SBC_POS     = 0;    /** @brief Start of basic cycle */
  static const int32_t FDCANx_FDCAN_TTIR_SMC_POS     = 1;    /** @brief Start of matrix cycle */
  static const int32_t FDCANx_FDCAN_TTIR_CSM_POS     = 2;    /** @brief Change of synchronization mode */
  static const int32_t FDCANx_FDCAN_TTIR_SOG_POS     = 3;    /** @brief Start of gap */
  static const int32_t FDCANx_FDCAN_TTIR_RTMI_POS    = 4;    /** @brief Register time mark interrupt. */
  static const int32_t FDCANx_FDCAN_TTIR_TTMI_POS    = 5;    /** @brief Trigger time mark event internal */
  static const int32_t FDCANx_FDCAN_TTIR_SWE_POS     = 6;    /** @brief Stop watch event */
  static const int32_t FDCANx_FDCAN_TTIR_GTW_POS     = 7;    /** @brief Global time wrap */
  static const int32_t FDCANx_FDCAN_TTIR_GTD_POS     = 8;    /** @brief Global time discontinuity */
  static const int32_t FDCANx_FDCAN_TTIR_GTE_POS     = 9;    /** @brief Global time error */
  static const int32_t FDCANx_FDCAN_TTIR_TXU_POS     = 10;   /** @brief Tx count underflow */
  static const int32_t FDCANx_FDCAN_TTIR_TXO_POS     = 11;   /** @brief Tx count overflow */
  static const int32_t FDCANx_FDCAN_TTIR_ELC_POS     = 14;   /** @brief Error level changed. */
  static const int32_t FDCANx_FDCAN_TTIR_IWTG_POS    = 15;   /** @brief Initialization watch trigger */
  static const int32_t FDCANx_FDCAN_TTIR_WT_POS      = 16;   /** @brief Watch trigger */
  static const int32_t FDCANx_FDCAN_TTIR_AW_POS      = 17;   /** @brief Application watchdog */
  static const int32_t FDCANx_FDCAN_TTIR_CER_POS     = 18;   /** @brief Configuration error */
  static const int32_t FDCANx_FDCAN_TTIE_SBCE_POS    = 0;    /** @brief Start of basic cycle interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_SMCE_POS    = 1;    /** @brief Start of matrix cycle interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_CSME_POS    = 2;    /** @brief Change of synchronization mode interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_SOGE_POS    = 3;    /** @brief Start of gap interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_RTMIE_POS   = 4;    /** @brief Register time mark interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_TTMIE_POS   = 5;    /** @brief Trigger time mark event internal interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_SWEE_POS    = 6;    /** @brief Stop watch event interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_GTWE_POS    = 7;    /** @brief Global time wrap interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_GTDE_POS    = 8;    /** @brief Global time discontinuity interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_GTEE_POS    = 9;    /** @brief Global time error interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_TXUE_POS    = 10;   /** @brief Tx count underflow interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_TXOE_POS    = 11;   /** @brief Tx count overflow interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_ELCE_POS    = 14;   /** @brief Change error level interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_IWTGE_POS   = 15;   /** @brief Initialization watch trigger interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_WTE_POS     = 16;   /** @brief Watch trigger interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_AWE_POS     = 17;   /** @brief Application watchdog interrupt enable */
  static const int32_t FDCANx_FDCAN_TTIE_CERE_POS    = 18;   /** @brief Configuration error interrupt enable */
  static const int32_t FDCANx_FDCAN_TTILS_SBCL_POS   = 0;    /** @brief Start of basic cycle interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_SMCL_POS   = 1;    /** @brief Start of matrix cycle interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_CSML_POS   = 2;    /** @brief Change of synchronization mode interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_SOGL_POS   = 3;    /** @brief Start of gap interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_RTMIL_POS  = 4;    /** @brief Register time mark interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_TTMIL_POS  = 5;    /** @brief Trigger time mark event internal interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_SWEL_POS   = 6;    /** @brief Stop watch event interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_GTWL_POS   = 7;    /** @brief Global time wrap interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_GTDL_POS   = 8;    /** @brief Global time discontinuity interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_GTEL_POS   = 9;    /** @brief Global time error interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_TXUL_POS   = 10;   /** @brief Tx count underflow interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_TXOL_POS   = 11;   /** @brief Tx count overflow interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_ELCL_POS   = 14;   /** @brief Change error level interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_IWTGL_POS  = 15;   /** @brief Initialization watch trigger interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_WTL_POS    = 16;   /** @brief Watch trigger interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_AWL_POS    = 17;   /** @brief Application watchdog interrupt line */
  static const int32_t FDCANx_FDCAN_TTILS_CERL_POS   = 18;   /** @brief Configuration error interrupt line */
  static const int32_t FDCANx_FDCAN_TTOST_EL_POS     = 0;    /** @brief Error level */
  static const int32_t FDCANx_FDCAN_TTOST_MS_POS     = 2;    /** @brief Master state. */
  static const int32_t FDCANx_FDCAN_TTOST_SYS_POS    = 4;    /** @brief Synchronization state */
  static const int32_t FDCANx_FDCAN_TTOST_GTP_POS    = 6;    /** @brief Quality of global time phase */
  static const int32_t FDCANx_FDCAN_TTOST_QCS_POS    = 7;    /** @brief Quality of clock speed */
  static const int32_t FDCANx_FDCAN_TTOST_RTO_POS    = 8;    /** @brief Reference trigger offset */
  static const int32_t FDCANx_FDCAN_TTOST_WGTD_POS   = 22;   /** @brief Wait for global time discontinuity */
  static const int32_t FDCANx_FDCAN_TTOST_GFI_POS    = 23;   /** @brief Gap finished indicator. */
  static const int32_t FDCANx_FDCAN_TTOST_TMP_POS    = 24;   /** @brief Time master priority */
  static const int32_t FDCANx_FDCAN_TTOST_GSI_POS    = 27;   /** @brief Gap started indicator. */
  static const int32_t FDCANx_FDCAN_TTOST_WFE_POS    = 28;   /** @brief Wait for event */
  static const int32_t FDCANx_FDCAN_TTOST_AWE_POS    = 29;   /** @brief Application watchdog event */
  static const int32_t FDCANx_FDCAN_TTOST_WECS_POS   = 30;   /** @brief Wait for external clock synchronization */
  static const int32_t FDCANx_FDCAN_TTOST_SPL_POS    = 31;   /** @brief Schedule phase lock */
  static const int32_t FDCANx_FDCAN_TURNA_NAV_POS    = 0;    /** @brief Numerator actual value */
  static const int32_t FDCANx_FDCAN_TTLGT_LT_POS     = 0;    /** @brief Local time */
  static const int32_t FDCANx_FDCAN_TTLGT_GT_POS     = 16;   /** @brief Global time */
  static const int32_t FDCANx_FDCAN_TTCTC_CT_POS     = 0;    /** @brief Cycle time */
  static const int32_t FDCANx_FDCAN_TTCTC_CC_POS     = 16;   /** @brief Cycle count */
  static const int32_t FDCANx_FDCAN_TTCPT_CT_POS     = 0;    /** @brief Cycle count value */
  static const int32_t FDCANx_FDCAN_TTCPT_SWV_POS    = 16;   /** @brief Stop watch value */
  static const int32_t FDCANx_FDCAN_TTCSM_CSM_POS    = 0;    /** @brief Cycle sync mark */
  static const int32_t FDCANx_FDCAN_TTTS_SWTDEL_POS  = 0;    /** @brief Stop watch trigger input selection */
  static const int32_t FDCANx_FDCAN_TTTS_EVTSEL_POS  = 4;    /** @brief Event trigger input selection */

  /**** @subsection Enumerated FDCANx Register Field Positions ****/

  static const int32_t FDCANx_FDCAN_DBTP_DTSEGx_POS[3] = {
    [1] = 8,   /** @brief Data time segment after sample point */
    [2] = 4,   /** @brief Data time segment after sample point */
  };

  static const int32_t FDCANx_FDCAN_IR_RFxN_POS[2] = {
    [0] = 0,   /** @brief Rx FIFO 0 new message */
    [1] = 4,   /** @brief Rx FIFO 1 new message */
  };

  static const int32_t FDCANx_FDCAN_IR_RFxW_POS[2] = {
    [0] = 1,   /** @brief Rx FIFO 0 full */
    [1] = 5,   /** @brief Rx FIFO 1 watermark reached */
  };

  static const int32_t FDCANx_FDCAN_IR_RFxF_POS[2] = {
    [0] = 2,   /** @brief Rx FIFO 0 full */
    [1] = 6,   /** @brief Rx FIFO 1 watermark reached */
  };

  static const int32_t FDCANx_FDCAN_IR_RFxL_POS[2] = {
    [0] = 3,   /** @brief Rx FIFO 0 message lost */
    [1] = 7,   /** @brief Rx FIFO 1 message lost */
  };

  static const int32_t FDCANx_FDCAN_IE_RFxNE_POS[2] = {
    [0] = 0,   /** @brief Rx FIFO 0 new message enable */
    [1] = 4,   /** @brief Rx FIFO 1 new message enable */
  };

  static const int32_t FDCANx_FDCAN_IE_RFxWE_POS[2] = {
    [0] = 1,   /** @brief Rx FIFO 0 full enable */
    [1] = 5,   /** @brief Rx FIFO 1 watermark reached enable */
  };

  static const int32_t FDCANx_FDCAN_IE_RFxFE_POS[2] = {
    [0] = 2,   /** @brief Rx FIFO 0 full enable */
    [1] = 6,   /** @brief Rx FIFO 1 watermark reached enable */
  };

  static const int32_t FDCANx_FDCAN_IE_RFxLE_POS[2] = {
    [0] = 3,   /** @brief Rx FIFO 0 message lost enable */
    [1] = 7,   /** @brief Rx FIFO 1 message lost enable */
  };

  static const int32_t FDCANx_FDCAN_ILS_RFxNL_POS[2] = {
    [0] = 0,   /** @brief Rx FIFO 0 new message interrupt line */
    [1] = 4,   /** @brief Rx FIFO 1 new message interrupt line */
  };

  static const int32_t FDCANx_FDCAN_ILS_RFxWL_POS[2] = {
    [0] = 1,   /** @brief Rx FIFO 0 watermark reached interrupt line */
    [1] = 5,   /** @brief Rx FIFO 1 watermark reached interrupt line */
  };

  static const int32_t FDCANx_FDCAN_ILS_RFxFL_POS[2] = {
    [0] = 2,   /** @brief Rx FIFO 0 full interrupt line */
    [1] = 6,   /** @brief Rx FIFO 1 full interrupt line */
  };

  static const int32_t FDCANx_FDCAN_ILS_RFxLL_POS[2] = {
    [0] = 3,   /** @brief Rx FIFO 0 message lost interrupt line */
    [1] = 7,   /** @brief Rx FIFO 1 message lost interrupt line */
  };

  static const int32_t FDCANx_FDCAN_ILE_EINTx_POS[2] = {
    [0] = 0,   /** @brief Enable interrupt line 0 */
    [1] = 1,   /** @brief Enable interrupt line 1 */
  };

  static const int32_t FDCANx_FDCAN_NDATx_NDx_POS[32] = {
    [0]  = 0,    /** @brief New data */
    [1]  = 1,    /** @brief New data */
    [2]  = 2,    /** @brief New data */
    [3]  = 3,    /** @brief New data */
    [4]  = 4,    /** @brief New data */
    [5]  = 5,    /** @brief New data */
    [6]  = 6,    /** @brief New data */
    [7]  = 7,    /** @brief New data */
    [8]  = 8,    /** @brief New data */
    [9]  = 9,    /** @brief New data */
    [10] = 10,   /** @brief New data */
    [11] = 11,   /** @brief New data */
    [12] = 12,   /** @brief New data */
    [13] = 13,   /** @brief New data */
    [14] = 14,   /** @brief New data */
    [15] = 15,   /** @brief New data */
    [16] = 16,   /** @brief New data */
    [17] = 17,   /** @brief New data */
    [18] = 18,   /** @brief New data */
    [19] = 19,   /** @brief New data */
    [20] = 20,   /** @brief New data */
    [21] = 21,   /** @brief New data */
    [22] = 22,   /** @brief New data */
    [23] = 23,   /** @brief New data */
    [24] = 24,   /** @brief New data */
    [25] = 25,   /** @brief New data */
    [26] = 26,   /** @brief New data */
    [27] = 27,   /** @brief New data */
    [28] = 28,   /** @brief New data */
    [29] = 29,   /** @brief New data */
    [30] = 30,   /** @brief New data */
    [31] = 31,   /** @brief New data */
  };

  static const int32_t FDCANx_FDCAN_RXESC_FxDS_POS[2] = {
    [0] = 0,   /** @brief Rx FIFO 1 data field size: */
    [1] = 4,   /** @brief Rx FIFO 0 data field size: */
  };

  static const int32_t FDCANx_FDCAN_TTIR_SEx_POS[3] = {
    [1] = 12,   /** @brief Scheduling error 1 */
    [2] = 13,   /** @brief Scheduling error 2 */
  };

  static const int32_t FDCANx_FDCAN_TTIE_SExE_POS[3] = {
    [1] = 12,   /** @brief Scheduling error 1 interrupt enable */
    [2] = 13,   /** @brief Scheduling error 2 interrupt enable */
  };

  static const int32_t FDCANx_FDCAN_TTILS_SExL_POS[3] = {
    [1] = 12,   /** @brief Scheduling error 1 interrupt line */
    [2] = 13,   /** @brief Scheduling error 2 interrupt line */
  };

  /**********************************************************************************************
   * @section CAN_CCU Register Information
   **********************************************************************************************/

  /**** @subsection CAN_CCU Register Pointers ****/

  static RW_ uint32_t* const CAN_CCU_CREL_PTR  = (RW_ uint32_t* const)0x4000A800U;   /** @brief Clock calibration unit core release register */
  static RW_ uint32_t* const CAN_CCU_CCFG_PTR  = (RW_ uint32_t* const)0x4000A804U;   /** @brief Calibration configuration register */
  static RW_ uint32_t* const CAN_CCU_CSTAT_PTR = (RW_ uint32_t* const)0x4000A808U;   /** @brief Calibration status register */
  static RW_ uint32_t* const CAN_CCU_CWD_PTR   = (RW_ uint32_t* const)0x4000A80CU;   /** @brief Calibration watchdog register */
  static RW_ uint32_t* const CAN_CCU_IR_PTR    = (RW_ uint32_t* const)0x4000A810U;   /** @brief Clock calibration unit interrupt register */
  static RW_ uint32_t* const CAN_CCU_IE_PTR    = (RW_ uint32_t* const)0x4000A814U;   /** @brief Clock calibration unit interrupt enable register */

  /**** @subsection CAN_CCU Register Field Masks ****/

  static const uint32_t CAN_CCU_CREL_DAY_MSK     = 0x000000FFU;   /** @brief Time stamp day */
  static const uint32_t CAN_CCU_CREL_MON_MSK     = 0x0000FF00U;   /** @brief Time stamp month */
  static const uint32_t CAN_CCU_CREL_YEAR_MSK    = 0x000F0000U;   /** @brief Time stamp year */
  static const uint32_t CAN_CCU_CREL_SUBSTEP_MSK = 0x00F00000U;   /** @brief Sub-step of core release */
  static const uint32_t CAN_CCU_CREL_STEP_MSK    = 0x0F000000U;   /** @brief Step of core release */
  static const uint32_t CAN_CCU_CREL_REL_MSK     = 0xF0000000U;   /** @brief Core release */
  static const uint32_t CAN_CCU_CCFG_TQBT_MSK    = 0x0000001FU;   /** @brief Time quanta per bit time */
  static const uint32_t CAN_CCU_CCFG_BCC_MSK     = 0x00000040U;   /** @brief Bypass clock calibration */
  static const uint32_t CAN_CCU_CCFG_CFL_MSK     = 0x00000080U;   /** @brief Calibration field length */
  static const uint32_t CAN_CCU_CCFG_OCPM_MSK    = 0x0000FF00U;   /** @brief Oscillator clock periods minimum */
  static const uint32_t CAN_CCU_CCFG_CDIV_MSK    = 0x000F0000U;   /** @brief Clock divider */
  static const uint32_t CAN_CCU_CCFG_SWR_MSK     = 0x80000000U;   /** @brief Software reset */
  static const uint32_t CAN_CCU_CSTAT_OCPC_MSK   = 0x0003FFFFU;   /** @brief Oscillator clock period counter */
  static const uint32_t CAN_CCU_CSTAT_TQC_MSK    = 0x1FFC0000U;   /** @brief Time quanta counter */
  static const uint32_t CAN_CCU_CSTAT_CALS_MSK   = 0xC0000000U;   /** @brief Calibration state */
  static const uint32_t CAN_CCU_CWD_WDC_MSK      = 0x0000FFFFU;   /** @brief WDC */
  static const uint32_t CAN_CCU_CWD_WDV_MSK      = 0xFFFF0000U;   /** @brief WDV */
  static const uint32_t CAN_CCU_IR_CWE_MSK       = 0x00000001U;   /** @brief Calibration watchdog event */
  static const uint32_t CAN_CCU_IR_CSC_MSK       = 0x00000002U;   /** @brief Calibration state changed */
  static const uint32_t CAN_CCU_IE_CWEE_MSK      = 0x00000001U;   /** @brief Calibration watchdog event enable */
  static const uint32_t CAN_CCU_IE_CSCE_MSK      = 0x00000002U;   /** @brief Calibration state changed enable */

  /**** @subsection CAN_CCU Register Field Positions ****/

  static const int32_t CAN_CCU_CREL_DAY_POS     = 0;    /** @brief Time stamp day */
  static const int32_t CAN_CCU_CREL_MON_POS     = 8;    /** @brief Time stamp month */
  static const int32_t CAN_CCU_CREL_YEAR_POS    = 16;   /** @brief Time stamp year */
  static const int32_t CAN_CCU_CREL_SUBSTEP_POS = 20;   /** @brief Sub-step of core release */
  static const int32_t CAN_CCU_CREL_STEP_POS    = 24;   /** @brief Step of core release */
  static const int32_t CAN_CCU_CREL_REL_POS     = 28;   /** @brief Core release */
  static const int32_t CAN_CCU_CCFG_TQBT_POS    = 0;    /** @brief Time quanta per bit time */
  static const int32_t CAN_CCU_CCFG_BCC_POS     = 6;    /** @brief Bypass clock calibration */
  static const int32_t CAN_CCU_CCFG_CFL_POS     = 7;    /** @brief Calibration field length */
  static const int32_t CAN_CCU_CCFG_OCPM_POS    = 8;    /** @brief Oscillator clock periods minimum */
  static const int32_t CAN_CCU_CCFG_CDIV_POS    = 16;   /** @brief Clock divider */
  static const int32_t CAN_CCU_CCFG_SWR_POS     = 31;   /** @brief Software reset */
  static const int32_t CAN_CCU_CSTAT_OCPC_POS   = 0;    /** @brief Oscillator clock period counter */
  static const int32_t CAN_CCU_CSTAT_TQC_POS    = 18;   /** @brief Time quanta counter */
  static const int32_t CAN_CCU_CSTAT_CALS_POS   = 30;   /** @brief Calibration state */
  static const int32_t CAN_CCU_CWD_WDC_POS      = 0;    /** @brief WDC */
  static const int32_t CAN_CCU_CWD_WDV_POS      = 16;   /** @brief WDV */
  static const int32_t CAN_CCU_IR_CWE_POS       = 0;    /** @brief Calibration watchdog event */
  static const int32_t CAN_CCU_IR_CSC_POS       = 1;    /** @brief Calibration state changed */
  static const int32_t CAN_CCU_IE_CWEE_POS      = 0;    /** @brief Calibration watchdog event enable */
  static const int32_t CAN_CCU_IE_CSCE_POS      = 1;    /** @brief Calibration state changed enable */

  /**********************************************************************************************
   * @section MDIOS Register Information
   **********************************************************************************************/

  /**** @subsection MDIOS Register Pointers ****/

  static RW_ uint32_t* const MDIOS_MDIOS_CR_PTR    = (RW_ uint32_t* const)0x40009400U;   /** @brief MDIOS configuration register */
  static RO_ uint32_t* const MDIOS_MDIOS_WRFR_PTR  = (RO_ uint32_t* const)0x40009404U;   /** @brief MDIOS write flag register */
  static RW_ uint32_t* const MDIOS_MDIOS_CWRFR_PTR = (RW_ uint32_t* const)0x40009408U;   /** @brief MDIOS clear write flag register */
  static RO_ uint32_t* const MDIOS_MDIOS_RDFR_PTR  = (RO_ uint32_t* const)0x4000940CU;   /** @brief MDIOS read flag register */
  static RW_ uint32_t* const MDIOS_MDIOS_CRDFR_PTR = (RW_ uint32_t* const)0x40009410U;   /** @brief MDIOS clear read flag register */
  static RO_ uint32_t* const MDIOS_MDIOS_SR_PTR    = (RO_ uint32_t* const)0x40009414U;   /** @brief MDIOS status register */
  static RW_ uint32_t* const MDIOS_MDIOS_CLRFR_PTR = (RW_ uint32_t* const)0x40009418U;   /** @brief MDIOS clear flag register */

  /**** @subsection Enumerated MDIOS Register Pointers ****/

  static RO_ uint32_t* const MDIOS_MDIOS_DINRx_PTR[32] = {
    [0]  = (RO_ uint32_t* const)0x4000941CU,   /** @brief MDIOS input data register 0 */
    [1]  = (RO_ uint32_t* const)0x40009420U,   /** @brief MDIOS input data register 1 */
    [2]  = (RO_ uint32_t* const)0x40009424U,   /** @brief MDIOS input data register 2 */
    [3]  = (RO_ uint32_t* const)0x40009428U,   /** @brief MDIOS input data register 3 */
    [4]  = (RO_ uint32_t* const)0x4000942CU,   /** @brief MDIOS input data register 4 */
    [5]  = (RO_ uint32_t* const)0x40009430U,   /** @brief MDIOS input data register 5 */
    [6]  = (RO_ uint32_t* const)0x40009434U,   /** @brief MDIOS input data register 6 */
    [7]  = (RO_ uint32_t* const)0x40009438U,   /** @brief MDIOS input data register 7 */
    [8]  = (RO_ uint32_t* const)0x4000943CU,   /** @brief MDIOS input data register 8 */
    [9]  = (RO_ uint32_t* const)0x40009440U,   /** @brief MDIOS input data register 9 */
    [10] = (RO_ uint32_t* const)0x40009444U,   /** @brief MDIOS input data register 10 */
    [11] = (RO_ uint32_t* const)0x40009448U,   /** @brief MDIOS input data register 11 */
    [12] = (RO_ uint32_t* const)0x4000944CU,   /** @brief MDIOS input data register 12 */
    [13] = (RO_ uint32_t* const)0x40009450U,   /** @brief MDIOS input data register 13 */
    [14] = (RO_ uint32_t* const)0x40009454U,   /** @brief MDIOS input data register 14 */
    [15] = (RO_ uint32_t* const)0x40009458U,   /** @brief MDIOS input data register 15 */
    [16] = (RO_ uint32_t* const)0x4000945CU,   /** @brief MDIOS input data register 16 */
    [17] = (RO_ uint32_t* const)0x40009460U,   /** @brief MDIOS input data register 17 */
    [18] = (RO_ uint32_t* const)0x40009464U,   /** @brief MDIOS input data register 18 */
    [19] = (RO_ uint32_t* const)0x40009468U,   /** @brief MDIOS input data register 19 */
    [20] = (RO_ uint32_t* const)0x4000946CU,   /** @brief MDIOS input data register 20 */
    [21] = (RO_ uint32_t* const)0x40009470U,   /** @brief MDIOS input data register 21 */
    [22] = (RO_ uint32_t* const)0x40009474U,   /** @brief MDIOS input data register 22 */
    [23] = (RO_ uint32_t* const)0x40009478U,   /** @brief MDIOS input data register 23 */
    [24] = (RO_ uint32_t* const)0x4000947CU,   /** @brief MDIOS input data register 24 */
    [25] = (RO_ uint32_t* const)0x40009480U,   /** @brief MDIOS input data register 25 */
    [26] = (RO_ uint32_t* const)0x40009484U,   /** @brief MDIOS input data register 26 */
    [27] = (RO_ uint32_t* const)0x40009488U,   /** @brief MDIOS input data register 27 */
    [28] = (RO_ uint32_t* const)0x4000948CU,   /** @brief MDIOS input data register 28 */
    [29] = (RO_ uint32_t* const)0x40009490U,   /** @brief MDIOS input data register 29 */
    [30] = (RO_ uint32_t* const)0x40009494U,   /** @brief MDIOS input data register 30 */
    [31] = (RO_ uint32_t* const)0x40009498U,   /** @brief MDIOS input data register 31 */
  };

  static RW_ uint32_t* const MDIOS_MDIOS_DOUTRx_PTR[32] = {
    [0]  = (RW_ uint32_t* const)0x4000949CU,   /** @brief MDIOS output data register 0 */
    [1]  = (RW_ uint32_t* const)0x400094A0U,   /** @brief MDIOS output data register 1 */
    [2]  = (RW_ uint32_t* const)0x400094A4U,   /** @brief MDIOS output data register 2 */
    [3]  = (RW_ uint32_t* const)0x400094A8U,   /** @brief MDIOS output data register 3 */
    [4]  = (RW_ uint32_t* const)0x400094ACU,   /** @brief MDIOS output data register 4 */
    [5]  = (RW_ uint32_t* const)0x400094B0U,   /** @brief MDIOS output data register 5 */
    [6]  = (RW_ uint32_t* const)0x400094B4U,   /** @brief MDIOS output data register 6 */
    [7]  = (RW_ uint32_t* const)0x400094B8U,   /** @brief MDIOS output data register 7 */
    [8]  = (RW_ uint32_t* const)0x400094BCU,   /** @brief MDIOS output data register 8 */
    [9]  = (RW_ uint32_t* const)0x400094C0U,   /** @brief MDIOS output data register 9 */
    [10] = (RW_ uint32_t* const)0x400094C4U,   /** @brief MDIOS output data register 10 */
    [11] = (RW_ uint32_t* const)0x400094C8U,   /** @brief MDIOS output data register 11 */
    [12] = (RW_ uint32_t* const)0x400094CCU,   /** @brief MDIOS output data register 12 */
    [13] = (RW_ uint32_t* const)0x400094D0U,   /** @brief MDIOS output data register 13 */
    [14] = (RW_ uint32_t* const)0x400094D4U,   /** @brief MDIOS output data register 14 */
    [15] = (RW_ uint32_t* const)0x400094D8U,   /** @brief MDIOS output data register 15 */
    [16] = (RW_ uint32_t* const)0x400094DCU,   /** @brief MDIOS output data register 16 */
    [17] = (RW_ uint32_t* const)0x400094E0U,   /** @brief MDIOS output data register 17 */
    [18] = (RW_ uint32_t* const)0x400094E4U,   /** @brief MDIOS output data register 18 */
    [19] = (RW_ uint32_t* const)0x400094E8U,   /** @brief MDIOS output data register 19 */
    [20] = (RW_ uint32_t* const)0x400094ECU,   /** @brief MDIOS output data register 20 */
    [21] = (RW_ uint32_t* const)0x400094F0U,   /** @brief MDIOS output data register 21 */
    [22] = (RW_ uint32_t* const)0x400094F4U,   /** @brief MDIOS output data register 22 */
    [23] = (RW_ uint32_t* const)0x400094F8U,   /** @brief MDIOS output data register 23 */
    [24] = (RW_ uint32_t* const)0x400094FCU,   /** @brief MDIOS output data register 24 */
    [25] = (RW_ uint32_t* const)0x40009500U,   /** @brief MDIOS output data register 25 */
    [26] = (RW_ uint32_t* const)0x40009504U,   /** @brief MDIOS output data register 26 */
    [27] = (RW_ uint32_t* const)0x40009508U,   /** @brief MDIOS output data register 27 */
    [28] = (RW_ uint32_t* const)0x4000950CU,   /** @brief MDIOS output data register 28 */
    [29] = (RW_ uint32_t* const)0x40009510U,   /** @brief MDIOS output data register 29 */
    [30] = (RW_ uint32_t* const)0x40009514U,   /** @brief MDIOS output data register 30 */
    [31] = (RW_ uint32_t* const)0x40009518U,   /** @brief MDIOS output data register 31 */
  };

  /**** @subsection MDIOS Register Field Masks ****/

  static const uint32_t MDIOS_MDIOS_CR_EN_MSK           = 0x00000001U;   /** @brief Peripheral enable */
  static const uint32_t MDIOS_MDIOS_CR_WRIE_MSK         = 0x00000002U;   /** @brief Register write interrupt enable */
  static const uint32_t MDIOS_MDIOS_CR_RDIE_MSK         = 0x00000004U;   /** @brief Register read interrupt enable */
  static const uint32_t MDIOS_MDIOS_CR_EIE_MSK          = 0x00000008U;   /** @brief Error interrupt enable */
  static const uint32_t MDIOS_MDIOS_CR_DPC_MSK          = 0x00000080U;   /** @brief Disable preamble check */
  static const uint32_t MDIOS_MDIOS_CR_PORT_ADDRESS_MSK = 0x00001F00U;   /** @brief Slaves's address */
  static const uint32_t MDIOS_MDIOS_SR_PERF_MSK         = 0x00000001U;   /** @brief Preamble error flag */
  static const uint32_t MDIOS_MDIOS_SR_SERF_MSK         = 0x00000002U;   /** @brief Start error flag */
  static const uint32_t MDIOS_MDIOS_SR_TERF_MSK         = 0x00000004U;   /** @brief Turnaround error flag */
  static const uint32_t MDIOS_MDIOS_CLRFR_CPERF_MSK     = 0x00000001U;   /** @brief Clear the preamble error flag */
  static const uint32_t MDIOS_MDIOS_CLRFR_CSERF_MSK     = 0x00000002U;   /** @brief Clear the start error flag */
  static const uint32_t MDIOS_MDIOS_CLRFR_CTERF_MSK     = 0x00000004U;   /** @brief Clear the turnaround error flag */
  static const uint32_t MDIOS_MDIOS_DINRx_DIN0_MSK      = 0x0000FFFFU;   /** @brief Input data received from MDIO master during write frames */
  static const uint32_t MDIOS_MDIOS_DOUTRx_DOUT0_MSK    = 0x0000FFFFU;   /** @brief Output data sent to MDIO master during read frames */

  /**** @subsection MDIOS Register Field Positions ****/

  static const int32_t MDIOS_MDIOS_CR_EN_POS           = 0;   /** @brief Peripheral enable */
  static const int32_t MDIOS_MDIOS_CR_WRIE_POS         = 1;   /** @brief Register write interrupt enable */
  static const int32_t MDIOS_MDIOS_CR_RDIE_POS         = 2;   /** @brief Register read interrupt enable */
  static const int32_t MDIOS_MDIOS_CR_EIE_POS          = 3;   /** @brief Error interrupt enable */
  static const int32_t MDIOS_MDIOS_CR_DPC_POS          = 7;   /** @brief Disable preamble check */
  static const int32_t MDIOS_MDIOS_CR_PORT_ADDRESS_POS = 8;   /** @brief Slaves's address */
  static const int32_t MDIOS_MDIOS_SR_PERF_POS         = 0;   /** @brief Preamble error flag */
  static const int32_t MDIOS_MDIOS_SR_SERF_POS         = 1;   /** @brief Start error flag */
  static const int32_t MDIOS_MDIOS_SR_TERF_POS         = 2;   /** @brief Turnaround error flag */
  static const int32_t MDIOS_MDIOS_CLRFR_CPERF_POS     = 0;   /** @brief Clear the preamble error flag */
  static const int32_t MDIOS_MDIOS_CLRFR_CSERF_POS     = 1;   /** @brief Clear the start error flag */
  static const int32_t MDIOS_MDIOS_CLRFR_CTERF_POS     = 2;   /** @brief Clear the turnaround error flag */
  static const int32_t MDIOS_MDIOS_DINRx_DIN0_POS      = 0;   /** @brief Input data received from MDIO master during write frames */
  static const int32_t MDIOS_MDIOS_DOUTRx_DOUT0_POS    = 0;   /** @brief Output data sent to MDIO master during read frames */

  /**********************************************************************************************
   * @section OPAMP Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated OPAMP Register Pointers ****/

  static RW_ uint32_t* const OPAMP_OPAMPx_CSR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40009000U,   /** @brief OPAMP1 control/status register */
    [2] = (RW_ uint32_t* const)0x40009010U,   /** @brief OPAMP2 control/status register */
  };

  static RW_ uint32_t* const OPAMP_OPAMPx_OTR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40009004U,   /** @brief OPAMP1 offset trimming register in normal mode */
    [2] = (RW_ uint32_t* const)0x40009014U,   /** @brief OPAMP2 offset trimming register in normal mode */
  };

  static RW_ uint32_t* const OPAMP_OPAMPx_HSOTR_PTR[3] = {
    [1] = (RW_ uint32_t* const)0x40009008U,   /** @brief OPAMP1 offset trimming register in low-power mode */
    [2] = (RW_ uint32_t* const)0x40009018U,   /** @brief OPAMP2 offset trimming register in low-power mode */
  };

  /**** @subsection OPAMP Register Field Masks ****/

  static const uint32_t OPAMP_OPAMPx_CSR_OPAEN_MSK           = 0x00000001U;   /** @brief Operational amplifier enable */
  static const uint32_t OPAMP_OPAMPx_CSR_FORCE_VP_MSK        = 0x00000002U;   /** @brief Force internal reference on VP (reserved for test */
  static const uint32_t OPAMP_OPAMPx_CSR_VP_SEL_MSK          = 0x0000000CU;   /** @brief Operational amplifier PGA mode */
  static const uint32_t OPAMP_OPAMPx_CSR_VM_SEL_MSK          = 0x00000060U;   /** @brief Inverting input selection */
  static const uint32_t OPAMP_OPAMPx_CSR_OPAHSM_MSK          = 0x00000100U;   /** @brief Operational amplifier high-speed mode */
  static const uint32_t OPAMP_OPAMPx_CSR_CALON_MSK           = 0x00000800U;   /** @brief Calibration mode enabled */
  static const uint32_t OPAMP_OPAMPx_CSR_CALSEL_MSK          = 0x00003000U;   /** @brief Calibration selection */
  static const uint32_t OPAMP_OPAMPx_CSR_PGA_GAIN_MSK        = 0x0003C000U;   /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
  static const uint32_t OPAMP_OPAMPx_CSR_USERTRIM_MSK        = 0x00040000U;   /** @brief User trimming enable */
  static const uint32_t OPAMP_OPAMPx_CSR_TSTREF_MSK          = 0x20000000U;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
  static const uint32_t OPAMP_OPAMPx_CSR_CALOUT_MSK          = 0x40000000U;   /** @brief Operational amplifier calibration output */
  static const uint32_t OPAMP_OPAMPx_OTR_TRIMOFFSETN_MSK     = 0x0000001FU;   /** @brief Trim for NMOS differential pairs */
  static const uint32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP_MSK     = 0x00001F00U;   /** @brief Trim for PMOS differential pairs */
  static const uint32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETN_MSK = 0x0000001FU;   /** @brief Trim for NMOS differential pairs */
  static const uint32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP_MSK = 0x00001F00U;   /** @brief Trim for PMOS differential pairs */

  /**** @subsection OPAMP Register Field Positions ****/

  static const int32_t OPAMP_OPAMPx_CSR_OPAEN_POS           = 0;    /** @brief Operational amplifier enable */
  static const int32_t OPAMP_OPAMPx_CSR_FORCE_VP_POS        = 1;    /** @brief Force internal reference on VP (reserved for test */
  static const int32_t OPAMP_OPAMPx_CSR_VP_SEL_POS          = 2;    /** @brief Operational amplifier PGA mode */
  static const int32_t OPAMP_OPAMPx_CSR_VM_SEL_POS          = 5;    /** @brief Inverting input selection */
  static const int32_t OPAMP_OPAMPx_CSR_OPAHSM_POS          = 8;    /** @brief Operational amplifier high-speed mode */
  static const int32_t OPAMP_OPAMPx_CSR_CALON_POS           = 11;   /** @brief Calibration mode enabled */
  static const int32_t OPAMP_OPAMPx_CSR_CALSEL_POS          = 12;   /** @brief Calibration selection */
  static const int32_t OPAMP_OPAMPx_CSR_PGA_GAIN_POS        = 14;   /** @brief Allows to switch from AOP offset trimmed values to AOP offset */
  static const int32_t OPAMP_OPAMPx_CSR_USERTRIM_POS        = 18;   /** @brief User trimming enable */
  static const int32_t OPAMP_OPAMPx_CSR_TSTREF_POS          = 29;   /** @brief OPAMP calibration reference voltage output control (reserved for test) */
  static const int32_t OPAMP_OPAMPx_CSR_CALOUT_POS          = 30;   /** @brief Operational amplifier calibration output */
  static const int32_t OPAMP_OPAMPx_OTR_TRIMOFFSETN_POS     = 0;    /** @brief Trim for NMOS differential pairs */
  static const int32_t OPAMP_OPAMPx_OTR_TRIMOFFSETP_POS     = 8;    /** @brief Trim for PMOS differential pairs */
  static const int32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETN_POS = 0;    /** @brief Trim for NMOS differential pairs */
  static const int32_t OPAMP_OPAMPx_HSOTR_TRIMLPOFFSETP_POS = 8;    /** @brief Trim for PMOS differential pairs */

  /**********************************************************************************************
   * @section SWPMI Register Information
   **********************************************************************************************/

  /**** @subsection SWPMI Register Pointers ****/

  static RW_ uint32_t* const SWPMI_CR_PTR  = (RW_ uint32_t* const)0x40008800U;   /** @brief SWPMI configuration/control register */
  static RW_ uint32_t* const SWPMI_BRR_PTR = (RW_ uint32_t* const)0x40008804U;   /** @brief SWPMI bitrate register */
  static RO_ uint32_t* const SWPMI_ISR_PTR = (RO_ uint32_t* const)0x4000880CU;   /** @brief SWPMI interrupt and status register */
  static WO_ uint32_t* const SWPMI_ICR_PTR = (WO_ uint32_t* const)0x40008810U;   /** @brief SWPMI interrupt flag clear register */
  static RW_ uint32_t* const SWPMI_IER_PTR = (RW_ uint32_t* const)0x40008814U;   /** @brief SWPMI interrupt enable register */
  static RO_ uint32_t* const SWPMI_RFL_PTR = (RO_ uint32_t* const)0x40008818U;   /** @brief SWPMI receive frame length register */
  static WO_ uint32_t* const SWPMI_TDR_PTR = (WO_ uint32_t* const)0x4000881CU;   /** @brief SWPMI transmit data register */
  static RO_ uint32_t* const SWPMI_RDR_PTR = (RO_ uint32_t* const)0x40008820U;   /** @brief SWPMI receive data register */
  static RW_ uint32_t* const SWPMI_OR_PTR  = (RW_ uint32_t* const)0x40008824U;   /** @brief SWPMI option register */

  /**** @subsection SWPMI Register Field Masks ****/

  static const uint32_t SWPMI_CR_RXDMA_MSK     = 0x00000001U;   /** @brief Reception DMA enable */
  static const uint32_t SWPMI_CR_TXDMA_MSK     = 0x00000002U;   /** @brief Transmission DMA enable */
  static const uint32_t SWPMI_CR_RXMODE_MSK    = 0x00000004U;   /** @brief Reception buffering mode */
  static const uint32_t SWPMI_CR_TXMODE_MSK    = 0x00000008U;   /** @brief Transmission buffering mode */
  static const uint32_t SWPMI_CR_LPBK_MSK      = 0x00000010U;   /** @brief Loopback mode enable */
  static const uint32_t SWPMI_CR_SWPACT_MSK    = 0x00000020U;   /** @brief Single wire protocol master interface activate */
  static const uint32_t SWPMI_CR_DEACT_MSK     = 0x00000400U;   /** @brief Single wire protocol master interface deactivate */
  static const uint32_t SWPMI_CR_SWPTEN_MSK    = 0x00000800U;   /** @brief Single wire protocol master transceiver enable */
  static const uint32_t SWPMI_BRR_BR_MSK       = 0x000000FFU;   /** @brief Bitrate prescaler */
  static const uint32_t SWPMI_ISR_RXBFF_MSK    = 0x00000001U;   /** @brief Receive buffer full flag */
  static const uint32_t SWPMI_ISR_TXBEF_MSK    = 0x00000002U;   /** @brief Transmit buffer empty flag */
  static const uint32_t SWPMI_ISR_RXBERF_MSK   = 0x00000004U;   /** @brief Receive CRC error flag */
  static const uint32_t SWPMI_ISR_RXOVRF_MSK   = 0x00000008U;   /** @brief Receive overrun error flag */
  static const uint32_t SWPMI_ISR_TXUNRF_MSK   = 0x00000010U;   /** @brief Transmit underrun error flag */
  static const uint32_t SWPMI_ISR_RXNE_MSK     = 0x00000020U;   /** @brief Receive data register not empty */
  static const uint32_t SWPMI_ISR_TXE_MSK      = 0x00000040U;   /** @brief Transmit data register empty */
  static const uint32_t SWPMI_ISR_TCF_MSK      = 0x00000080U;   /** @brief Transfer complete flag */
  static const uint32_t SWPMI_ISR_SRF_MSK      = 0x00000100U;   /** @brief Slave resume flag */
  static const uint32_t SWPMI_ISR_SUSP_MSK     = 0x00000200U;   /** @brief SUSPEND flag */
  static const uint32_t SWPMI_ISR_DEACTF_MSK   = 0x00000400U;   /** @brief DEACTIVATED flag */
  static const uint32_t SWPMI_ISR_RDYF_MSK     = 0x00000800U;   /** @brief Transceiver ready flag */
  static const uint32_t SWPMI_ICR_CRXBFF_MSK   = 0x00000001U;   /** @brief Clear receive buffer full flag */
  static const uint32_t SWPMI_ICR_CTXBEF_MSK   = 0x00000002U;   /** @brief Clear transmit buffer empty flag */
  static const uint32_t SWPMI_ICR_CRXBERF_MSK  = 0x00000004U;   /** @brief Clear receive CRC error flag */
  static const uint32_t SWPMI_ICR_CRXOVRF_MSK  = 0x00000008U;   /** @brief Clear receive overrun error flag */
  static const uint32_t SWPMI_ICR_CTXUNRF_MSK  = 0x00000010U;   /** @brief Clear transmit underrun error flag */
  static const uint32_t SWPMI_ICR_CTCF_MSK     = 0x00000080U;   /** @brief Clear transfer complete flag */
  static const uint32_t SWPMI_ICR_CSRF_MSK     = 0x00000100U;   /** @brief Clear slave resume flag */
  static const uint32_t SWPMI_ICR_CRDYF_MSK    = 0x00000800U;   /** @brief Clear transceiver ready flag */
  static const uint32_t SWPMI_IER_RXBFIE_MSK   = 0x00000001U;   /** @brief Receive buffer full interrupt enable */
  static const uint32_t SWPMI_IER_TXBEIE_MSK   = 0x00000002U;   /** @brief Transmit buffer empty interrupt enable */
  static const uint32_t SWPMI_IER_RXBERIE_MSK  = 0x00000004U;   /** @brief Receive CRC error interrupt enable */
  static const uint32_t SWPMI_IER_RXOVRIE_MSK  = 0x00000008U;   /** @brief Receive overrun error interrupt enable */
  static const uint32_t SWPMI_IER_TXUNRIE_MSK  = 0x00000010U;   /** @brief Transmit underrun error interrupt enable */
  static const uint32_t SWPMI_IER_RIE_MSK      = 0x00000020U;   /** @brief Receive interrupt enable */
  static const uint32_t SWPMI_IER_TIE_MSK      = 0x00000040U;   /** @brief Transmit interrupt enable */
  static const uint32_t SWPMI_IER_TCIE_MSK     = 0x00000080U;   /** @brief Transmit complete interrupt enable */
  static const uint32_t SWPMI_IER_SRIE_MSK     = 0x00000100U;   /** @brief Slave resume interrupt enable */
  static const uint32_t SWPMI_IER_RDYIE_MSK    = 0x00000800U;   /** @brief Transceiver ready interrupt enable */
  static const uint32_t SWPMI_RFL_RFL_MSK      = 0x0000001FU;   /** @brief Receive frame length */
  static const uint32_t SWPMI_OR_SWP_TBYP_MSK  = 0x00000001U;   /** @brief SWP transceiver bypass */
  static const uint32_t SWPMI_OR_SWP_CLASS_MSK = 0x00000002U;   /** @brief SWP class selection */

  /**** @subsection SWPMI Register Field Positions ****/

  static const int32_t SWPMI_CR_RXDMA_POS     = 0;    /** @brief Reception DMA enable */
  static const int32_t SWPMI_CR_TXDMA_POS     = 1;    /** @brief Transmission DMA enable */
  static const int32_t SWPMI_CR_RXMODE_POS    = 2;    /** @brief Reception buffering mode */
  static const int32_t SWPMI_CR_TXMODE_POS    = 3;    /** @brief Transmission buffering mode */
  static const int32_t SWPMI_CR_LPBK_POS      = 4;    /** @brief Loopback mode enable */
  static const int32_t SWPMI_CR_SWPACT_POS    = 5;    /** @brief Single wire protocol master interface activate */
  static const int32_t SWPMI_CR_DEACT_POS     = 10;   /** @brief Single wire protocol master interface deactivate */
  static const int32_t SWPMI_CR_SWPTEN_POS    = 11;   /** @brief Single wire protocol master transceiver enable */
  static const int32_t SWPMI_BRR_BR_POS       = 0;    /** @brief Bitrate prescaler */
  static const int32_t SWPMI_ISR_RXBFF_POS    = 0;    /** @brief Receive buffer full flag */
  static const int32_t SWPMI_ISR_TXBEF_POS    = 1;    /** @brief Transmit buffer empty flag */
  static const int32_t SWPMI_ISR_RXBERF_POS   = 2;    /** @brief Receive CRC error flag */
  static const int32_t SWPMI_ISR_RXOVRF_POS   = 3;    /** @brief Receive overrun error flag */
  static const int32_t SWPMI_ISR_TXUNRF_POS   = 4;    /** @brief Transmit underrun error flag */
  static const int32_t SWPMI_ISR_RXNE_POS     = 5;    /** @brief Receive data register not empty */
  static const int32_t SWPMI_ISR_TXE_POS      = 6;    /** @brief Transmit data register empty */
  static const int32_t SWPMI_ISR_TCF_POS      = 7;    /** @brief Transfer complete flag */
  static const int32_t SWPMI_ISR_SRF_POS      = 8;    /** @brief Slave resume flag */
  static const int32_t SWPMI_ISR_SUSP_POS     = 9;    /** @brief SUSPEND flag */
  static const int32_t SWPMI_ISR_DEACTF_POS   = 10;   /** @brief DEACTIVATED flag */
  static const int32_t SWPMI_ISR_RDYF_POS     = 11;   /** @brief Transceiver ready flag */
  static const int32_t SWPMI_ICR_CRXBFF_POS   = 0;    /** @brief Clear receive buffer full flag */
  static const int32_t SWPMI_ICR_CTXBEF_POS   = 1;    /** @brief Clear transmit buffer empty flag */
  static const int32_t SWPMI_ICR_CRXBERF_POS  = 2;    /** @brief Clear receive CRC error flag */
  static const int32_t SWPMI_ICR_CRXOVRF_POS  = 3;    /** @brief Clear receive overrun error flag */
  static const int32_t SWPMI_ICR_CTXUNRF_POS  = 4;    /** @brief Clear transmit underrun error flag */
  static const int32_t SWPMI_ICR_CTCF_POS     = 7;    /** @brief Clear transfer complete flag */
  static const int32_t SWPMI_ICR_CSRF_POS     = 8;    /** @brief Clear slave resume flag */
  static const int32_t SWPMI_ICR_CRDYF_POS    = 11;   /** @brief Clear transceiver ready flag */
  static const int32_t SWPMI_IER_RXBFIE_POS   = 0;    /** @brief Receive buffer full interrupt enable */
  static const int32_t SWPMI_IER_TXBEIE_POS   = 1;    /** @brief Transmit buffer empty interrupt enable */
  static const int32_t SWPMI_IER_RXBERIE_POS  = 2;    /** @brief Receive CRC error interrupt enable */
  static const int32_t SWPMI_IER_RXOVRIE_POS  = 3;    /** @brief Receive overrun error interrupt enable */
  static const int32_t SWPMI_IER_TXUNRIE_POS  = 4;    /** @brief Transmit underrun error interrupt enable */
  static const int32_t SWPMI_IER_RIE_POS      = 5;    /** @brief Receive interrupt enable */
  static const int32_t SWPMI_IER_TIE_POS      = 6;    /** @brief Transmit interrupt enable */
  static const int32_t SWPMI_IER_TCIE_POS     = 7;    /** @brief Transmit complete interrupt enable */
  static const int32_t SWPMI_IER_SRIE_POS     = 8;    /** @brief Slave resume interrupt enable */
  static const int32_t SWPMI_IER_RDYIE_POS    = 11;   /** @brief Transceiver ready interrupt enable */
  static const int32_t SWPMI_RFL_RFL_POS      = 0;    /** @brief Receive frame length */
  static const int32_t SWPMI_OR_SWP_TBYP_POS  = 0;    /** @brief SWP transceiver bypass */
  static const int32_t SWPMI_OR_SWP_CLASS_POS = 1;    /** @brief SWP class selection */

  /**********************************************************************************************
   * @section G_TIMx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated G_TIMx Register Pointers ****/

  static RW_ uint32_t* const G_TIMx_CRx_PTR[15][3] = {
    [0]  = {
      [1] = (RW_ uint32_t* const)0x40000000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40000004U,   /** @brief Control register 2 */
    },
    [1]  = {
      [1] = (RW_ uint32_t* const)0x40000400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40000404U,   /** @brief Control register 2 */
    },
    [2]  = {
      [1] = (RW_ uint32_t* const)0x40000800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40000804U,   /** @brief Control register 2 */
    },
    [3]  = {
      [1] = (RW_ uint32_t* const)0x40000C00U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40000C04U,   /** @brief Control register 2 */
    },
    [4]  = {
      [1] = (RW_ uint32_t* const)0x40001800U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40001804U,   /** @brief Control register 2 */
    },
    [5]  = {
      [1] = (RW_ uint32_t* const)0x40001C00U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40001C04U,   /** @brief Control register 2 */
    },
    [6]  = {
      [1] = (RW_ uint32_t* const)0x40002000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40002004U,   /** @brief Control register 2 */
    },
  };

  static RW_ uint32_t* const G_TIMx_SMCR_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000008U,   /** @brief Slave mode control register */
    [3]  = (RW_ uint32_t* const)0x40000408U,   /** @brief Slave mode control register */
    [4]  = (RW_ uint32_t* const)0x40000808U,   /** @brief Slave mode control register */
    [5]  = (RW_ uint32_t* const)0x40000C08U,   /** @brief Slave mode control register */
    [12] = (RW_ uint32_t* const)0x40001808U,   /** @brief Slave mode control register */
    [13] = (RW_ uint32_t* const)0x40001C08U,   /** @brief Slave mode control register */
    [14] = (RW_ uint32_t* const)0x40002008U,   /** @brief Slave mode control register */
  };

  static RW_ uint32_t* const G_TIMx_DIER_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x4000000CU,   /** @brief DMA/Interrupt enable register */
    [3]  = (RW_ uint32_t* const)0x4000040CU,   /** @brief DMA/Interrupt enable register */
    [4]  = (RW_ uint32_t* const)0x4000080CU,   /** @brief DMA/Interrupt enable register */
    [5]  = (RW_ uint32_t* const)0x40000C0CU,   /** @brief DMA/Interrupt enable register */
    [12] = (RW_ uint32_t* const)0x4000180CU,   /** @brief DMA/Interrupt enable register */
    [13] = (RW_ uint32_t* const)0x40001C0CU,   /** @brief DMA/Interrupt enable register */
    [14] = (RW_ uint32_t* const)0x4000200CU,   /** @brief DMA/Interrupt enable register */
  };

  static RW_ uint32_t* const G_TIMx_SR_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000010U,   /** @brief Status register */
    [3]  = (RW_ uint32_t* const)0x40000410U,   /** @brief Status register */
    [4]  = (RW_ uint32_t* const)0x40000810U,   /** @brief Status register */
    [5]  = (RW_ uint32_t* const)0x40000C10U,   /** @brief Status register */
    [12] = (RW_ uint32_t* const)0x40001810U,   /** @brief Status register */
    [13] = (RW_ uint32_t* const)0x40001C10U,   /** @brief Status register */
    [14] = (RW_ uint32_t* const)0x40002010U,   /** @brief Status register */
  };

  static WO_ uint32_t* const G_TIMx_EGR_PTR[15] = {
    [2]  = (WO_ uint32_t* const)0x40000014U,   /** @brief Event generation register */
    [3]  = (WO_ uint32_t* const)0x40000414U,   /** @brief Event generation register */
    [4]  = (WO_ uint32_t* const)0x40000814U,   /** @brief Event generation register */
    [5]  = (WO_ uint32_t* const)0x40000C14U,   /** @brief Event generation register */
    [12] = (WO_ uint32_t* const)0x40001814U,   /** @brief Event generation register */
    [13] = (WO_ uint32_t* const)0x40001C14U,   /** @brief Event generation register */
    [14] = (WO_ uint32_t* const)0x40002014U,   /** @brief Event generation register */
  };

  static RW_ uint32_t* const G_TIMx_CCMRx_OUTPUT_PTR[15][3] = {
    [0]  = {
      [1] = (RW_ uint32_t* const)0x40000018U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4000001CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [1]  = {
      [1] = (RW_ uint32_t* const)0x40000418U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4000041CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [2]  = {
      [1] = (RW_ uint32_t* const)0x40000818U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4000081CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [3]  = {
      [1] = (RW_ uint32_t* const)0x40000C18U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x40000C1CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [4]  = {
      [1] = (RW_ uint32_t* const)0x40001818U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4000181CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [5]  = {
      [1] = (RW_ uint32_t* const)0x40001C18U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x40001C1CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
    [6]  = {
      [1] = (RW_ uint32_t* const)0x40002018U,   /** @brief Capture/compare mode register 1 (output mode) */
      [2] = (RW_ uint32_t* const)0x4000201CU,   /** @brief Capture/compare mode register 2 (output mode) */
    },
  };

  static RW_ uint32_t* const G_TIMx_CCMRx_INPUT_PTR[15][3] = {
    [0]  = {
      [1] = (RW_ uint32_t* const)0x40000018U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4000001CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [1]  = {
      [1] = (RW_ uint32_t* const)0x40000418U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4000041CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [2]  = {
      [1] = (RW_ uint32_t* const)0x40000818U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4000081CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [3]  = {
      [1] = (RW_ uint32_t* const)0x40000C18U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x40000C1CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [4]  = {
      [1] = (RW_ uint32_t* const)0x40001818U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4000181CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [5]  = {
      [1] = (RW_ uint32_t* const)0x40001C18U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x40001C1CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
    [6]  = {
      [1] = (RW_ uint32_t* const)0x40002018U,   /** @brief Capture/compare mode register 1 (input mode) */
      [2] = (RW_ uint32_t* const)0x4000201CU,   /** @brief Capture/compare mode register 2 (input mode) */
    },
  };

  static RW_ uint32_t* const G_TIMx_CCER_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000020U,   /** @brief Capture/compare enable register */
    [3]  = (RW_ uint32_t* const)0x40000420U,   /** @brief Capture/compare enable register */
    [4]  = (RW_ uint32_t* const)0x40000820U,   /** @brief Capture/compare enable register */
    [5]  = (RW_ uint32_t* const)0x40000C20U,   /** @brief Capture/compare enable register */
    [12] = (RW_ uint32_t* const)0x40001820U,   /** @brief Capture/compare enable register */
    [13] = (RW_ uint32_t* const)0x40001C20U,   /** @brief Capture/compare enable register */
    [14] = (RW_ uint32_t* const)0x40002020U,   /** @brief Capture/compare enable register */
  };

  static RW_ uint32_t* const G_TIMx_CNT_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000024U,   /** @brief Counter */
    [3]  = (RW_ uint32_t* const)0x40000424U,   /** @brief Counter */
    [4]  = (RW_ uint32_t* const)0x40000824U,   /** @brief Counter */
    [5]  = (RW_ uint32_t* const)0x40000C24U,   /** @brief Counter */
    [12] = (RW_ uint32_t* const)0x40001824U,   /** @brief Counter */
    [13] = (RW_ uint32_t* const)0x40001C24U,   /** @brief Counter */
    [14] = (RW_ uint32_t* const)0x40002024U,   /** @brief Counter */
  };

  static RW_ uint32_t* const G_TIMx_PSC_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000028U,   /** @brief Prescaler */
    [3]  = (RW_ uint32_t* const)0x40000428U,   /** @brief Prescaler */
    [4]  = (RW_ uint32_t* const)0x40000828U,   /** @brief Prescaler */
    [5]  = (RW_ uint32_t* const)0x40000C28U,   /** @brief Prescaler */
    [12] = (RW_ uint32_t* const)0x40001828U,   /** @brief Prescaler */
    [13] = (RW_ uint32_t* const)0x40001C28U,   /** @brief Prescaler */
    [14] = (RW_ uint32_t* const)0x40002028U,   /** @brief Prescaler */
  };

  static RW_ uint32_t* const G_TIMx_ARR_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x4000002CU,   /** @brief Auto-reload register */
    [3]  = (RW_ uint32_t* const)0x4000042CU,   /** @brief Auto-reload register */
    [4]  = (RW_ uint32_t* const)0x4000082CU,   /** @brief Auto-reload register */
    [5]  = (RW_ uint32_t* const)0x40000C2CU,   /** @brief Auto-reload register */
    [12] = (RW_ uint32_t* const)0x4000182CU,   /** @brief Auto-reload register */
    [13] = (RW_ uint32_t* const)0x40001C2CU,   /** @brief Auto-reload register */
    [14] = (RW_ uint32_t* const)0x4000202CU,   /** @brief Auto-reload register */
  };

  static RW_ uint32_t* const G_TIMx_CCRx_PTR[15][5] = {
    [0]  = {
      [1] = (RW_ uint32_t* const)0x40000034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000038U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000003CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000040U,   /** @brief Capture/compare register 4 */
    },
    [1]  = {
      [1] = (RW_ uint32_t* const)0x40000434U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000438U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000043CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000440U,   /** @brief Capture/compare register 4 */
    },
    [2]  = {
      [1] = (RW_ uint32_t* const)0x40000834U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000838U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000083CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000840U,   /** @brief Capture/compare register 4 */
    },
    [3]  = {
      [1] = (RW_ uint32_t* const)0x40000C34U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40000C38U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x40000C3CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40000C40U,   /** @brief Capture/compare register 4 */
    },
    [4]  = {
      [1] = (RW_ uint32_t* const)0x40001834U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40001838U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000183CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40001840U,   /** @brief Capture/compare register 4 */
    },
    [5]  = {
      [1] = (RW_ uint32_t* const)0x40001C34U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40001C38U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x40001C3CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40001C40U,   /** @brief Capture/compare register 4 */
    },
    [6]  = {
      [1] = (RW_ uint32_t* const)0x40002034U,   /** @brief Capture/compare register 1 */
      [2] = (RW_ uint32_t* const)0x40002038U,   /** @brief Capture/compare register 2 */
      [3] = (RW_ uint32_t* const)0x4000203CU,   /** @brief Capture/compare register 3 */
      [4] = (RW_ uint32_t* const)0x40002040U,   /** @brief Capture/compare register 4 */
    },
  };

  static RW_ uint32_t* const G_TIMx_DCR_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000048U,   /** @brief DMA control register */
    [3]  = (RW_ uint32_t* const)0x40000448U,   /** @brief DMA control register */
    [4]  = (RW_ uint32_t* const)0x40000848U,   /** @brief DMA control register */
    [5]  = (RW_ uint32_t* const)0x40000C48U,   /** @brief DMA control register */
    [12] = (RW_ uint32_t* const)0x40001848U,   /** @brief DMA control register */
    [13] = (RW_ uint32_t* const)0x40001C48U,   /** @brief DMA control register */
    [14] = (RW_ uint32_t* const)0x40002048U,   /** @brief DMA control register */
  };

  static RW_ uint32_t* const G_TIMx_DMAR_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x4000004CU,   /** @brief DMA address for full transfer */
    [3]  = (RW_ uint32_t* const)0x4000044CU,   /** @brief DMA address for full transfer */
    [4]  = (RW_ uint32_t* const)0x4000084CU,   /** @brief DMA address for full transfer */
    [5]  = (RW_ uint32_t* const)0x40000C4CU,   /** @brief DMA address for full transfer */
    [12] = (RW_ uint32_t* const)0x4000184CU,   /** @brief DMA address for full transfer */
    [13] = (RW_ uint32_t* const)0x40001C4CU,   /** @brief DMA address for full transfer */
    [14] = (RW_ uint32_t* const)0x4000204CU,   /** @brief DMA address for full transfer */
  };

  static RW_ uint32_t* const G_TIMx_AF1_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000060U,   /** @brief TIM alternate function option register 1 */
    [3]  = (RW_ uint32_t* const)0x40000460U,   /** @brief TIM alternate function option register 1 */
    [4]  = (RW_ uint32_t* const)0x40000860U,   /** @brief TIM alternate function option register 1 */
    [5]  = (RW_ uint32_t* const)0x40000C60U,   /** @brief TIM alternate function option register 1 */
    [12] = (RW_ uint32_t* const)0x40001860U,   /** @brief TIM alternate function option register 1 */
    [13] = (RW_ uint32_t* const)0x40001C60U,   /** @brief TIM alternate function option register 1 */
    [14] = (RW_ uint32_t* const)0x40002060U,   /** @brief TIM alternate function option register 1 */
  };

  static RW_ uint32_t* const G_TIMx_TISEL_PTR[15] = {
    [2]  = (RW_ uint32_t* const)0x40000068U,   /** @brief TIM timer input selection register */
    [3]  = (RW_ uint32_t* const)0x40000468U,   /** @brief TIM timer input selection register */
    [4]  = (RW_ uint32_t* const)0x40000868U,   /** @brief TIM timer input selection register */
    [5]  = (RW_ uint32_t* const)0x40000C68U,   /** @brief TIM timer input selection register */
    [12] = (RW_ uint32_t* const)0x40001868U,   /** @brief TIM timer input selection register */
    [13] = (RW_ uint32_t* const)0x40001C68U,   /** @brief TIM timer input selection register */
    [14] = (RW_ uint32_t* const)0x40002068U,   /** @brief TIM timer input selection register */
  };

  /**** @subsection G_TIMx Register Field Masks ****/

  static const uint32_t G_TIMx_CRx_UIFREMAP_MSK       = 0x00000800U;   /** @brief UIF status bit remapping */
  static const uint32_t G_TIMx_CRx_CKD_MSK            = 0x00000300U;   /** @brief Clock division */
  static const uint32_t G_TIMx_CRx_ARPE_MSK           = 0x00000080U;   /** @brief Auto-reload preload enable */
  static const uint32_t G_TIMx_CRx_CMS_MSK            = 0x00000060U;   /** @brief Center-aligned mode selection */
  static const uint32_t G_TIMx_CRx_DIR_MSK            = 0x00000010U;   /** @brief Direction */
  static const uint32_t G_TIMx_CRx_OPM_MSK            = 0x00000008U;   /** @brief One-pulse mode */
  static const uint32_t G_TIMx_CRx_URS_MSK            = 0x00000004U;   /** @brief Update request source */
  static const uint32_t G_TIMx_CRx_UDIS_MSK           = 0x00000002U;   /** @brief Update disable */
  static const uint32_t G_TIMx_CRx_CEN_MSK            = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t G_TIMx_SMCR_TS_4_3_MSK        = 0x00300000U;   /** @brief Trigger selection */
  static const uint32_t G_TIMx_SMCR_SMS_3_MSK         = 0x00010000U;   /** @brief Slave mode selection - bit 3 */
  static const uint32_t G_TIMx_SMCR_ETP_MSK           = 0x00008000U;   /** @brief External trigger polarity */
  static const uint32_t G_TIMx_SMCR_ECE_MSK           = 0x00004000U;   /** @brief External clock enable */
  static const uint32_t G_TIMx_SMCR_ETPS_MSK          = 0x00003000U;   /** @brief External trigger prescaler */
  static const uint32_t G_TIMx_SMCR_ETF_MSK           = 0x00000F00U;   /** @brief External trigger filter */
  static const uint32_t G_TIMx_SMCR_MSM_MSK           = 0x00000080U;   /** @brief Master/Slave mode */
  static const uint32_t G_TIMx_SMCR_TS_MSK            = 0x00000070U;   /** @brief Trigger selection */
  static const uint32_t G_TIMx_SMCR_SMS_MSK           = 0x00000007U;   /** @brief Slave mode selection */
  static const uint32_t G_TIMx_DIER_TDE_MSK           = 0x00004000U;   /** @brief Trigger DMA request enable */
  static const uint32_t G_TIMx_DIER_UDE_MSK           = 0x00000100U;   /** @brief Update DMA request enable */
  static const uint32_t G_TIMx_DIER_TIE_MSK           = 0x00000040U;   /** @brief Trigger interrupt enable */
  static const uint32_t G_TIMx_DIER_UIE_MSK           = 0x00000001U;   /** @brief Update interrupt enable */
  static const uint32_t G_TIMx_SR_TIF_MSK             = 0x00000040U;   /** @brief Trigger interrupt flag */
  static const uint32_t G_TIMx_SR_UIF_MSK             = 0x00000001U;   /** @brief Update interrupt flag */
  static const uint32_t G_TIMx_EGR_TG_MSK             = 0x00000040U;   /** @brief Trigger generation */
  static const uint32_t G_TIMx_EGR_UG_MSK             = 0x00000001U;   /** @brief Update generation */
  static const uint32_t G_TIMx_CCMRx_INPUT_IC2PCS_MSK = 0x00000C00U;   /** @brief Input capture 2 prescaler */
  static const uint32_t G_TIMx_CCMRx_INPUT_ICPCS_MSK  = 0x0000000CU;   /** @brief Input capture 1 prescaler */
  static const uint32_t G_TIMx_CNT_CNT_L_MSK          = 0x0000FFFFU;   /** @brief Low counter value */
  static const uint32_t G_TIMx_CNT_CNT_H_MSK          = 0xFFFF0000U;   /** @brief High counter value */
  static const uint32_t G_TIMx_PSC_PSC_MSK            = 0x0000FFFFU;   /** @brief Prescaler value */
  static const uint32_t G_TIMx_ARR_ARR_H_MSK          = 0xFFFF0000U;   /** @brief High auto-reload value */
  static const uint32_t G_TIMx_ARR_ARR_L_MSK          = 0x0000FFFFU;   /** @brief Low auto-reload value */
  static const uint32_t G_TIMx_CCRx_CCR1_H_MSK        = 0xFFFF0000U;   /** @brief High capture/compare 1 value */
  static const uint32_t G_TIMx_CCRx_CCR1_L_MSK        = 0x0000FFFFU;   /** @brief Low capture/compare 1 value */
  static const uint32_t G_TIMx_DCR_DBL_MSK            = 0x00001F00U;   /** @brief DMA burst length */
  static const uint32_t G_TIMx_DCR_DBA_MSK            = 0x0000001FU;   /** @brief DMA base address */
  static const uint32_t G_TIMx_DMAR_DMAB_MSK          = 0x0000FFFFU;   /** @brief DMA register for burst accesses */
  static const uint32_t G_TIMx_AF1_ETRSEL_MSK         = 0x0003C000U;   /** @brief ETR source selection */

  /**** @subsection Enumerated G_TIMx Register Field Masks ****/

  static const uint32_t G_TIMx_DIER_CCxDE_MSK[5] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 DMA request enable */
    [2] = 0x00000400U,   /** @brief Capture/Compare 2 DMA request enable */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 DMA request enable */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 DMA request enable */
  };

  static const uint32_t G_TIMx_DIER_CCxIE_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt enable */
    [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt enable */
    [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt enable */
  };

  static const uint32_t G_TIMx_SR_CCxOF_MSK[5] = {
    [1] = 0x00000200U,   /** @brief Capture/Compare 1 overcapture flag */
    [2] = 0x00000400U,   /** @brief Capture/compare 2 overcapture flag */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 overcapture flag */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 overcapture flag */
  };

  static const uint32_t G_TIMx_SR_CCxIF_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 interrupt flag */
    [2] = 0x00000004U,   /** @brief Capture/Compare 2 interrupt flag */
    [3] = 0x00000008U,   /** @brief Capture/Compare 3 interrupt flag */
    [4] = 0x00000010U,   /** @brief Capture/Compare 4 interrupt flag */
  };

  static const uint32_t G_TIMx_EGR_CCxG_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/compare 1 generation */
    [2] = 0x00000004U,   /** @brief Capture/compare 2 generation */
    [3] = 0x00000008U,   /** @brief Capture/compare 3 generation */
    [4] = 0x00000010U,   /** @brief Capture/compare 4 generation */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_CCxS_MSK[3] = {
    [1] = 0x00000003U,   /** @brief CC1S */
    [2] = 0x00000300U,   /** @brief CC2S */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_OCxFE_MSK[3] = {
    [1] = 0x00000004U,   /** @brief OC1FE */
    [2] = 0x00000400U,   /** @brief OC2FE */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_OCxPE_MSK[3] = {
    [1] = 0x00000008U,   /** @brief OC1PE */
    [2] = 0x00000800U,   /** @brief OC2PE */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_OCxM_MSK[3] = {
    [1] = 0x00000070U,   /** @brief OC1M */
    [2] = 0x00007000U,   /** @brief OC2M */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_OCxCE_MSK[3] = {
    [1] = 0x00000080U,   /** @brief OC1CE */
    [2] = 0x00008000U,   /** @brief OC2CE */
  };

  static const uint32_t G_TIMx_CCMRx_OUTPUT_OCxM_3_MSK[3] = {
    [1] = 0x00010000U,   /** @brief Output compare 1 mode - bit 3 */
    [2] = 0x01000000U,   /** @brief Output compare 2 mode - bit 3 */
  };

  static const uint32_t G_TIMx_CCMRx_INPUT_ICxF_MSK[3] = {
    [1] = 0x000000F0U,   /** @brief Input capture 1 filter */
    [2] = 0x0000F000U,   /** @brief Input capture 2 filter */
  };

  static const uint32_t G_TIMx_CCER_CCxNP_MSK[5] = {
    [1] = 0x00000008U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000080U,   /** @brief Capture/Compare 2 output polarity */
    [3] = 0x00000800U,   /** @brief Capture/Compare 3 output polarity */
    [4] = 0x00008000U,   /** @brief Capture/Compare 4 output polarity */
  };

  static const uint32_t G_TIMx_CCER_CCxP_MSK[5] = {
    [1] = 0x00000002U,   /** @brief Capture/Compare 1 output polarity */
    [2] = 0x00000020U,   /** @brief Capture/Compare 2 output polarity */
    [3] = 0x00000200U,   /** @brief Capture/Compare 3 output polarity */
    [4] = 0x00002000U,   /** @brief Capture/Compare 3 output polarity */
  };

  static const uint32_t G_TIMx_CCER_CCxE_MSK[5] = {
    [1] = 0x00000001U,   /** @brief Capture/Compare 1 output enable */
    [2] = 0x00000010U,   /** @brief Capture/Compare 2 output enable */
    [3] = 0x00000100U,   /** @brief Capture/Compare 3 output enable */
    [4] = 0x00001000U,   /** @brief Capture/Compare 4 output enable */
  };

  static const uint32_t G_TIMx_TISEL_TIxSEL_MSK[5] = {
    [1] = 0x0000000FU,   /** @brief TI1[0] to TI1[15] input selection */
    [2] = 0x00000F00U,   /** @brief TI2[0] to TI2[15] input selection */
    [3] = 0x000F0000U,   /** @brief TI3[0] to TI3[15] input selection */
    [4] = 0x0F000000U,   /** @brief TI4[0] to TI4[15] input selection */
  };

  /**** @subsection G_TIMx Register Field Positions ****/

  static const int32_t G_TIMx_CRx_UIFREMAP_POS       = 11;   /** @brief UIF status bit remapping */
  static const int32_t G_TIMx_CRx_CKD_POS            = 8;    /** @brief Clock division */
  static const int32_t G_TIMx_CRx_ARPE_POS           = 7;    /** @brief Auto-reload preload enable */
  static const int32_t G_TIMx_CRx_CMS_POS            = 5;    /** @brief Center-aligned mode selection */
  static const int32_t G_TIMx_CRx_DIR_POS            = 4;    /** @brief Direction */
  static const int32_t G_TIMx_CRx_OPM_POS            = 3;    /** @brief One-pulse mode */
  static const int32_t G_TIMx_CRx_URS_POS            = 2;    /** @brief Update request source */
  static const int32_t G_TIMx_CRx_UDIS_POS           = 1;    /** @brief Update disable */
  static const int32_t G_TIMx_CRx_CEN_POS            = 0;    /** @brief Counter enable */
  static const int32_t G_TIMx_SMCR_TS_4_3_POS        = 20;   /** @brief Trigger selection */
  static const int32_t G_TIMx_SMCR_SMS_3_POS         = 16;   /** @brief Slave mode selection - bit 3 */
  static const int32_t G_TIMx_SMCR_ETP_POS           = 15;   /** @brief External trigger polarity */
  static const int32_t G_TIMx_SMCR_ECE_POS           = 14;   /** @brief External clock enable */
  static const int32_t G_TIMx_SMCR_ETPS_POS          = 12;   /** @brief External trigger prescaler */
  static const int32_t G_TIMx_SMCR_ETF_POS           = 8;    /** @brief External trigger filter */
  static const int32_t G_TIMx_SMCR_MSM_POS           = 7;    /** @brief Master/Slave mode */
  static const int32_t G_TIMx_SMCR_TS_POS            = 4;    /** @brief Trigger selection */
  static const int32_t G_TIMx_SMCR_SMS_POS           = 0;    /** @brief Slave mode selection */
  static const int32_t G_TIMx_DIER_TDE_POS           = 14;   /** @brief Trigger DMA request enable */
  static const int32_t G_TIMx_DIER_UDE_POS           = 8;    /** @brief Update DMA request enable */
  static const int32_t G_TIMx_DIER_TIE_POS           = 6;    /** @brief Trigger interrupt enable */
  static const int32_t G_TIMx_DIER_UIE_POS           = 0;    /** @brief Update interrupt enable */
  static const int32_t G_TIMx_SR_TIF_POS             = 6;    /** @brief Trigger interrupt flag */
  static const int32_t G_TIMx_SR_UIF_POS             = 0;    /** @brief Update interrupt flag */
  static const int32_t G_TIMx_EGR_TG_POS             = 6;    /** @brief Trigger generation */
  static const int32_t G_TIMx_EGR_UG_POS             = 0;    /** @brief Update generation */
  static const int32_t G_TIMx_CCMRx_INPUT_IC2PCS_POS = 10;   /** @brief Input capture 2 prescaler */
  static const int32_t G_TIMx_CCMRx_INPUT_ICPCS_POS  = 2;    /** @brief Input capture 1 prescaler */
  static const int32_t G_TIMx_CNT_CNT_L_POS          = 0;    /** @brief Low counter value */
  static const int32_t G_TIMx_CNT_CNT_H_POS          = 16;   /** @brief High counter value */
  static const int32_t G_TIMx_PSC_PSC_POS            = 0;    /** @brief Prescaler value */
  static const int32_t G_TIMx_ARR_ARR_H_POS          = 16;   /** @brief High auto-reload value */
  static const int32_t G_TIMx_ARR_ARR_L_POS          = 0;    /** @brief Low auto-reload value */
  static const int32_t G_TIMx_CCRx_CCR1_H_POS        = 16;   /** @brief High capture/compare 1 value */
  static const int32_t G_TIMx_CCRx_CCR1_L_POS        = 0;    /** @brief Low capture/compare 1 value */
  static const int32_t G_TIMx_DCR_DBL_POS            = 8;    /** @brief DMA burst length */
  static const int32_t G_TIMx_DCR_DBA_POS            = 0;    /** @brief DMA base address */
  static const int32_t G_TIMx_DMAR_DMAB_POS          = 0;    /** @brief DMA register for burst accesses */
  static const int32_t G_TIMx_AF1_ETRSEL_POS         = 14;   /** @brief ETR source selection */

  /**** @subsection Enumerated G_TIMx Register Field Positions ****/

  static const int32_t G_TIMx_DIER_CCxDE_POS[5] = {
    [1] = 9,    /** @brief Capture/Compare 1 DMA request enable */
    [2] = 10,   /** @brief Capture/Compare 2 DMA request enable */
    [3] = 11,   /** @brief Capture/Compare 3 DMA request enable */
    [4] = 12,   /** @brief Capture/Compare 4 DMA request enable */
  };

  static const int32_t G_TIMx_DIER_CCxIE_POS[5] = {
    [1] = 1,   /** @brief Capture/Compare 1 interrupt enable */
    [2] = 2,   /** @brief Capture/Compare 2 interrupt enable */
    [3] = 3,   /** @brief Capture/Compare 3 interrupt enable */
    [4] = 4,   /** @brief Capture/Compare 4 interrupt enable */
  };

  static const int32_t G_TIMx_SR_CCxOF_POS[5] = {
    [1] = 9,    /** @brief Capture/Compare 1 overcapture flag */
    [2] = 10,   /** @brief Capture/compare 2 overcapture flag */
    [3] = 11,   /** @brief Capture/Compare 3 overcapture flag */
    [4] = 12,   /** @brief Capture/Compare 4 overcapture flag */
  };

  static const int32_t G_TIMx_SR_CCxIF_POS[5] = {
    [1] = 1,   /** @brief Capture/compare 1 interrupt flag */
    [2] = 2,   /** @brief Capture/Compare 2 interrupt flag */
    [3] = 3,   /** @brief Capture/Compare 3 interrupt flag */
    [4] = 4,   /** @brief Capture/Compare 4 interrupt flag */
  };

  static const int32_t G_TIMx_EGR_CCxG_POS[5] = {
    [1] = 1,   /** @brief Capture/compare 1 generation */
    [2] = 2,   /** @brief Capture/compare 2 generation */
    [3] = 3,   /** @brief Capture/compare 3 generation */
    [4] = 4,   /** @brief Capture/compare 4 generation */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_CCxS_POS[3] = {
    [1] = 0,   /** @brief CC1S */
    [2] = 8,   /** @brief CC2S */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_OCxFE_POS[3] = {
    [1] = 2,    /** @brief OC1FE */
    [2] = 10,   /** @brief OC2FE */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_OCxPE_POS[3] = {
    [1] = 3,    /** @brief OC1PE */
    [2] = 11,   /** @brief OC2PE */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_OCxM_POS[3] = {
    [1] = 4,    /** @brief OC1M */
    [2] = 12,   /** @brief OC2M */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_OCxCE_POS[3] = {
    [1] = 7,    /** @brief OC1CE */
    [2] = 15,   /** @brief OC2CE */
  };

  static const int32_t G_TIMx_CCMRx_OUTPUT_OCxM_3_POS[3] = {
    [1] = 16,   /** @brief Output compare 1 mode - bit 3 */
    [2] = 24,   /** @brief Output compare 2 mode - bit 3 */
  };

  static const int32_t G_TIMx_CCMRx_INPUT_ICxF_POS[3] = {
    [1] = 4,    /** @brief Input capture 1 filter */
    [2] = 12,   /** @brief Input capture 2 filter */
  };

  static const int32_t G_TIMx_CCER_CCxNP_POS[5] = {
    [1] = 3,    /** @brief Capture/Compare 1 output polarity */
    [2] = 7,    /** @brief Capture/Compare 2 output polarity */
    [3] = 11,   /** @brief Capture/Compare 3 output polarity */
    [4] = 15,   /** @brief Capture/Compare 4 output polarity */
  };

  static const int32_t G_TIMx_CCER_CCxP_POS[5] = {
    [1] = 1,    /** @brief Capture/Compare 1 output polarity */
    [2] = 5,    /** @brief Capture/Compare 2 output polarity */
    [3] = 9,    /** @brief Capture/Compare 3 output polarity */
    [4] = 13,   /** @brief Capture/Compare 3 output polarity */
  };

  static const int32_t G_TIMx_CCER_CCxE_POS[5] = {
    [1] = 0,    /** @brief Capture/Compare 1 output enable */
    [2] = 4,    /** @brief Capture/Compare 2 output enable */
    [3] = 8,    /** @brief Capture/Compare 3 output enable */
    [4] = 12,   /** @brief Capture/Compare 4 output enable */
  };

  static const int32_t G_TIMx_TISEL_TIxSEL_POS[5] = {
    [1] = 0,    /** @brief TI1[0] to TI1[15] input selection */
    [2] = 8,    /** @brief TI2[0] to TI2[15] input selection */
    [3] = 16,   /** @brief TI3[0] to TI3[15] input selection */
    [4] = 24,   /** @brief TI4[0] to TI4[15] input selection */
  };

  /**********************************************************************************************
   * @section B_TIMx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated B_TIMx Register Pointers ****/

  static RW_ uint32_t* const B_TIMx_CRx_PTR[8][3] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x40001000U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40001004U,   /** @brief Control register 2 */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x40001400U,   /** @brief Control register 1 */
      [2] = (RW_ uint32_t* const)0x40001404U,   /** @brief Control register 2 */
    },
  };

  static RW_ uint32_t* const B_TIMx_DIER_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x4000100CU,   /** @brief DMA/Interrupt enable register */
    [7] = (RW_ uint32_t* const)0x4000140CU,   /** @brief DMA/Interrupt enable register */
  };

  static RW_ uint32_t* const B_TIMx_SR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40001010U,   /** @brief Status register */
    [7] = (RW_ uint32_t* const)0x40001410U,   /** @brief Status register */
  };

  static WO_ uint32_t* const B_TIMx_EGR_PTR[8] = {
    [6] = (WO_ uint32_t* const)0x40001014U,   /** @brief Event generation register */
    [7] = (WO_ uint32_t* const)0x40001414U,   /** @brief Event generation register */
  };

  static RW_ uint32_t* const B_TIMx_CNT_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40001024U,   /** @brief Counter */
    [7] = (RW_ uint32_t* const)0x40001424U,   /** @brief Counter */
  };

  static RW_ uint32_t* const B_TIMx_PSC_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x40001028U,   /** @brief Prescaler */
    [7] = (RW_ uint32_t* const)0x40001428U,   /** @brief Prescaler */
  };

  static RW_ uint32_t* const B_TIMx_ARR_PTR[8] = {
    [6] = (RW_ uint32_t* const)0x4000102CU,   /** @brief Auto-reload register */
    [7] = (RW_ uint32_t* const)0x4000142CU,   /** @brief Auto-reload register */
  };

  /**** @subsection B_TIMx Register Field Masks ****/

  static const uint32_t B_TIMx_CRx_UIFREMAP_MSK = 0x00000800U;   /** @brief UIF status bit remapping */
  static const uint32_t B_TIMx_CRx_ARPE_MSK     = 0x00000080U;   /** @brief Auto-reload preload enable */
  static const uint32_t B_TIMx_CRx_OPM_MSK      = 0x00000008U;   /** @brief One-pulse mode */
  static const uint32_t B_TIMx_CRx_URS_MSK      = 0x00000004U;   /** @brief Update request source */
  static const uint32_t B_TIMx_CRx_UDIS_MSK     = 0x00000002U;   /** @brief Update disable */
  static const uint32_t B_TIMx_CRx_CEN_MSK      = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t B_TIMx_DIER_UDE_MSK     = 0x00000100U;   /** @brief Update DMA request enable */
  static const uint32_t B_TIMx_DIER_UIE_MSK     = 0x00000001U;   /** @brief Update interrupt enable */
  static const uint32_t B_TIMx_SR_UIF_MSK       = 0x00000001U;   /** @brief Update interrupt flag */
  static const uint32_t B_TIMx_EGR_UG_MSK       = 0x00000001U;   /** @brief Update generation */
  static const uint32_t B_TIMx_CNT_CNT_MSK      = 0x0000FFFFU;   /** @brief Low counter value */
  static const uint32_t B_TIMx_CNT_UIFCPY_MSK   = 0x80000000U;   /** @brief UIF copy */
  static const uint32_t B_TIMx_PSC_PSC_MSK      = 0x0000FFFFU;   /** @brief Prescaler value */
  static const uint32_t B_TIMx_ARR_ARR_MSK      = 0x0000FFFFU;   /** @brief Low auto-reload value */

  /**** @subsection B_TIMx Register Field Positions ****/

  static const int32_t B_TIMx_CRx_UIFREMAP_POS = 11;   /** @brief UIF status bit remapping */
  static const int32_t B_TIMx_CRx_ARPE_POS     = 7;    /** @brief Auto-reload preload enable */
  static const int32_t B_TIMx_CRx_OPM_POS      = 3;    /** @brief One-pulse mode */
  static const int32_t B_TIMx_CRx_URS_POS      = 2;    /** @brief Update request source */
  static const int32_t B_TIMx_CRx_UDIS_POS     = 1;    /** @brief Update disable */
  static const int32_t B_TIMx_CRx_CEN_POS      = 0;    /** @brief Counter enable */
  static const int32_t B_TIMx_DIER_UDE_POS     = 8;    /** @brief Update DMA request enable */
  static const int32_t B_TIMx_DIER_UIE_POS     = 0;    /** @brief Update interrupt enable */
  static const int32_t B_TIMx_SR_UIF_POS       = 0;    /** @brief Update interrupt flag */
  static const int32_t B_TIMx_EGR_UG_POS       = 0;    /** @brief Update generation */
  static const int32_t B_TIMx_CNT_CNT_POS      = 0;    /** @brief Low counter value */
  static const int32_t B_TIMx_CNT_UIFCPY_POS   = 31;   /** @brief UIF copy */
  static const int32_t B_TIMx_PSC_PSC_POS      = 0;    /** @brief Prescaler value */
  static const int32_t B_TIMx_ARR_ARR_POS      = 0;    /** @brief Low auto-reload value */

  /**********************************************************************************************
   * @section NVIC Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated NVIC Register Pointers ****/

  static RW_ uint32_t* const NVIC_ISERx_PTR[4] = {
    [0] = (RW_ uint32_t* const)0xE000E100U,   /** @brief Interrupt set-enable register */
    [1] = (RW_ uint32_t* const)0xE000E104U,   /** @brief Interrupt set-enable register */
    [2] = (RW_ uint32_t* const)0xE000E108U,   /** @brief Interrupt set-enable register */
    [3] = (RW_ uint32_t* const)0xE000E10CU,   /** @brief Interrupt set-enable register */
  };

  static RW_ uint32_t* const NVIC_ICERx_PTR[4] = {
    [0] = (RW_ uint32_t* const)0xE000E180U,   /** @brief Interrupt clear-enable register */
    [1] = (RW_ uint32_t* const)0xE000E184U,   /** @brief Interrupt clear-enable register */
    [2] = (RW_ uint32_t* const)0xE000E188U,   /** @brief Interrupt clear-enable register */
    [3] = (RW_ uint32_t* const)0xE000E18CU,   /** @brief Interrupt clear-enable register */
  };

  static RW_ uint32_t* const NVIC_ISPRx_PTR[4] = {
    [0] = (RW_ uint32_t* const)0xE000E200U,   /** @brief Interrupt set-pending register */
    [1] = (RW_ uint32_t* const)0xE000E204U,   /** @brief Interrupt set-pending register */
    [2] = (RW_ uint32_t* const)0xE000E208U,   /** @brief Interrupt set-pending register */
    [3] = (RW_ uint32_t* const)0xE000E20CU,   /** @brief Interrupt set-pending register */
  };

  static RW_ uint32_t* const NVIC_ICPRx_PTR[4] = {
    [0] = (RW_ uint32_t* const)0xE000E280U,   /** @brief Interrupt clear-pending register */
    [1] = (RW_ uint32_t* const)0xE000E284U,   /** @brief Interrupt clear-pending register */
    [2] = (RW_ uint32_t* const)0xE000E288U,   /** @brief Interrupt clear-pending register */
    [3] = (RW_ uint32_t* const)0xE000E2C0U,   /** @brief Interrupt clear-pending register */
  };

  static RO_ uint32_t* const NVIC_IABRx_PTR[4] = {
    [0] = (RO_ uint32_t* const)0xE000E300U,   /** @brief Interrupt active bit register */
    [1] = (RO_ uint32_t* const)0xE000E304U,   /** @brief Interrupt active bit register */
    [2] = (RO_ uint32_t* const)0xE000E308U,   /** @brief Interrupt active bit register */
    [3] = (RO_ uint32_t* const)0xE000E30CU,   /** @brief Interrupt active bit register */
  };

  static RW_ uint32_t* const NVIC_IPRx_PTR[39] = {
    [0]  = (RW_ uint32_t* const)0xE000E400U,   /** @brief Interrupt priority register */
    [1]  = (RW_ uint32_t* const)0xE000E404U,   /** @brief Interrupt priority register */
    [2]  = (RW_ uint32_t* const)0xE000E408U,   /** @brief Interrupt priority register */
    [3]  = (RW_ uint32_t* const)0xE000E40CU,   /** @brief Interrupt priority register */
    [4]  = (RW_ uint32_t* const)0xE000E410U,   /** @brief Interrupt priority register */
    [5]  = (RW_ uint32_t* const)0xE000E414U,   /** @brief Interrupt priority register */
    [6]  = (RW_ uint32_t* const)0xE000E418U,   /** @brief Interrupt priority register */
    [7]  = (RW_ uint32_t* const)0xE000E41CU,   /** @brief Interrupt priority register */
    [8]  = (RW_ uint32_t* const)0xE000E420U,   /** @brief Interrupt priority register */
    [9]  = (RW_ uint32_t* const)0xE000E424U,   /** @brief Interrupt priority register */
    [10] = (RW_ uint32_t* const)0xE000E428U,   /** @brief Interrupt priority register */
    [11] = (RW_ uint32_t* const)0xE000E42CU,   /** @brief Interrupt priority register */
    [12] = (RW_ uint32_t* const)0xE000E430U,   /** @brief Interrupt priority register */
    [13] = (RW_ uint32_t* const)0xE000E434U,   /** @brief Interrupt priority register */
    [14] = (RW_ uint32_t* const)0xE000E438U,   /** @brief Interrupt priority register */
    [15] = (RW_ uint32_t* const)0xE000E43CU,   /** @brief Interrupt priority register */
    [16] = (RW_ uint32_t* const)0xE000E440U,   /** @brief Interrupt priority register */
    [17] = (RW_ uint32_t* const)0xE000E444U,   /** @brief Interrupt priority register */
    [18] = (RW_ uint32_t* const)0xE000E448U,   /** @brief Interrupt priority register */
    [19] = (RW_ uint32_t* const)0xE000E44CU,   /** @brief Interrupt priority register */
    [20] = (RW_ uint32_t* const)0xE000E450U,   /** @brief Interrupt priority register */
    [21] = (RW_ uint32_t* const)0xE000E454U,   /** @brief Interrupt priority register */
    [22] = (RW_ uint32_t* const)0xE000E458U,   /** @brief Interrupt priority register */
    [23] = (RW_ uint32_t* const)0xE000E45CU,   /** @brief Interrupt priority register */
    [24] = (RW_ uint32_t* const)0xE000E460U,   /** @brief Interrupt priority register */
    [25] = (RW_ uint32_t* const)0xE000E464U,   /** @brief Interrupt priority register */
    [26] = (RW_ uint32_t* const)0xE000E468U,   /** @brief Interrupt priority register */
    [27] = (RW_ uint32_t* const)0xE000E46CU,   /** @brief Interrupt priority register */
    [28] = (RW_ uint32_t* const)0xE000E470U,   /** @brief Interrupt priority register */
    [29] = (RW_ uint32_t* const)0xE000E474U,   /** @brief Interrupt priority register */
    [30] = (RW_ uint32_t* const)0xE000E478U,   /** @brief Interrupt priority register */
    [31] = (RW_ uint32_t* const)0xE000E47CU,   /** @brief Interrupt priority register */
    [32] = (RW_ uint32_t* const)0xE000E480U,   /** @brief Interrupt priority register */
    [33] = (RW_ uint32_t* const)0xE000E484U,   /** @brief Interrupt priority register */
    [34] = (RW_ uint32_t* const)0xE000E488U,   /** @brief Interrupt priority register */
    [35] = (RW_ uint32_t* const)0xE000E48CU,   /** @brief Interrupt priority register */
    [36] = (RW_ uint32_t* const)0xE000E490U,   /** @brief Interrupt priority register */
    [37] = (RW_ uint32_t* const)0xE000E494U,   /** @brief Interrupt priority register */
    [38] = (RW_ uint32_t* const)0xE000E498U,   /** @brief Interrupt priority register */
  };

  /**** @subsection Enumerated NVIC Register Field Masks ****/

  static const uint32_t NVIC_IPRx_IPR_Nx_MSK[4] = {
    [0] = 0x000000FFU,   /** @brief IPR_N0 */
    [1] = 0x0000FF00U,   /** @brief IPR_N1 */
    [2] = 0x00FF0000U,   /** @brief IPR_N2 */
    [3] = 0xFF000000U,   /** @brief IPR_N3 */
  };

  /**** @subsection Enumerated NVIC Register Field Positions ****/

  static const int32_t NVIC_IPRx_IPR_Nx_POS[4] = {
    [0] = 0,    /** @brief IPR_N0 */
    [1] = 8,    /** @brief IPR_N1 */
    [2] = 16,   /** @brief IPR_N2 */
    [3] = 24,   /** @brief IPR_N3 */
  };

  /**********************************************************************************************
   * @section xPU Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated xPU Register Pointers ****/

  static RO_ uint32_t* const xPU_MPU_TYPER_PTR[13] = {
    [5]  = (RO_ uint32_t* const)0xE000EF34U,   /** @brief Floating-point context control register */
    [12] = (RO_ uint32_t* const)0xE000ED90U,   /** @brief MPU type register */
  };

  static RO_ uint32_t* const xPU_MPU_CTRL_PTR[13] = {
    [5]  = (RO_ uint32_t* const)0xE000EF38U,   /** @brief Floating-point context address register */
    [12] = (RO_ uint32_t* const)0xE000ED94U,   /** @brief MPU control register */
  };

  static RW_ uint32_t* const xPU_MPU_RNR_PTR[13] = {
    [5]  = (RW_ uint32_t* const)0xE000EF3CU,   /** @brief Floating-point status control register */
    [12] = (RW_ uint32_t* const)0xE000ED98U,   /** @brief MPU region number register */
  };

  static RW_ uint32_t* const xPU_MPU_RBAR_PTR[13] = {
    [12] = (RW_ uint32_t* const)0xE000ED9CU,   /** @brief MPU region base address register */
  };

  static RW_ uint32_t* const xPU_MPU_RASR_PTR[13] = {
    [12] = (RW_ uint32_t* const)0xE000EDA0U,   /** @brief MPU region attribute and size register */
  };

  /**** @subsection xPU Register Field Masks ****/

  static const uint32_t xPU_MPU_TYPER_SEPARATE_MSK  = 0x00000001U;   /** @brief Separate flag */
  static const uint32_t xPU_MPU_TYPER_DREGION_MSK   = 0x0000FF00U;   /** @brief Number of MPU data regions */
  static const uint32_t xPU_MPU_TYPER_IREGION_MSK   = 0x00FF0000U;   /** @brief Number of MPU instruction regions */
  static const uint32_t xPU_MPU_CTRL_ENABLE_MSK     = 0x00000001U;   /** @brief Enables the MPU */
  static const uint32_t xPU_MPU_CTRL_HFNMIENA_MSK   = 0x00000002U;   /** @brief Enables the operation of MPU during hard fault */
  static const uint32_t xPU_MPU_CTRL_PRIVDEFENA_MSK = 0x00000004U;   /** @brief Enable priviliged software access to default memory map */
  static const uint32_t xPU_MPU_RNR_REGION_MSK      = 0x000000FFU;   /** @brief MPU region */
  static const uint32_t xPU_MPU_RBAR_REGION_MSK     = 0x0000000FU;   /** @brief MPU region field */
  static const uint32_t xPU_MPU_RBAR_VALID_MSK      = 0x00000010U;   /** @brief MPU region number valid */
  static const uint32_t xPU_MPU_RBAR_ADDR_MSK       = 0xFFFFFFE0U;   /** @brief Region base address field */
  static const uint32_t xPU_MPU_RASR_ENABLE_MSK     = 0x00000001U;   /** @brief Region enable bit. */
  static const uint32_t xPU_MPU_RASR_SIZE_MSK       = 0x0000003EU;   /** @brief Size of the MPU protection region */
  static const uint32_t xPU_MPU_RASR_SRD_MSK        = 0x0000FF00U;   /** @brief Subregion disable bits */
  static const uint32_t xPU_MPU_RASR_B_MSK          = 0x00010000U;   /** @brief Memory attribute */
  static const uint32_t xPU_MPU_RASR_C_MSK          = 0x00020000U;   /** @brief Memory attribute */
  static const uint32_t xPU_MPU_RASR_S_MSK          = 0x00040000U;   /** @brief Shareable memory attribute */
  static const uint32_t xPU_MPU_RASR_TEX_MSK        = 0x00380000U;   /** @brief Memory attribute */
  static const uint32_t xPU_MPU_RASR_AP_MSK         = 0x07000000U;   /** @brief Access permission */
  static const uint32_t xPU_MPU_RASR_XN_MSK         = 0x10000000U;   /** @brief Instruction access disable bit */

  /**** @subsection xPU Register Field Positions ****/

  static const int32_t xPU_MPU_TYPER_SEPARATE_POS  = 0;    /** @brief Separate flag */
  static const int32_t xPU_MPU_TYPER_DREGION_POS   = 8;    /** @brief Number of MPU data regions */
  static const int32_t xPU_MPU_TYPER_IREGION_POS   = 16;   /** @brief Number of MPU instruction regions */
  static const int32_t xPU_MPU_CTRL_ENABLE_POS     = 0;    /** @brief Enables the MPU */
  static const int32_t xPU_MPU_CTRL_HFNMIENA_POS   = 1;    /** @brief Enables the operation of MPU during hard fault */
  static const int32_t xPU_MPU_CTRL_PRIVDEFENA_POS = 2;    /** @brief Enable priviliged software access to default memory map */
  static const int32_t xPU_MPU_RNR_REGION_POS      = 0;    /** @brief MPU region */
  static const int32_t xPU_MPU_RBAR_REGION_POS     = 0;    /** @brief MPU region field */
  static const int32_t xPU_MPU_RBAR_VALID_POS      = 4;    /** @brief MPU region number valid */
  static const int32_t xPU_MPU_RBAR_ADDR_POS       = 5;    /** @brief Region base address field */
  static const int32_t xPU_MPU_RASR_ENABLE_POS     = 0;    /** @brief Region enable bit. */
  static const int32_t xPU_MPU_RASR_SIZE_POS       = 1;    /** @brief Size of the MPU protection region */
  static const int32_t xPU_MPU_RASR_SRD_POS        = 8;    /** @brief Subregion disable bits */
  static const int32_t xPU_MPU_RASR_B_POS          = 16;   /** @brief Memory attribute */
  static const int32_t xPU_MPU_RASR_C_POS          = 17;   /** @brief Memory attribute */
  static const int32_t xPU_MPU_RASR_S_POS          = 18;   /** @brief Shareable memory attribute */
  static const int32_t xPU_MPU_RASR_TEX_POS        = 19;   /** @brief Memory attribute */
  static const int32_t xPU_MPU_RASR_AP_POS         = 24;   /** @brief Access permission */
  static const int32_t xPU_MPU_RASR_XN_POS         = 28;   /** @brief Instruction access disable bit */

  /**********************************************************************************************
   * @section STK Register Information
   **********************************************************************************************/

  /**** @subsection STK Register Pointers ****/

  static RW_ uint32_t* const STK_CSR_PTR   = (RW_ uint32_t* const)0xE000E010U;   /** @brief SysTick control and status register */
  static RW_ uint32_t* const STK_RVR_PTR   = (RW_ uint32_t* const)0xE000E014U;   /** @brief SysTick reload value register */
  static RW_ uint32_t* const STK_CVR_PTR   = (RW_ uint32_t* const)0xE000E018U;   /** @brief SysTick current value register */
  static RW_ uint32_t* const STK_CALIB_PTR = (RW_ uint32_t* const)0xE000E01CU;   /** @brief SysTick calibration value register */

  /**** @subsection STK Register Field Masks ****/

  static const uint32_t STK_CSR_ENABLE_MSK    = 0x00000001U;   /** @brief Counter enable */
  static const uint32_t STK_CSR_TICKINT_MSK   = 0x00000002U;   /** @brief SysTick exception request enable */
  static const uint32_t STK_CSR_CLKSOURCE_MSK = 0x00000004U;   /** @brief Clock source selection */
  static const uint32_t STK_CSR_COUNTFLAG_MSK = 0x00010000U;   /** @brief COUNTFLAG */
  static const uint32_t STK_RVR_RELOAD_MSK    = 0x00FFFFFFU;   /** @brief RELOAD value */
  static const uint32_t STK_CVR_CURRENT_MSK   = 0x00FFFFFFU;   /** @brief Current counter value */
  static const uint32_t STK_CALIB_TENMS_MSK   = 0x00FFFFFFU;   /** @brief Calibration value */
  static const uint32_t STK_CALIB_SKEW_MSK    = 0x40000000U;   /** @brief SKEW flag: indicates whether the TENMS value is exact */
  static const uint32_t STK_CALIB_NOREF_MSK   = 0x80000000U;   /** @brief NOREF flag. Reads as zero */

  /**** @subsection STK Register Field Positions ****/

  static const int32_t STK_CSR_ENABLE_POS    = 0;    /** @brief Counter enable */
  static const int32_t STK_CSR_TICKINT_POS   = 1;    /** @brief SysTick exception request enable */
  static const int32_t STK_CSR_CLKSOURCE_POS = 2;    /** @brief Clock source selection */
  static const int32_t STK_CSR_COUNTFLAG_POS = 16;   /** @brief COUNTFLAG */
  static const int32_t STK_RVR_RELOAD_POS    = 0;    /** @brief RELOAD value */
  static const int32_t STK_CVR_CURRENT_POS   = 0;    /** @brief Current counter value */
  static const int32_t STK_CALIB_TENMS_POS   = 0;    /** @brief Calibration value */
  static const int32_t STK_CALIB_SKEW_POS    = 30;   /** @brief SKEW flag: indicates whether the TENMS value is exact */
  static const int32_t STK_CALIB_NOREF_POS   = 31;   /** @brief NOREF flag. Reads as zero */

  /**********************************************************************************************
   * @section NVIC_STIR Register Information
   **********************************************************************************************/

  /**** @subsection NVIC_STIR Register Pointers ****/

  static RW_ uint32_t* const NVIC_STIR_STIR_PTR = (RW_ uint32_t* const)0xE000EF00U;   /** @brief Software trigger interrupt register */

  /**** @subsection NVIC_STIR Register Field Masks ****/

  static const uint32_t NVIC_STIR_STIR_INTID_MSK = 0x000001FFU;   /** @brief Software generated interrupt ID */

  /**** @subsection NVIC_STIR Register Field Positions ****/

  static const int32_t NVIC_STIR_STIR_INTID_POS = 0;   /** @brief Software generated interrupt ID */

  /**********************************************************************************************
   * @section FPU_CPACR Register Information
   **********************************************************************************************/

  /**** @subsection FPU_CPACR Register Pointers ****/

  static RW_ uint32_t* const FPU_CPACR_CPACR_PTR = (RW_ uint32_t* const)0xE000ED88U;   /** @brief Coprocessor access control register */

  /**** @subsection FPU_CPACR Register Field Masks ****/

  static const uint32_t FPU_CPACR_CPACR_CP_MSK = 0x00F00000U;   /** @brief CP */

  /**** @subsection FPU_CPACR Register Field Positions ****/

  static const int32_t FPU_CPACR_CPACR_CP_POS = 20;   /** @brief CP */

  /**********************************************************************************************
   * @section SCB_ACTRL Register Information
   **********************************************************************************************/

  /**** @subsection SCB_ACTRL Register Pointers ****/

  static RW_ uint32_t* const SCB_ACTRL_ACTRL_PTR = (RW_ uint32_t* const)0xE000E008U;   /** @brief Auxiliary control register */

  /**** @subsection SCB_ACTRL Register Field Masks ****/

  static const uint32_t SCB_ACTRL_ACTRL_DISFOLD_MSK        = 0x00000004U;   /** @brief DISFOLD */
  static const uint32_t SCB_ACTRL_ACTRL_FPEXCODIS_MSK      = 0x00000400U;   /** @brief FPEXCODIS */
  static const uint32_t SCB_ACTRL_ACTRL_DISRAMODE_MSK      = 0x00000800U;   /** @brief DISRAMODE */
  static const uint32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_MSK = 0x00001000U;   /** @brief DISITMATBFLUSH */

  /**** @subsection SCB_ACTRL Register Field Positions ****/

  static const int32_t SCB_ACTRL_ACTRL_DISFOLD_POS        = 2;    /** @brief DISFOLD */
  static const int32_t SCB_ACTRL_ACTRL_FPEXCODIS_POS      = 10;   /** @brief FPEXCODIS */
  static const int32_t SCB_ACTRL_ACTRL_DISRAMODE_POS      = 11;   /** @brief DISRAMODE */
  static const int32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH_POS = 12;   /** @brief DISITMATBFLUSH */

  /**********************************************************************************************
   * @section SCB Register Information
   **********************************************************************************************/

  /**** @subsection SCB Register Pointers ****/

  static RO_ uint32_t* const SCB_CPUID_PTR                = (RO_ uint32_t* const)0xE000ED00U;   /** @brief CPUID base register */
  static RW_ uint32_t* const SCB_ICSR_PTR                 = (RW_ uint32_t* const)0xE000ED04U;   /** @brief Interrupt control and state register */
  static RW_ uint32_t* const SCB_VTOR_PTR                 = (RW_ uint32_t* const)0xE000ED08U;   /** @brief Vector table offset register */
  static RW_ uint32_t* const SCB_AIRCR_PTR                = (RW_ uint32_t* const)0xE000ED0CU;   /** @brief Application interrupt and reset control register */
  static RW_ uint32_t* const SCB_SCR_PTR                  = (RW_ uint32_t* const)0xE000ED10U;   /** @brief System control register */
  static RW_ uint32_t* const SCB_CCR_PTR                  = (RW_ uint32_t* const)0xE000ED14U;   /** @brief Configuration and control register */
  static RW_ uint32_t* const SCB_SHCRS_PTR                = (RW_ uint32_t* const)0xE000ED24U;   /** @brief System handler control and state register */
  static RW_ uint32_t* const SCB_CFSR_UFSR_BFSR_MMFSR_PTR = (RW_ uint32_t* const)0xE000ED28U;   /** @brief Configurable fault status register */
  static RW_ uint32_t* const SCB_HFSR_PTR                 = (RW_ uint32_t* const)0xE000ED2CU;   /** @brief Hard fault status register */
  static RW_ uint32_t* const SCB_MMFAR_PTR                = (RW_ uint32_t* const)0xE000ED34U;   /** @brief Memory management fault address register */
  static RW_ uint32_t* const SCB_BFAR_PTR                 = (RW_ uint32_t* const)0xE000ED38U;   /** @brief Bus fault address register */

  /**** @subsection Enumerated SCB Register Pointers ****/

  static RW_ uint32_t* const SCB_SHPRx_PTR[4] = {
    [1] = (RW_ uint32_t* const)0xE000ED18U,   /** @brief System handler priority registers */
    [2] = (RW_ uint32_t* const)0xE000ED1CU,   /** @brief System handler priority registers */
    [3] = (RW_ uint32_t* const)0xE000ED20U,   /** @brief System handler priority registers */
  };

  /**** @subsection SCB Register Field Masks ****/

  static const uint32_t SCB_CPUID_REVISION_MSK                   = 0x0000000FU;   /** @brief Revision number */
  static const uint32_t SCB_CPUID_PARTNO_MSK                     = 0x0000FFF0U;   /** @brief Part number of the processor */
  static const uint32_t SCB_CPUID_CONSTANT_MSK                   = 0x000F0000U;   /** @brief Reads as 0xf */
  static const uint32_t SCB_CPUID_VARIANT_MSK                    = 0x00F00000U;   /** @brief Variant number */
  static const uint32_t SCB_CPUID_IMPLEMENTER_MSK                = 0xFF000000U;   /** @brief Implementer code */
  static const uint32_t SCB_ICSR_VECTACTIVE_MSK                  = 0x000001FFU;   /** @brief Active vector */
  static const uint32_t SCB_ICSR_RETTOBASE_MSK                   = 0x00000800U;   /** @brief Return to base level */
  static const uint32_t SCB_ICSR_VECTPENDING_MSK                 = 0x0007F000U;   /** @brief Pending vector */
  static const uint32_t SCB_ICSR_ISRPENDING_MSK                  = 0x00400000U;   /** @brief Interrupt pending flag */
  static const uint32_t SCB_ICSR_PENDSTCLR_MSK                   = 0x02000000U;   /** @brief SysTick exception clear-pending bit */
  static const uint32_t SCB_ICSR_PENDSTSET_MSK                   = 0x04000000U;   /** @brief SysTick exception set-pending bit */
  static const uint32_t SCB_ICSR_PENDSVCLR_MSK                   = 0x08000000U;   /** @brief PendSV clear-pending bit */
  static const uint32_t SCB_ICSR_PENDSVSET_MSK                   = 0x10000000U;   /** @brief PendSV set-pending bit */
  static const uint32_t SCB_ICSR_NMIPENDSET_MSK                  = 0x80000000U;   /** @brief NMI set-pending bit. */
  static const uint32_t SCB_VTOR_TBLOFF_MSK                      = 0x3FFFFE00U;   /** @brief Vector table base offset field */
  static const uint32_t SCB_AIRCR_VECTRESET_MSK                  = 0x00000001U;   /** @brief VECTRESET */
  static const uint32_t SCB_AIRCR_VECTCLRACTIVE_MSK              = 0x00000002U;   /** @brief VECTCLRACTIVE */
  static const uint32_t SCB_AIRCR_SYSRESETREQ_MSK                = 0x00000004U;   /** @brief SYSRESETREQ */
  static const uint32_t SCB_AIRCR_PRIGROUP_MSK                   = 0x00000700U;   /** @brief PRIGROUP */
  static const uint32_t SCB_AIRCR_ENDIANESS_MSK                  = 0x00008000U;   /** @brief ENDIANESS */
  static const uint32_t SCB_AIRCR_VECTKEYSTAT_MSK                = 0xFFFF0000U;   /** @brief Register key */
  static const uint32_t SCB_SCR_SLEEPONEXIT_MSK                  = 0x00000002U;   /** @brief SLEEPONEXIT */
  static const uint32_t SCB_SCR_SLEEPDEEP_MSK                    = 0x00000004U;   /** @brief SLEEPDEEP */
  static const uint32_t SCB_SCR_SEVEONPEND_MSK                   = 0x00000010U;   /** @brief Send event on pending bit */
  static const uint32_t SCB_CCR_NONBASETHRDENA_MSK               = 0x00000001U;   /** @brief Configures how the processor enters thread mode */
  static const uint32_t SCB_CCR_USERSETMPEND_MSK                 = 0x00000002U;   /** @brief USERSETMPEND */
  static const uint32_t SCB_CCR_UNALIGN__TRP_MSK                 = 0x00000008U;   /** @brief UNALIGN_ TRP */
  static const uint32_t SCB_CCR_DIV_0_TRP_MSK                    = 0x00000010U;   /** @brief DIV_0_TRP */
  static const uint32_t SCB_CCR_BFHFNMIGN_MSK                    = 0x00000100U;   /** @brief BFHFNMIGN */
  static const uint32_t SCB_CCR_STKALIGN_MSK                     = 0x00000200U;   /** @brief STKALIGN */
  static const uint32_t SCB_CCR_DC_MSK                           = 0x00010000U;   /** @brief DC */
  static const uint32_t SCB_CCR_IC_MSK                           = 0x00020000U;   /** @brief IC */
  static const uint32_t SCB_CCR_BP_MSK                           = 0x00040000U;   /** @brief BP */
  static const uint32_t SCB_SHCRS_MEMFAULTACT_MSK                = 0x00000001U;   /** @brief Memory management fault exception active bit */
  static const uint32_t SCB_SHCRS_BUSFAULTACT_MSK                = 0x00000002U;   /** @brief Bus fault exception active bit */
  static const uint32_t SCB_SHCRS_USGFAULTACT_MSK                = 0x00000008U;   /** @brief Usage fault exception active bit */
  static const uint32_t SCB_SHCRS_SVCALLACT_MSK                  = 0x00000080U;   /** @brief SVC call active bit */
  static const uint32_t SCB_SHCRS_MONITORACT_MSK                 = 0x00000100U;   /** @brief Debug monitor active bit */
  static const uint32_t SCB_SHCRS_PENDSVACT_MSK                  = 0x00000400U;   /** @brief PendSV exception active bit */
  static const uint32_t SCB_SHCRS_SYSTICKACT_MSK                 = 0x00000800U;   /** @brief SysTick exception active bit */
  static const uint32_t SCB_SHCRS_USGFAULTPENDED_MSK             = 0x00001000U;   /** @brief Usage fault exception pending bit */
  static const uint32_t SCB_SHCRS_MEMFAULTPENDED_MSK             = 0x00002000U;   /** @brief Memory management fault exception pending bit */
  static const uint32_t SCB_SHCRS_BUSFAULTPENDED_MSK             = 0x00004000U;   /** @brief Bus fault exception pending bit */
  static const uint32_t SCB_SHCRS_SVCALLPENDED_MSK               = 0x00008000U;   /** @brief SVC call pending bit */
  static const uint32_t SCB_SHCRS_MEMFAULTENA_MSK                = 0x00010000U;   /** @brief Memory management fault enable bit */
  static const uint32_t SCB_SHCRS_BUSFAULTENA_MSK                = 0x00020000U;   /** @brief Bus fault enable bit */
  static const uint32_t SCB_SHCRS_USGFAULTENA_MSK                = 0x00040000U;   /** @brief Usage fault enable bit */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_MSK    = 0x00000001U;   /** @brief IACCVIOL */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_MSK    = 0x00000002U;   /** @brief DACCVIOL */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_MSK   = 0x00000008U;   /** @brief MUNSTKERR */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_MSK     = 0x00000010U;   /** @brief MSTKERR */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_MSK     = 0x00000020U;   /** @brief MLSPERR */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_MSK   = 0x00000080U;   /** @brief MMARVALID */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_MSK     = 0x00000100U;   /** @brief Instruction bus error */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_MSK   = 0x00000200U;   /** @brief Precise data bus error */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_MSK = 0x00000400U;   /** @brief Imprecise data bus error */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_MSK    = 0x00000800U;   /** @brief Bus fault on unstacking for a return from exception */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_MSK      = 0x00001000U;   /** @brief Bus fault on stacking for exception entry */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_MSK      = 0x00002000U;   /** @brief Bus fault on floating-point lazy state preservation */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_MSK   = 0x00008000U;   /** @brief Bus fault address register (BFAR) valid flag */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_MSK  = 0x00010000U;   /** @brief Undefined instruction usage fault */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_MSK    = 0x00020000U;   /** @brief Invalid state usage fault */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_MSK       = 0x00040000U;   /** @brief Invalid PC load usage fault */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_MSK        = 0x00080000U;   /** @brief No coprocessor usage fault. */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_MSK   = 0x01000000U;   /** @brief Unaligned access usage fault */
  static const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_MSK   = 0x02000000U;   /** @brief Divide by zero usage fault */
  static const uint32_t SCB_HFSR_VECTTBL_MSK                     = 0x00000002U;   /** @brief Vector table hard fault */
  static const uint32_t SCB_HFSR_FORCED_MSK                      = 0x40000000U;   /** @brief Forced hard fault */
  static const uint32_t SCB_HFSR_DEBUG_VT_MSK                    = 0x80000000U;   /** @brief Reserved for debug use */

  /**** @subsection Enumerated SCB Register Field Masks ****/

  static const uint32_t SCB_SHPRx_PRI_x_MSK[7] = {
    [4] = 0x000000FFU,   /** @brief Priority of system handler 4 */
    [5] = 0x0000FF00U,   /** @brief Priority of system handler 5 */
    [6] = 0x00FF0000U,   /** @brief Priority of system handler 6 */
  };

  /**** @subsection SCB Register Field Positions ****/

  static const int32_t SCB_CPUID_REVISION_POS                   = 0;    /** @brief Revision number */
  static const int32_t SCB_CPUID_PARTNO_POS                     = 4;    /** @brief Part number of the processor */
  static const int32_t SCB_CPUID_CONSTANT_POS                   = 16;   /** @brief Reads as 0xf */
  static const int32_t SCB_CPUID_VARIANT_POS                    = 20;   /** @brief Variant number */
  static const int32_t SCB_CPUID_IMPLEMENTER_POS                = 24;   /** @brief Implementer code */
  static const int32_t SCB_ICSR_VECTACTIVE_POS                  = 0;    /** @brief Active vector */
  static const int32_t SCB_ICSR_RETTOBASE_POS                   = 11;   /** @brief Return to base level */
  static const int32_t SCB_ICSR_VECTPENDING_POS                 = 12;   /** @brief Pending vector */
  static const int32_t SCB_ICSR_ISRPENDING_POS                  = 22;   /** @brief Interrupt pending flag */
  static const int32_t SCB_ICSR_PENDSTCLR_POS                   = 25;   /** @brief SysTick exception clear-pending bit */
  static const int32_t SCB_ICSR_PENDSTSET_POS                   = 26;   /** @brief SysTick exception set-pending bit */
  static const int32_t SCB_ICSR_PENDSVCLR_POS                   = 27;   /** @brief PendSV clear-pending bit */
  static const int32_t SCB_ICSR_PENDSVSET_POS                   = 28;   /** @brief PendSV set-pending bit */
  static const int32_t SCB_ICSR_NMIPENDSET_POS                  = 31;   /** @brief NMI set-pending bit. */
  static const int32_t SCB_VTOR_TBLOFF_POS                      = 9;    /** @brief Vector table base offset field */
  static const int32_t SCB_AIRCR_VECTRESET_POS                  = 0;    /** @brief VECTRESET */
  static const int32_t SCB_AIRCR_VECTCLRACTIVE_POS              = 1;    /** @brief VECTCLRACTIVE */
  static const int32_t SCB_AIRCR_SYSRESETREQ_POS                = 2;    /** @brief SYSRESETREQ */
  static const int32_t SCB_AIRCR_PRIGROUP_POS                   = 8;    /** @brief PRIGROUP */
  static const int32_t SCB_AIRCR_ENDIANESS_POS                  = 15;   /** @brief ENDIANESS */
  static const int32_t SCB_AIRCR_VECTKEYSTAT_POS                = 16;   /** @brief Register key */
  static const int32_t SCB_SCR_SLEEPONEXIT_POS                  = 1;    /** @brief SLEEPONEXIT */
  static const int32_t SCB_SCR_SLEEPDEEP_POS                    = 2;    /** @brief SLEEPDEEP */
  static const int32_t SCB_SCR_SEVEONPEND_POS                   = 4;    /** @brief Send event on pending bit */
  static const int32_t SCB_CCR_NONBASETHRDENA_POS               = 0;    /** @brief Configures how the processor enters thread mode */
  static const int32_t SCB_CCR_USERSETMPEND_POS                 = 1;    /** @brief USERSETMPEND */
  static const int32_t SCB_CCR_UNALIGN__TRP_POS                 = 3;    /** @brief UNALIGN_ TRP */
  static const int32_t SCB_CCR_DIV_0_TRP_POS                    = 4;    /** @brief DIV_0_TRP */
  static const int32_t SCB_CCR_BFHFNMIGN_POS                    = 8;    /** @brief BFHFNMIGN */
  static const int32_t SCB_CCR_STKALIGN_POS                     = 9;    /** @brief STKALIGN */
  static const int32_t SCB_CCR_DC_POS                           = 16;   /** @brief DC */
  static const int32_t SCB_CCR_IC_POS                           = 17;   /** @brief IC */
  static const int32_t SCB_CCR_BP_POS                           = 18;   /** @brief BP */
  static const int32_t SCB_SHCRS_MEMFAULTACT_POS                = 0;    /** @brief Memory management fault exception active bit */
  static const int32_t SCB_SHCRS_BUSFAULTACT_POS                = 1;    /** @brief Bus fault exception active bit */
  static const int32_t SCB_SHCRS_USGFAULTACT_POS                = 3;    /** @brief Usage fault exception active bit */
  static const int32_t SCB_SHCRS_SVCALLACT_POS                  = 7;    /** @brief SVC call active bit */
  static const int32_t SCB_SHCRS_MONITORACT_POS                 = 8;    /** @brief Debug monitor active bit */
  static const int32_t SCB_SHCRS_PENDSVACT_POS                  = 10;   /** @brief PendSV exception active bit */
  static const int32_t SCB_SHCRS_SYSTICKACT_POS                 = 11;   /** @brief SysTick exception active bit */
  static const int32_t SCB_SHCRS_USGFAULTPENDED_POS             = 12;   /** @brief Usage fault exception pending bit */
  static const int32_t SCB_SHCRS_MEMFAULTPENDED_POS             = 13;   /** @brief Memory management fault exception pending bit */
  static const int32_t SCB_SHCRS_BUSFAULTPENDED_POS             = 14;   /** @brief Bus fault exception pending bit */
  static const int32_t SCB_SHCRS_SVCALLPENDED_POS               = 15;   /** @brief SVC call pending bit */
  static const int32_t SCB_SHCRS_MEMFAULTENA_POS                = 16;   /** @brief Memory management fault enable bit */
  static const int32_t SCB_SHCRS_BUSFAULTENA_POS                = 17;   /** @brief Bus fault enable bit */
  static const int32_t SCB_SHCRS_USGFAULTENA_POS                = 18;   /** @brief Usage fault enable bit */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL_POS    = 0;    /** @brief IACCVIOL */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL_POS    = 1;    /** @brief DACCVIOL */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR_POS   = 3;    /** @brief MUNSTKERR */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR_POS     = 4;    /** @brief MSTKERR */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR_POS     = 5;    /** @brief MLSPERR */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID_POS   = 7;    /** @brief MMARVALID */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR_POS     = 8;    /** @brief Instruction bus error */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR_POS   = 9;    /** @brief Precise data bus error */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR_POS = 10;   /** @brief Imprecise data bus error */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR_POS    = 11;   /** @brief Bus fault on unstacking for a return from exception */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR_POS      = 12;   /** @brief Bus fault on stacking for exception entry */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR_POS      = 13;   /** @brief Bus fault on floating-point lazy state preservation */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID_POS   = 15;   /** @brief Bus fault address register (BFAR) valid flag */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR_POS  = 16;   /** @brief Undefined instruction usage fault */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE_POS    = 17;   /** @brief Invalid state usage fault */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC_POS       = 18;   /** @brief Invalid PC load usage fault */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP_POS        = 19;   /** @brief No coprocessor usage fault. */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED_POS   = 24;   /** @brief Unaligned access usage fault */
  static const int32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO_POS   = 25;   /** @brief Divide by zero usage fault */
  static const int32_t SCB_HFSR_VECTTBL_POS                     = 1;    /** @brief Vector table hard fault */
  static const int32_t SCB_HFSR_FORCED_POS                      = 30;   /** @brief Forced hard fault */
  static const int32_t SCB_HFSR_DEBUG_VT_POS                    = 31;   /** @brief Reserved for debug use */

  /**** @subsection Enumerated SCB Register Field Positions ****/

  static const int32_t SCB_SHPRx_PRI_x_POS[7] = {
    [4] = 0,    /** @brief Priority of system handler 4 */
    [5] = 8,    /** @brief Priority of system handler 5 */
    [6] = 16,   /** @brief Priority of system handler 6 */
  };

  /**********************************************************************************************
   * @section PF Register Information
   **********************************************************************************************/

  /**** @subsection PF Register Pointers ****/

  static RO_ uint32_t* const PF_CLIDR_PTR  = (RO_ uint32_t* const)0xE000ED78U;   /** @brief Cache level ID register */
  static RO_ uint32_t* const PF_CTR_PTR    = (RO_ uint32_t* const)0xE000ED7CU;   /** @brief Cache type register */
  static RO_ uint32_t* const PF_CCSIDR_PTR = (RO_ uint32_t* const)0xE000ED80U;   /** @brief Cache size ID register */

  /**** @subsection PF Register Field Masks ****/

  static const uint32_t PF_CLIDR_LOUIS_MSK          = 0x00E00000U;   /** @brief LoUIS */
  static const uint32_t PF_CLIDR_LOC_MSK            = 0x07000000U;   /** @brief LoC */
  static const uint32_t PF_CLIDR_LOU_MSK            = 0x38000000U;   /** @brief LoU */
  static const uint32_t PF_CTR__IMINLINE_MSK        = 0x0000000FU;   /** @brief IminLine */
  static const uint32_t PF_CTR_DMINLINE_MSK         = 0x000F0000U;   /** @brief DMinLine */
  static const uint32_t PF_CTR_ERG_MSK              = 0x00F00000U;   /** @brief ERG */
  static const uint32_t PF_CTR_CWG_MSK              = 0x0F000000U;   /** @brief CWG */
  static const uint32_t PF_CTR_FORMAT_MSK           = 0xE0000000U;   /** @brief Format */
  static const uint32_t PF_CCSIDR_LINESIZE_MSK      = 0x00000007U;   /** @brief LineSize */
  static const uint32_t PF_CCSIDR_ASSOCIATIVITY_MSK = 0x00001FF8U;   /** @brief Associativity */
  static const uint32_t PF_CCSIDR_NUMSETS_MSK       = 0x0FFFE000U;   /** @brief NumSets */
  static const uint32_t PF_CCSIDR_WA_MSK            = 0x10000000U;   /** @brief WA */
  static const uint32_t PF_CCSIDR_RA_MSK            = 0x20000000U;   /** @brief RA */
  static const uint32_t PF_CCSIDR_WB_MSK            = 0x40000000U;   /** @brief WB */
  static const uint32_t PF_CCSIDR_WT_MSK            = 0x80000000U;   /** @brief WT */

  /**** @subsection Enumerated PF Register Field Masks ****/

  static const uint32_t PF_CLIDR_CLx_MSK[8] = {
    [1] = 0x00000007U,   /** @brief CL1 */
    [2] = 0x00000038U,   /** @brief CL2 */
    [3] = 0x000001C0U,   /** @brief CL3 */
    [4] = 0x00000E00U,   /** @brief CL4 */
    [5] = 0x00007000U,   /** @brief CL5 */
    [6] = 0x00038000U,   /** @brief CL6 */
    [7] = 0x001C0000U,   /** @brief CL7 */
  };

  /**** @subsection PF Register Field Positions ****/

  static const int32_t PF_CLIDR_LOUIS_POS          = 21;   /** @brief LoUIS */
  static const int32_t PF_CLIDR_LOC_POS            = 24;   /** @brief LoC */
  static const int32_t PF_CLIDR_LOU_POS            = 27;   /** @brief LoU */
  static const int32_t PF_CTR__IMINLINE_POS        = 0;    /** @brief IminLine */
  static const int32_t PF_CTR_DMINLINE_POS         = 16;   /** @brief DMinLine */
  static const int32_t PF_CTR_ERG_POS              = 20;   /** @brief ERG */
  static const int32_t PF_CTR_CWG_POS              = 24;   /** @brief CWG */
  static const int32_t PF_CTR_FORMAT_POS           = 29;   /** @brief Format */
  static const int32_t PF_CCSIDR_LINESIZE_POS      = 0;    /** @brief LineSize */
  static const int32_t PF_CCSIDR_ASSOCIATIVITY_POS = 3;    /** @brief Associativity */
  static const int32_t PF_CCSIDR_NUMSETS_POS       = 13;   /** @brief NumSets */
  static const int32_t PF_CCSIDR_WA_POS            = 28;   /** @brief WA */
  static const int32_t PF_CCSIDR_RA_POS            = 29;   /** @brief RA */
  static const int32_t PF_CCSIDR_WB_POS            = 30;   /** @brief WB */
  static const int32_t PF_CCSIDR_WT_POS            = 31;   /** @brief WT */

  /**** @subsection Enumerated PF Register Field Positions ****/

  static const int32_t PF_CLIDR_CLx_POS[8] = {
    [1] = 0,    /** @brief CL1 */
    [2] = 3,    /** @brief CL2 */
    [3] = 6,    /** @brief CL3 */
    [4] = 9,    /** @brief CL4 */
    [5] = 12,   /** @brief CL5 */
    [6] = 15,   /** @brief CL6 */
    [7] = 18,   /** @brief CL7 */
  };

  /**********************************************************************************************
   * @section AC Register Information
   **********************************************************************************************/

  /**** @subsection AC Register Pointers ****/

  static RW_ uint32_t* const AC_ITCMCR_PTR = (RW_ uint32_t* const)0xE000EF90U;   /** @brief Instruction and data tightly-coupled memory control registers */
  static RW_ uint32_t* const AC_DTCMCR_PTR = (RW_ uint32_t* const)0xE000EF94U;   /** @brief Instruction and data tightly-coupled memory control registers */
  static RW_ uint32_t* const AC_AHBPCR_PTR = (RW_ uint32_t* const)0xE000EF98U;   /** @brief AHBP control register */
  static RW_ uint32_t* const AC_CACR_PTR   = (RW_ uint32_t* const)0xE000EF9CU;   /** @brief Auxiliary cache control register */
  static RW_ uint32_t* const AC_AHBSCR_PTR = (RW_ uint32_t* const)0xE000EFA0U;   /** @brief AHB slave control register */
  static RW_ uint32_t* const AC_ABFSR_PTR  = (RW_ uint32_t* const)0xE000EFA8U;   /** @brief Auxiliary bus fault status register */

  /**** @subsection AC Register Field Masks ****/

  static const uint32_t AC_ITCMCR_EN_MSK        = 0x00000001U;   /** @brief EN */
  static const uint32_t AC_ITCMCR_RMW_MSK       = 0x00000002U;   /** @brief RMW */
  static const uint32_t AC_ITCMCR_RETEN_MSK     = 0x00000004U;   /** @brief RETEN */
  static const uint32_t AC_ITCMCR_SZ_MSK        = 0x00000078U;   /** @brief SZ */
  static const uint32_t AC_DTCMCR_EN_MSK        = 0x00000001U;   /** @brief EN */
  static const uint32_t AC_DTCMCR_RMW_MSK       = 0x00000002U;   /** @brief RMW */
  static const uint32_t AC_DTCMCR_RETEN_MSK     = 0x00000004U;   /** @brief RETEN */
  static const uint32_t AC_DTCMCR_SZ_MSK        = 0x00000078U;   /** @brief SZ */
  static const uint32_t AC_AHBPCR_EN_MSK        = 0x00000001U;   /** @brief EN */
  static const uint32_t AC_AHBPCR_SZ_MSK        = 0x0000000EU;   /** @brief SZ */
  static const uint32_t AC_CACR_SIWT_MSK        = 0x00000001U;   /** @brief SIWT */
  static const uint32_t AC_CACR_ECCEN_MSK       = 0x00000002U;   /** @brief ECCEN */
  static const uint32_t AC_CACR_FORCEWT_MSK     = 0x00000004U;   /** @brief FORCEWT */
  static const uint32_t AC_AHBSCR_CTL_MSK       = 0x00000003U;   /** @brief CTL */
  static const uint32_t AC_AHBSCR_TPRI_MSK      = 0x000007FCU;   /** @brief TPRI */
  static const uint32_t AC_AHBSCR_INITCOUNT_MSK = 0x0000F800U;   /** @brief INITCOUNT */
  static const uint32_t AC_ABFSR_ITCM_MSK       = 0x00000001U;   /** @brief ITCM */
  static const uint32_t AC_ABFSR_DTCM_MSK       = 0x00000002U;   /** @brief DTCM */
  static const uint32_t AC_ABFSR_AHBP_MSK       = 0x00000004U;   /** @brief AHBP */
  static const uint32_t AC_ABFSR_AXIM_MSK       = 0x00000008U;   /** @brief AXIM */
  static const uint32_t AC_ABFSR_EPPB_MSK       = 0x00000010U;   /** @brief EPPB */
  static const uint32_t AC_ABFSR_AXIMTYPE_MSK   = 0x00000300U;   /** @brief AXIMTYPE */

  /**** @subsection AC Register Field Positions ****/

  static const int32_t AC_ITCMCR_EN_POS        = 0;    /** @brief EN */
  static const int32_t AC_ITCMCR_RMW_POS       = 1;    /** @brief RMW */
  static const int32_t AC_ITCMCR_RETEN_POS     = 2;    /** @brief RETEN */
  static const int32_t AC_ITCMCR_SZ_POS        = 3;    /** @brief SZ */
  static const int32_t AC_DTCMCR_EN_POS        = 0;    /** @brief EN */
  static const int32_t AC_DTCMCR_RMW_POS       = 1;    /** @brief RMW */
  static const int32_t AC_DTCMCR_RETEN_POS     = 2;    /** @brief RETEN */
  static const int32_t AC_DTCMCR_SZ_POS        = 3;    /** @brief SZ */
  static const int32_t AC_AHBPCR_EN_POS        = 0;    /** @brief EN */
  static const int32_t AC_AHBPCR_SZ_POS        = 1;    /** @brief SZ */
  static const int32_t AC_CACR_SIWT_POS        = 0;    /** @brief SIWT */
  static const int32_t AC_CACR_ECCEN_POS       = 1;    /** @brief ECCEN */
  static const int32_t AC_CACR_FORCEWT_POS     = 2;    /** @brief FORCEWT */
  static const int32_t AC_AHBSCR_CTL_POS       = 0;    /** @brief CTL */
  static const int32_t AC_AHBSCR_TPRI_POS      = 2;    /** @brief TPRI */
  static const int32_t AC_AHBSCR_INITCOUNT_POS = 11;   /** @brief INITCOUNT */
  static const int32_t AC_ABFSR_ITCM_POS       = 0;    /** @brief ITCM */
  static const int32_t AC_ABFSR_DTCM_POS       = 1;    /** @brief DTCM */
  static const int32_t AC_ABFSR_AHBP_POS       = 2;    /** @brief AHBP */
  static const int32_t AC_ABFSR_AXIM_POS       = 3;    /** @brief AXIM */
  static const int32_t AC_ABFSR_EPPB_POS       = 4;    /** @brief EPPB */
  static const int32_t AC_ABFSR_AXIMTYPE_POS   = 8;    /** @brief AXIMTYPE */

  /**********************************************************************************************
   * @section RAMECCx Register Information
   **********************************************************************************************/

  /**** @subsection Enumerated RAMECCx Register Pointers ****/

  static RW_ uint32_t* const RAMECCx_IER_PTR[4] = {
    [1] = (RW_ uint32_t* const)0x52009000U,   /** @brief RAMECC interrupt enable register */
    [2] = (RW_ uint32_t* const)0x48023000U,   /** @brief RAMECC interrupt enable register */
    [3] = (RW_ uint32_t* const)0x58027000U,   /** @brief RAMECC interrupt enable register */
  };

  static RW_ uint32_t* const RAMECCx_MxCR_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x52009020U,   /** @brief RAMECC monitor x configuration register */
      [2] = (RW_ uint32_t* const)0x52009040U,   /** @brief RAMECC monitor x configuration register */
      [3] = (RW_ uint32_t* const)0x52009060U,   /** @brief RAMECC monitor x configuration register */
      [4] = (RW_ uint32_t* const)0x52009080U,   /** @brief RAMECC monitor x configuration register */
      [5] = (RW_ uint32_t* const)0x520090A0U,   /** @brief RAMECC monitor x configuration register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x48023020U,   /** @brief RAMECC monitor x configuration register */
      [2] = (RW_ uint32_t* const)0x48023040U,   /** @brief RAMECC monitor x configuration register */
      [3] = (RW_ uint32_t* const)0x48023060U,   /** @brief RAMECC monitor x configuration register */
      [4] = (RW_ uint32_t* const)0x48023080U,   /** @brief RAMECC monitor x configuration register */
      [5] = (RW_ uint32_t* const)0x480230A0U,   /** @brief RAMECC monitor x configuration register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58027020U,   /** @brief RAMECC monitor x configuration register */
      [2] = (RW_ uint32_t* const)0x58027040U,   /** @brief RAMECC monitor x configuration register */
    },
  };

  static RW_ uint32_t* const RAMECCx_MxSR_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x52009024U,   /** @brief RAMECC monitor x status register */
      [2] = (RW_ uint32_t* const)0x52009044U,   /** @brief RAMECC monitor x status register */
      [3] = (RW_ uint32_t* const)0x52009064U,   /** @brief RAMECC monitor x status register */
      [4] = (RW_ uint32_t* const)0x52009084U,   /** @brief RAMECC monitor x status register */
      [5] = (RW_ uint32_t* const)0x520090A4U,   /** @brief RAMECC monitor x status register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x48023024U,   /** @brief RAMECC monitor x status register */
      [2] = (RW_ uint32_t* const)0x48023044U,   /** @brief RAMECC monitor x status register */
      [3] = (RW_ uint32_t* const)0x48023064U,   /** @brief RAMECC monitor x status register */
      [4] = (RW_ uint32_t* const)0x48023084U,   /** @brief RAMECC monitor x status register */
      [5] = (RW_ uint32_t* const)0x480230A4U,   /** @brief RAMECC monitor x status register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58027024U,   /** @brief RAMECC monitor x status register */
      [2] = (RW_ uint32_t* const)0x58027044U,   /** @brief RAMECC monitor x status register */
    },
  };

  static RW_ uint32_t* const RAMECCx_MxFAR_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x52009028U,   /** @brief RAMECC monitor x failing address register */
      [2] = (RW_ uint32_t* const)0x52009048U,   /** @brief RAMECC monitor x failing address register */
      [3] = (RW_ uint32_t* const)0x52009068U,   /** @brief RAMECC monitor x failing address register */
      [4] = (RW_ uint32_t* const)0x52009088U,   /** @brief RAMECC monitor x failing address register */
      [5] = (RW_ uint32_t* const)0x520090A8U,   /** @brief RAMECC monitor x failing address register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x48023028U,   /** @brief RAMECC monitor x failing address register */
      [2] = (RW_ uint32_t* const)0x48023048U,   /** @brief RAMECC monitor x failing address register */
      [3] = (RW_ uint32_t* const)0x48023068U,   /** @brief RAMECC monitor x failing address register */
      [4] = (RW_ uint32_t* const)0x48023088U,   /** @brief RAMECC monitor x failing address register */
      [5] = (RW_ uint32_t* const)0x480230A8U,   /** @brief RAMECC monitor x failing address register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58027028U,   /** @brief RAMECC monitor x failing address register */
      [2] = (RW_ uint32_t* const)0x58027048U,   /** @brief RAMECC monitor x failing address register */
    },
  };

  static RW_ uint32_t* const RAMECCx_MxFDRL_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x5200902CU,   /** @brief RAMECC monitor x failing data low register */
      [2] = (RW_ uint32_t* const)0x5200904CU,   /** @brief RAMECC monitor x failing data low register */
      [3] = (RW_ uint32_t* const)0x5200906CU,   /** @brief RAMECC monitor x failing data low register */
      [4] = (RW_ uint32_t* const)0x5200908CU,   /** @brief RAMECC monitor x failing data low register */
      [5] = (RW_ uint32_t* const)0x520090ACU,   /** @brief RAMECC monitor x failing data low register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x4802302CU,   /** @brief RAMECC monitor x failing data low register */
      [2] = (RW_ uint32_t* const)0x4802304CU,   /** @brief RAMECC monitor x failing data low register */
      [3] = (RW_ uint32_t* const)0x4802306CU,   /** @brief RAMECC monitor x failing data low register */
      [4] = (RW_ uint32_t* const)0x4802308CU,   /** @brief RAMECC monitor x failing data low register */
      [5] = (RW_ uint32_t* const)0x480230ACU,   /** @brief RAMECC monitor x failing data low register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x5802702CU,   /** @brief RAMECC monitor x failing data low register */
      [2] = (RW_ uint32_t* const)0x5802704CU,   /** @brief RAMECC monitor x failing data low register */
    },
  };

  static RW_ uint32_t* const RAMECCx_MxFDRH_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x52009030U,   /** @brief RAMECC monitor x failing data high register */
      [2] = (RW_ uint32_t* const)0x52009050U,   /** @brief RAMECC monitor x failing data high register */
      [3] = (RW_ uint32_t* const)0x52009070U,   /** @brief RAMECC monitor x failing data high register */
      [4] = (RW_ uint32_t* const)0x52009090U,   /** @brief RAMECC monitor x failing data high register */
      [5] = (RW_ uint32_t* const)0x520090B0U,   /** @brief RAMECC monitor x failing data high register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x48023030U,   /** @brief RAMECC monitor x failing data high register */
      [2] = (RW_ uint32_t* const)0x48023050U,   /** @brief RAMECC monitor x failing data high register */
      [3] = (RW_ uint32_t* const)0x48023070U,   /** @brief RAMECC monitor x failing data high register */
      [4] = (RW_ uint32_t* const)0x48023090U,   /** @brief RAMECC monitor x failing data high register */
      [5] = (RW_ uint32_t* const)0x480230B0U,   /** @brief RAMECC monitor x failing data high register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58027030U,   /** @brief RAMECC monitor x failing data high register */
      [2] = (RW_ uint32_t* const)0x58027050U,   /** @brief RAMECC monitor x failing data high register */
    },
  };

  static RW_ uint32_t* const RAMECCx_MxFECR_PTR[4][6] = {
    [0] = {
      [1] = (RW_ uint32_t* const)0x52009034U,   /** @brief RAMECC monitor x failing ECC error code register */
      [2] = (RW_ uint32_t* const)0x52009058U,   /** @brief RAMECC monitor x failing ECC error code register */
      [3] = (RW_ uint32_t* const)0x5200907CU,   /** @brief RAMECC monitor x failing ECC error code register */
      [4] = (RW_ uint32_t* const)0x52009090U,   /** @brief RAMECC monitor x failing ECC error code register */
      [5] = (RW_ uint32_t* const)0x520090B4U,   /** @brief RAMECC monitor x failing ECC error code register */
    },
    [1] = {
      [1] = (RW_ uint32_t* const)0x48023034U,   /** @brief RAMECC monitor x failing ECC error code register */
      [2] = (RW_ uint32_t* const)0x48023058U,   /** @brief RAMECC monitor x failing ECC error code register */
      [3] = (RW_ uint32_t* const)0x4802307CU,   /** @brief RAMECC monitor x failing ECC error code register */
      [4] = (RW_ uint32_t* const)0x48023090U,   /** @brief RAMECC monitor x failing ECC error code register */
      [5] = (RW_ uint32_t* const)0x480230B4U,   /** @brief RAMECC monitor x failing ECC error code register */
    },
    [2] = {
      [1] = (RW_ uint32_t* const)0x58027034U,   /** @brief RAMECC monitor x failing ECC error code register */
      [2] = (RW_ uint32_t* const)0x58027058U,   /** @brief RAMECC monitor x failing ECC error code register */
    },
  };

  /**** @subsection RAMECCx Register Field Masks ****/

  static const uint32_t RAMECCx_IER_GIE_MSK          = 0x00000001U;   /** @brief Global interrupt enable */
  static const uint32_t RAMECCx_IER_GECCSEIE__MSK    = 0x00000002U;   /** @brief Global ECC single error interrupt enable */
  static const uint32_t RAMECCx_IER_GECCDEIE_MSK     = 0x00000004U;   /** @brief Global ECC double error interrupt enable */
  static const uint32_t RAMECCx_IER_GECCDEBWIE_MSK   = 0x00000008U;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxCR_ECCSEIE_MSK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
  static const uint32_t RAMECCx_MxCR_ECCDEIE_MSK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
  static const uint32_t RAMECCx_MxCR_ECCDEBWIE_MSK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxCR_ECCELEN_MSK     = 0x00000020U;   /** @brief ECC error latching enable */
  static const uint32_t RAMECCx_MxSR_ECCSEIE_MSK     = 0x00000004U;   /** @brief ECC single error interrupt enable */
  static const uint32_t RAMECCx_MxSR_ECCDEIE_MSK     = 0x00000008U;   /** @brief ECC double error interrupt enable */
  static const uint32_t RAMECCx_MxSR_ECCDEBWIE_MSK   = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxSR_ECCELEN_MSK     = 0x00000020U;   /** @brief ECC error latching enable */
  static const uint32_t RAMECCx_MxFAR_ECCSEIE_MSK    = 0x00000004U;   /** @brief ECC single error interrupt enable */
  static const uint32_t RAMECCx_MxFAR_ECCDEIE_MSK    = 0x00000008U;   /** @brief ECC double error interrupt enable */
  static const uint32_t RAMECCx_MxFAR_ECCDEBWIE_MSK  = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxFAR_ECCELEN_MSK    = 0x00000020U;   /** @brief ECC error latching enable */
  static const uint32_t RAMECCx_MxFDRL_ECCSEIE_MSK   = 0x00000004U;   /** @brief ECC single error interrupt enable */
  static const uint32_t RAMECCx_MxFDRL_ECCDEIE_MSK   = 0x00000008U;   /** @brief ECC double error interrupt enable */
  static const uint32_t RAMECCx_MxFDRL_ECCDEBWIE_MSK = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxFDRL_ECCELEN_MSK   = 0x00000020U;   /** @brief ECC error latching enable */
  static const uint32_t RAMECCx_MxFDRH_ECCSEIE_MSK   = 0x00000004U;   /** @brief ECC single error interrupt enable */
  static const uint32_t RAMECCx_MxFDRH_ECCDEIE_MSK   = 0x00000008U;   /** @brief ECC double error interrupt enable */
  static const uint32_t RAMECCx_MxFDRH_ECCDEBWIE_MSK = 0x00000010U;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const uint32_t RAMECCx_MxFDRH_ECCELEN_MSK   = 0x00000020U;   /** @brief ECC error latching enable */
  static const uint32_t RAMECCx_MxFECR_SEDCF_MSK     = 0x00000001U;   /** @brief ECC single error detected and corrected flag */
  static const uint32_t RAMECCx_MxFECR_DEDF_MSK      = 0x00000002U;   /** @brief ECC double error detected flag */
  static const uint32_t RAMECCx_MxFECR_DEBWDF_MSK    = 0x00000004U;   /** @brief ECC double error on byte write (BW) detected flag */

  /**** @subsection RAMECCx Register Field Positions ****/

  static const int32_t RAMECCx_IER_GIE_POS          = 0;   /** @brief Global interrupt enable */
  static const int32_t RAMECCx_IER_GECCSEIE__POS    = 1;   /** @brief Global ECC single error interrupt enable */
  static const int32_t RAMECCx_IER_GECCDEIE_POS     = 2;   /** @brief Global ECC double error interrupt enable */
  static const int32_t RAMECCx_IER_GECCDEBWIE_POS   = 3;   /** @brief Global ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxCR_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
  static const int32_t RAMECCx_MxCR_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
  static const int32_t RAMECCx_MxCR_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxCR_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
  static const int32_t RAMECCx_MxSR_ECCSEIE_POS     = 2;   /** @brief ECC single error interrupt enable */
  static const int32_t RAMECCx_MxSR_ECCDEIE_POS     = 3;   /** @brief ECC double error interrupt enable */
  static const int32_t RAMECCx_MxSR_ECCDEBWIE_POS   = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxSR_ECCELEN_POS     = 5;   /** @brief ECC error latching enable */
  static const int32_t RAMECCx_MxFAR_ECCSEIE_POS    = 2;   /** @brief ECC single error interrupt enable */
  static const int32_t RAMECCx_MxFAR_ECCDEIE_POS    = 3;   /** @brief ECC double error interrupt enable */
  static const int32_t RAMECCx_MxFAR_ECCDEBWIE_POS  = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxFAR_ECCELEN_POS    = 5;   /** @brief ECC error latching enable */
  static const int32_t RAMECCx_MxFDRL_ECCSEIE_POS   = 2;   /** @brief ECC single error interrupt enable */
  static const int32_t RAMECCx_MxFDRL_ECCDEIE_POS   = 3;   /** @brief ECC double error interrupt enable */
  static const int32_t RAMECCx_MxFDRL_ECCDEBWIE_POS = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxFDRL_ECCELEN_POS   = 5;   /** @brief ECC error latching enable */
  static const int32_t RAMECCx_MxFDRH_ECCSEIE_POS   = 2;   /** @brief ECC single error interrupt enable */
  static const int32_t RAMECCx_MxFDRH_ECCDEIE_POS   = 3;   /** @brief ECC double error interrupt enable */
  static const int32_t RAMECCx_MxFDRH_ECCDEBWIE_POS = 4;   /** @brief ECC double error on byte write (BW) interrupt enable */
  static const int32_t RAMECCx_MxFDRH_ECCELEN_POS   = 5;   /** @brief ECC error latching enable */
  static const int32_t RAMECCx_MxFECR_SEDCF_POS     = 0;   /** @brief ECC single error detected and corrected flag */
  static const int32_t RAMECCx_MxFECR_DEDF_POS      = 1;   /** @brief ECC double error detected flag */
  static const int32_t RAMECCx_MxFECR_DEBWDF_POS    = 2;   /** @brief ECC double error on byte write (BW) detected flag */

  /**********************************************************************************************
   * @section ART Register Information
   **********************************************************************************************/

  /**** @subsection ART Register Pointers ****/

  static RW_ uint32_t* const ART_CTR_PTR = (RW_ uint32_t* const)0x40024400U;   /** @brief Control register */

  /**** @subsection ART Register Field Masks ****/

  static const uint32_t ART_CTR_EN_MSK         = 0x00000001U;   /** @brief Cache enable */
  static const uint32_t ART_CTR_PCACHEADDR_MSK = 0x000FFF00U;   /** @brief Cacheable page index */

  /**** @subsection ART Register Field Positions ****/

  static const int32_t ART_CTR_EN_POS         = 0;   /** @brief Cache enable */
  static const int32_t ART_CTR_PCACHEADDR_POS = 8;   /** @brief Cacheable page index */

#if defined(__cplusplus)
  } /* extern "C" */
#endif